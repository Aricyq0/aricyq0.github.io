<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aricyq0.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文是斯坦福大学 cs193p 公开课程第 03 集的相关笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="Stanford cs193p 03｜MVVM">
<meta property="og:url" content="https://aricyq0.github.io/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/index.html">
<meta property="og:site_name" content="Serein">
<meta property="og:description" content="本文是斯坦福大学 cs193p 公开课程第 03 集的相关笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aricyq0.github.io/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/cs193p03_MVVM.png">
<meta property="article:published_time" content="2024-12-06T09:28:10.000Z">
<meta property="article:modified_time" content="2025-04-01T04:04:31.293Z">
<meta property="article:author" content="Serein">
<meta property="article:tag" content="cs193p">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aricyq0.github.io/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/cs193p03_MVVM.png">

<link rel="canonical" href="https://aricyq0.github.io/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Stanford cs193p 03｜MVVM | Serein</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Serein</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/aricyq0" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aricyq0.github.io/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.JPEG">
      <meta itemprop="name" content="Serein">
      <meta itemprop="description" content="Crazy learning, crazy sharing.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Serein">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Stanford cs193p 03｜MVVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-06 17:28:10" itemprop="dateCreated datePublished" datetime="2024-12-06T17:28:10+08:00">2024-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-01 12:04:31" itemprop="dateModified" datetime="2025-04-01T12:04:31+08:00">2025-04-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/code/swift/" itemprop="url" rel="index"><span itemprop="name">swift</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="far fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文是斯坦福大学 cs193p 公开课程第 03 集的相关笔记。</p>
<span id="more"></span>

<blockquote>
<p>本文主要内容转载于：<a target="_blank" rel="noopener" href="https://nwdan.com/my-learning/stanford-cs193p-3.html">闻者通达的个人博客</a></p>
</blockquote>
<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>本节前言：</p>
<blockquote>
<p>Conceptual overview of the architectural paradigm underlying the development of applications for iOS using SwiftUI (known as MVVM). Explanation of a fundamental component of understanding the Swift programming language: its type system. Start to apply both of these to Memorize.</p>
</blockquote>
<p>cs193p 课程网址: <a target="_blank" rel="noopener" href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></p>
<p>推荐的拓展练习教程：todolist MVVM（约 130 分钟） <a target="_blank" rel="noopener" href="https://ur0.jp/jVOQG">https://ur0.jp/jVOQG</a></p>
<hr>
<h2 id="0-本节框架"><a href="#0-本节框架" class="headerlink" title="0. 本节框架"></a>0. 本节框架</h2><ul>
<li><p>MVVM</p>
<p>MVVM 架构简介与特点</p>
</li>
<li><p><code>swift</code> 类型</p>
<ul>
<li><code>struct</code> vs <code>class</code></li>
<li><code>protocol</code></li>
<li>“don’t care” type (aka <code>generics</code>)</li>
<li><code>enum</code>（略，但很重要）</li>
<li><code>functions</code></li>
</ul>
</li>
<li><p>Demo<br>续上节记忆游戏，因 demo 太短，将 demo 合并到了下一篇笔记中。</p>
</li>
</ul>
<h2 id="1-Model-and-UI"><a href="#1-Model-and-UI" class="headerlink" title="1. Model and UI"></a>1. Model and UI</h2><h3 id="1-1-将“逻辑与数据”与“用户界面”分离"><a href="#1-1-将“逻辑与数据”与“用户界面”分离" class="headerlink" title="1.1 将“逻辑与数据”与“用户界面”分离"></a>1.1 将“逻辑与数据”与“用户界面”分离</h3><ul>
<li>SwiftUI 强调将应用程序逻辑和数据与用户界面分离。我们将这些逻辑和数据称为 <strong>模型（Model）</strong>。</li>
<li>模型可以是 <code>struct</code>、<code>SQL</code> 数据库、机器学习代码或其他多种形式的组合。</li>
<li>用户界面基本上只是一个“可参数化”的外壳，由模型提供数据并赋予其生命。</li>
<li><strong>用户界面是模型的可视化表现</strong>。</li>
<li>模型是存放像 <code>isFaceUp</code> 和 <code>cardCount</code> 这样的状态的地方，而这些状态不应该放在 UI 的 <code>@State</code> 中。</li>
<li>SwiftUI 会确保当模型变化影响到用户界面时，用户界面会被重新构建。</li>
</ul>
<h3 id="1-2-将模型连接到用户界面"><a href="#1-2-将模型连接到用户界面" class="headerlink" title="1.2 将模型连接到用户界面"></a>1.2 将模型连接到用户界面</h3><p>在将模型与用户界面连接时，有几种选择：</p>
<ol>
<li><strong>几乎不分离</strong>：极少数情况下，模型可以作为视图中的 <code>@State</code></li>
<li><strong>完全分离</strong>：模型可能仅能通过一个充当“门卫”的 <strong>视图模型（View Model）</strong> <code>class</code> 进行访问</li>
<li><strong>部分分离</strong>：存在一个视图模型 <code>class</code>，但模型仍然可以直接访问</li>
</ol>
<p>这三种选择主要取决于模型的复杂性：</p>
<ul>
<li>一个由 SQL + <code>struct</code> + 其他元素组成的模型，可能会选择第二种方案</li>
<li>如果模型只是一小段简单数据且涉及的逻辑很少，可能会选择第一种方案</li>
<li>介于两者之间的情况可能会考虑第三种方案</li>
</ul>
<p>本节将重点讨论第二种方案（完全分离）。我们将这种连接模型与用户界面的架构称为 <strong>MVVM</strong> （模型-视图-视图模型）。</p>
<ul>
<li><strong>MVVM</strong> 是相对复杂的 SwiftUI 应用的主要架构</li>
<li>第三种方案（部分分离）是对 MVVM 的细微调整</li>
</ul>
<h2 id="2-MVVM"><a href="#2-MVVM" class="headerlink" title="2. MVVM"></a>2. MVVM</h2><h3 id="2-1-MVVM-简介"><a href="#2-1-MVVM-简介" class="headerlink" title="2.1 MVVM 简介"></a>2.1 MVVM 简介</h3><p><strong>MVVM (Model-View-ViewModel)</strong> 是一种架构模式，将视图（UI）和业务逻辑分离，从而提高代码可读性、可维护性和复用性。它将代码分为三个部分：</p>
<ul>
<li><strong>Model（模型层）：</strong> 负责管理数据和业务逻辑。通常是数据模型，可能包含从服务器或本地数据库获取的内容。</li>
<li><strong>View（视图层）：</strong> 负责展示 UI，声明式地描述界面如何响应数据变化。视图只与 ViewModel 交互，而不直接操作 Model。</li>
<li><strong>ViewModel（视图模型层）：</strong> 负责连接 View 和 Model。ViewModel 通过处理数据和业务逻辑，将数据转换为视图需要的形式，并通过绑定的方式通知视图更新。</li>
</ul>
<h3 id="2-2-MVVM-特点"><a href="#2-2-MVVM-特点" class="headerlink" title="2.2 MVVM 特点"></a>2.2 MVVM 特点</h3><ul>
<li>解耦：View 和 Model 相互独立，ViewModel 承担数据转换任务，减少 UI 和业务逻辑的耦合。</li>
<li>数据驱动：ViewModel 中的属性通常是可观察的（例如 SwiftUI 中的 @Published 属性），使得数据变化时自动触发 UI 更新。</li>
<li>单向数据流：Model 更新时，通知 ViewModel，进而通知 View；用户操作从 View 传递到 ViewModel 进行处理。</li>
</ul>
<p><img src="/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/cs193p03_MVVM.png"></p>
<h3 id="2-3-数据流在-MVVM-中的运作"><a href="#2-3-数据流在-MVVM-中的运作" class="headerlink" title="2.3 数据流在 MVVM 中的运作"></a>2.3 数据流在 MVVM 中的运作</h3><ul>
<li><p><strong>从 Model 到 View</strong></p>
<ol>
<li>ViewModel 从 Model 获取数据（如从网络或本地加载）。</li>
<li>ViewModel 通过 @Published 属性将数据暴露给视图。</li>
<li>视图观察 ViewModel，当数据更新时，自动重新渲染。</li>
</ol>
</li>
<li><p><strong>从 View 到 Model</strong></p>
<ol>
<li>用户在视图中进行交互</li>
<li>交互事件触发 ViewModel 的方法</li>
<li>ViewModel 修改 Model 或处理业务逻辑，更新数据后通知视图。</li>
</ol>
</li>
</ul>
<h3 id="2-4-补充举例（非视频内容）"><a href="#2-4-补充举例（非视频内容）" class="headerlink" title="2.4 补充举例（非视频内容）"></a>2.4 补充举例（非视频内容）</h3><p>以下是一个示例，展示如何在 SwiftUI 中实现 MVVM 架构。</p>
<blockquote>
<p>这一部分是为了辅助理解 MVVM 架构，不用实现。</p>
</blockquote>
<h4 id="2-4-1-模型层（Model）"><a href="#2-4-1-模型层（Model）" class="headerlink" title="2.4.1 模型层（Model）"></a>2.4.1 模型层（Model）</h4><p>模型负责表示应用的数据结构。通常是简单的数据类型，可能从服务器或本地数据库加载。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Habit</span>: <span class="title class_ inherited__">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> isCompleted: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-视图模型层（ViewModel）"><a href="#2-4-2-视图模型层（ViewModel）" class="headerlink" title="2.4.2 视图模型层（ViewModel）"></a>2.4.2 视图模型层（ViewModel）</h4><p><code>ViewModel</code> 负责管理业务逻辑和状态，并通过数据绑定将数据暴露给视图。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HabitViewModel</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="comment">// 可观察的属性，视图会自动更新</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> habits: [<span class="type">Habit</span>] <span class="operator">=</span> [</span><br><span class="line">        <span class="type">Habit</span>(id: <span class="number">1</span>, name: <span class="string">&quot;Exercise&quot;</span>, isCompleted: <span class="literal">false</span>),</span><br><span class="line">        <span class="type">Habit</span>(id: <span class="number">2</span>, name: <span class="string">&quot;Read a Book&quot;</span>, isCompleted: <span class="literal">true</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新习惯完成状态</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">toggleHabitCompletion</span>(<span class="keyword">_</span> <span class="params">habit</span>: <span class="type">Habit</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index <span class="operator">=</span> habits.firstIndex(where: &#123; <span class="variable">$0</span>.id <span class="operator">==</span> habit.id &#125;) &#123;</span><br><span class="line">            habits[index].isCompleted.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Published</code>：使得 <code>habits</code> 的变化可以被 SwiftUI 的 <code>View</code> 观察到，从而触发 UI 更新。</li>
<li><strong>方法</strong>：封装了业务逻辑，例如切换习惯完成状态。</li>
</ul>
<h4 id="2-4-3-视图层（View）"><a href="#2-4-3-视图层（View）" class="headerlink" title="2.4.3 视图层（View）"></a>2.4.3 视图层（View）</h4><p>视图是完全声明式的，只关注 UI 和数据的绑定，不直接操作 <code>Model</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HabitListView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> viewModel <span class="operator">=</span> <span class="type">HabitViewModel</span>() <span class="comment">// 创建 ViewModel 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">List</span>(viewModel.habits) &#123; habit <span class="keyword">in</span></span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(habit.name)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Button</span>(action: &#123;</span><br><span class="line">                        viewModel.toggleHabitCompletion(habit) <span class="comment">// 用户操作通知 ViewModel</span></span><br><span class="line">                    &#125;) &#123;</span><br><span class="line">                        <span class="type">Image</span>(systemName: habit.isCompleted <span class="operator">?</span> <span class="string">&quot;checkmark.circle.fill&quot;</span> : <span class="string">&quot;circle&quot;</span>)</span><br><span class="line">                            .foregroundColor(habit.isCompleted <span class="operator">?</span> .green : .gray)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;My Habits&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@StateObject</code>：用于初始化 <code>ViewModel</code>，使视图能够观察其状态变化。</li>
<li><strong>数据绑定</strong>：<code>viewModel.habits</code> 与列表内容绑定，<code>@Published</code> 属性变化时自动更新视图。</li>
<li><strong>用户操作</strong>：通过按钮操作调用 <code>ViewModel</code> 方法，而不直接操作 <code>Model</code>。</li>
</ul>
<h2 id="3-Varieties-of-Types"><a href="#3-Varieties-of-Types" class="headerlink" title="3. Varieties of Types"></a>3. Varieties of Types</h2><h3 id="3-1-struct-and-class"><a href="#3-1-struct-and-class" class="headerlink" title="3.1 struct and class"></a>3.1 struct and class</h3><h4 id="3-1-1-struct-class-共同点"><a href="#3-1-1-struct-class-共同点" class="headerlink" title="3.1.1 struct &amp; class 共同点"></a>3.1.1 struct &amp; class 共同点</h4><p>在 Swift 中，<code>struct</code> 和 <code>class</code> 具有以下特征：</p>
<ul>
<li><p><strong>语法相似</strong>：它们的语法几乎完全相同。</p>
</li>
<li><p><strong>存储属性</strong>（stored vars）：类似于你熟悉的那种存储在内存中的属性，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isFaceUp: <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>计算属性</strong>（computed vars）：其值是通过评估一些代码得出的属性，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常量</strong>（constant lets）：其值不会改变的属性，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColor <span class="operator">=</span> <span class="type">Color</span>.orange</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="type">CardView</span>().foregroundColor(defaultColor)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数</strong>（functions）：可以定义行为，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">multiply</span>(<span class="params">operand</span>: <span class="type">Int</span>, <span class="params">by</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> operand <span class="operator">*</span> by</span><br><span class="line">&#125;</span><br><span class="line">multiply(operand: <span class="number">5</span>, by: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">multiply</span>(<span class="keyword">_</span> <span class="params">operand</span>: <span class="type">Int</span>, <span class="params">by</span> <span class="params">otherOperand</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> operand <span class="operator">*</span> otherOperand</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">5</span>, by: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化器</strong>（initializers）：在创建 <code>struct</code> 或 <code>class</code> 时调用的特殊函数，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RoundedRectangle</span> &#123;</span><br><span class="line">	<span class="keyword">init</span>(<span class="params">cornerRadius</span>: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 cornerRadius 初始化矩形</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">init</span>(<span class="params">cornerSize</span>: <span class="type">CGSize</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 cornerSize 初始化矩形</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-1-2-struct-vs-class-区别"><a href="#3-1-2-struct-vs-class-区别" class="headerlink" title="3.1.2 struct vs class 区别"></a>3.1.2 struct vs class 区别</h4><table>
<thead>
<tr>
<th>struct</th>
<th>class</th>
</tr>
</thead>
<tbody><tr>
<td>值类型</td>
<td>引用类型</td>
</tr>
<tr>
<td>传递或赋值时会被复制</td>
<td>通过指针传递</td>
</tr>
<tr>
<td>复制时写入（只有在被修改时才真正复制）</td>
<td>自动引用计数</td>
</tr>
<tr>
<td>函数式编程</td>
<td>面向对象编程</td>
</tr>
<tr>
<td>不支持继承</td>
<td>支持单继承</td>
</tr>
<tr>
<td>“免费的” <strong>init</strong>初始化所有的 <strong>var</strong></td>
<td>“免费的” <strong>init</strong> 不初始化任何 <strong>var</strong></td>
</tr>
<tr>
<td>可变性是显式的（<strong>var</strong> 与 <strong>let</strong> 的区分）</td>
<td>始终可变</td>
</tr>
<tr>
<td>常用的数据结构</td>
<td>在特定情况下使用</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>值类型 vs 引用类型</strong>：<code>struct</code> 是值类型，这意味着当它们被传递或赋值时，会创建一个全新的副本；而 <code>class</code> 是引用类型，传递或赋值时只是将引用指向同一实例。</p>
</li>
<li><p><strong>复制时写入</strong>：对于 <code>struct</code>，只有在它们被修改时，才会生成新的副本（写时复制），这通常用于优化内存使用。</p>
</li>
<li><p><strong>自动引用计数</strong>：<code>class</code> 的实例会被 Swift 的内存管理系统自动引用计数，这意味着当没有强引用指向某个实例时，它会被自动释放。</p>
</li>
<li><p><strong>函数式编程 vs 面向对象编程</strong>：<code>struct</code> 常用于函数式编程范式，而 <code>class</code> 则广泛用于面向对象编程，后者强调对象的封装和继承。</p>
</li>
<li><p><strong>继承</strong>：<code>struct</code> 不支持继承，因此它不能从其它结构体派生；而 <code>class</code> 支持单层继承，允许子类从父类继承属性和方法。</p>
</li>
<li><p><strong>初始化器</strong>：对于 <code>struct</code>，默认情况下，Swift 会生成一个初始化器，确保所有属性都有默认值；而 <code>class</code> 的默认初始化器不会初始化任何属性，除非你自己定义。</p>
</li>
<li><p><strong>可变性</strong>：在使用 <code>struct</code> 时，变量（<code>var</code>）和常量（<code>let</code>）的定义影响其可变性，因此你需要显式声明；而 <code>class</code> 实例的属性默认是可变的，不论是用 <code>var</code> 还是 <code>let</code>。</p>
</li>
<li><p><strong>使用场景</strong>：在开发中，<code>struct</code> 通常是更常用的选择，这是因为它们提供了更好的内存管理和性能，特别是在需要值传递的场景；而 <code>class</code> 则适合需要共享状态或需要继承的情况。</p>
</li>
</ul>
<blockquote>
<p>截止目前课程所看到的都是 <code>struct</code>，MVVM 架构中的 ViewModel 是 <code>class</code>。</p>
</blockquote>
<h3 id="3-2-Generics-泛型"><a href="#3-2-Generics-泛型" class="headerlink" title="3.2 Generics 泛型"></a>3.2 Generics 泛型</h3><ul>
<li>有时我们不关心具体类型，想操作类型无关的数据结构。</li>
<li>Swift 是强类型语言，所以我们不能使用无类型的变量。解决办法是使用“泛型”。</li>
</ul>
<h4 id="3-2-1-Generics-示例：Array"><a href="#3-2-1-Generics-示例：Array" class="headerlink" title="3.2.1 Generics 示例：Array"></a>3.2.1 Generics 示例：<code>Array</code></h4><ul>
<li><p><code>Array</code> 可以包含多种类型的元素而不关心具体类型。</p>
</li>
<li><p><code>Array</code> 的声明如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>append</code> 的参数是 <code>Element</code>，表示一种“无所谓”类型。</p>
</li>
<li><p>使用 <code>Array</code> 时，我们可以指定具体类型，如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时 Element 为 Int 类型</span></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">a.append(<span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时 Element 为 String 类型</span></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">a.append(<span class="string">&quot;🌼&quot;</span>)</span><br><span class="line">a.append(<span class="string">&quot;🍉&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Element</code> 的类型在使用 <code>Array</code> 时确定。</p>
</li>
<li><p>泛型允许同时使用多个类型参数（如 <code>&lt;Element, Foo&gt;</code>）。</p>
</li>
<li><p>“无所谓”类型称为 <strong>类型参数</strong>。</p>
</li>
</ul>
<p>总之，泛型能让我们在不知道具体类型的情况下灵活操作数据结构。</p>
<h3 id="3-3-protocol-协议"><a href="#3-3-protocol-协议" class="headerlink" title="3.3 protocol 协议"></a>3.3 protocol 协议</h3><h4 id="3-3-1-protocol-协议的特点"><a href="#3-3-1-protocol-协议的特点" class="headerlink" title="3.3.1 protocol 协议的特点"></a>3.3.1 protocol 协议的特点</h4><h5 id="1-protocol-有函数和方法，但不能具体实现或存储"><a href="#1-protocol-有函数和方法，但不能具体实现或存储" class="headerlink" title="1. protocol 有函数和方法，但不能具体实现或存储"></a><strong>1. protocol 有函数和方法，但不能具体实现或存储</strong></h5><p>声明一个协议的语法与 struct 或 class 很相似，只是没有具体实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protocol</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">move</span>(<span class="params">by</span>: <span class="type">Int</span>)</span><br><span class="line"><span class="keyword">var</span> hasMoved: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> distanceFromStart: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>&#123; &#125;</code> 中的内容用于说明该协议的变量是只读（get）还是可读写（get set）。</p>
<p><strong>举例说明</strong></p>
<p>任意类型都可以实现 Moveable 协议，只需要在 struct 内部实现 <code>move(by)</code> 、<code>hasMoved</code> 和 <code>distanceFromStart</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PortableThing</span>: <span class="title class_ inherited__">Moveable</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里必须实现 move(by:)、hasMoved 和 distanceFromStart</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 <code>PortableThing</code> 结构体便符合 <code>Moveable</code> 协议。</p>
<h5 id="2-protocol-协议可以继承其他-protocol"><a href="#2-protocol-协议可以继承其他-protocol" class="headerlink" title="2. protocol 协议可以继承其他 protocol"></a>2. <strong>protocol</strong> 协议可以继承其他 protocol</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Vehicle</span>: <span class="title class_ inherited__">Moveable</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> passengerCount: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里必须实现 move(by:)、hasMoved、distanceFromStart 和 passengerCount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-一个类可以同时实现多个协议"><a href="#3-一个类可以同时实现多个协议" class="headerlink" title="3. 一个类可以同时实现多个协议"></a>3. 一个类可以同时实现多个协议</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_ inherited__">Vehicle</span>, <span class="title class_ inherited__">Impoundable</span>, <span class="title class_ inherited__">Leasable</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里必须实现所有协议中的函数和变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-protocol-协议的用途"><a href="#3-3-2-protocol-协议的用途" class="headerlink" title="3.3.2 protocol 协议的用途"></a>3.3.2 protocol 协议的用途</h4><ol>
<li><p><strong>统一行为定义</strong></p>
<p>协议可以用于定义一组类型的共同行为，而无需关心这些类型的具体实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">fly</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bird</span>: <span class="title class_ inherited__">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">fly</span>() &#123;</span><br><span class="line">	  <span class="built_in">print</span>(<span class="string">&quot;Bird is flying!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Airplane</span>: <span class="title class_ inherited__">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">fly</span>() &#123;</span><br><span class="line">	  <span class="built_in">print</span>(<span class="string">&quot;Airplane is flying!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flyer: [<span class="type">Flyable</span>] <span class="operator">=</span> [<span class="type">Bird</span>(), <span class="type">Airplane</span>()]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> flyer &#123;</span><br><span class="line">  item.fly()  <span class="comment">// 不同类型的对象都可以飞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Flyable 定义了所有可飞行的类型应具备的行为。</li>
<li>通过协议，可以统一处理 Bird 和 Airplane 等符合协议的类型。</li>
</ul>
<p>另外，比如，<code>struct ContentView: View</code>  使得  <code>ContentView</code>  成为一个强大的结构体，虽然需要实现  <code>var body</code>  来满足  <code>View</code>  协议。</p>
</li>
<li><p><strong>协议与泛型</strong></p>
<p>协议可以与泛型结合，约束泛型参数必须符合某些协议，从而提升代码的类型安全性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printDetails</span>&lt;<span class="type">T</span>: <span class="type">CustomStringConvertible</span>&gt;(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">T</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(item.description)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printDetails(<span class="number">42</span>)            <span class="comment">// 输出：42</span></span><br><span class="line">printDetails(<span class="string">&quot;Swift Rocks&quot;</span>) <span class="comment">// 输出：Swift Rocks</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>泛型参数 T 必须符合 CustomStringConvertible 协议。</li>
<li>这种约束确保函数可以使用 description 属性，而不会导致运行时错误。</li>
</ul>
<h4 id="3-3-3-常见协议示例"><a href="#3-3-3-常见协议示例" class="headerlink" title="3.3.3 常见协议示例"></a>3.3.3 常见协议示例</h4><p>常见协议包括：</p>
<ul>
<li><strong>Identifiable</strong></li>
<li><strong>Hashable</strong></li>
<li><strong>Equatable</strong></li>
<li><strong>CustomStringConvertible</strong></li>
<li>特定的协议如 <strong>Animatable</strong>。</li>
</ul>
<h4 id="3-3-4-协议的优点"><a href="#3-3-4-协议的优点" class="headerlink" title="3.3.4 协议的优点"></a>3.3.4 协议的优点</h4><ol>
<li><strong>定义行为的蓝图</strong>：用于统一定义一组行为（方法、属性）。</li>
<li><strong>实现多态性</strong>：使不同类型可以通过统一接口交互。</li>
<li><strong>泛型约束</strong>：提升代码的类型安全性和复用性。</li>
<li><strong>协议扩展</strong>：减少重复代码，为协议提供默认实现。</li>
<li><strong>灵活组合</strong>：通过协议组合构建更强大的接口。</li>
</ol>
<h3 id="3-4-enum"><a href="#3-4-enum" class="headerlink" title="3.4 enum"></a>3.4 <code>enum</code></h3><blockquote>
<p>本节略过，但很重要。</p>
</blockquote>
<h3 id="3-5-Functions"><a href="#3-5-Functions" class="headerlink" title="3.5 Functions"></a>3.5 Functions</h3><p>函数类型可以像其他类型一样使用，由参数类型列表和返回类型组成。语法为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型列表) -&gt; 返回类型</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">square</span>(<span class="params">operand</span>: <span class="type">Double</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> operand <span class="operator">*</span> operand</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> operation <span class="operator">=</span> square <span class="comment">// just assigning a value to the operation vars, nothing more</span></span><br><span class="line"><span class="keyword">let</span> result1 <span class="operator">=</span> operation(<span class="number">4</span>) <span class="comment">// result1 would equal 16</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>square</code> 函数的类型：<code>(Double) -&gt; Double</code>，表示接收一个 <code>Double</code> 参数并返回一个 <code>Doubel</code> 值。</li>
<li><code>operation</code> 是一个变量：存储了函数 <code>square</code>，可以通过变量调用。</li>
</ul>
<p><strong>函数类型示例</strong>：</p>
<ul>
<li><code>(Int, Int) -&gt; Bool</code>：接受两个 Int 类型参数，返回一个 Bool 值。</li>
<li><code>(Double) -&gt; Void</code>：接受一个 Double 类型参数，无返回值。</li>
<li><code>() -&gt; Array&lt;String&gt;</code>：不接受参数，返回一个 String 数组。</li>
<li><code>() -&gt; Void</code>：不接受参数，无返回值（这是一个常见的用法）。</li>
</ul>
<p>在 Swift 中，函数类型可以像其他类型一样使用，可以存储函数并通过变量调用。</p>
<h4 id="3-5-1-闭包类型（Function-as-type）"><a href="#3-5-1-闭包类型（Function-as-type）" class="headerlink" title="3.5.1 闭包类型（Function as type）"></a>3.5.1 闭包类型（Function as type）</h4><p>函数类型也适用于闭包。闭包是未命名的函数，它的语法更加简洁。你可以将闭包存储在变量中，或直接作为函数的参数，通常被称为“内联函数”。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="operator">=</span> &#123; (a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(operation(<span class="number">4</span>, <span class="number">6</span>))  <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure>

<p>在 Swift 中，许多 SwiftUI 的功能（如@ViewBuilders 和 onTapGesture 的动作）都是通过闭包实现的。</p>
<h2 id="4-Demo"><a href="#4-Demo" class="headerlink" title="4. Demo"></a>4. Demo</h2><p>由于 demo 太短（大约只有 15 分钟），将这节课的 demo 合并到下一篇笔记中。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>欣赏此文？求鼓励，求支持！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="Serein 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Serein 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
      <div>
     
       
<div class="my_post_copyright">
  <div style="text-align:center;color: #ccc;font-size:14px;">------ 版权声明 ------</div>
  <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  
  <p><span>原始链接:</span><a href="/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/" title="Stanford cs193p 03｜MVVM">https://aricyq0.github.io/2024/12/06/Stanford-cs193p-03｜MVVM/</a>
    <button class="copy-button" style="cursor: pointer; margin-left: 6px; border: none; background: none;" title="点击复制文章链接">
      <i class="fa fa-clipboard" aria-label="复制"></i>
    </button>
    <span class="copy-success" style="margin-left: 5px; display: none; color: #999; font-size: 14px;">复制成功</span>
  </p>
  <p><span style="margin-right: 4px;">版权申明:</span>本博客所有文章除特别声明外，均采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">CC BY-NC-SA 4.0</a>许可协议。转载请保留原文链接及作者。</p>  
</div>
<script> 
  document.addEventListener('DOMContentLoaded', function() {
    var clipboard = new ClipboardJS('.copy-button', {
      text: function() {
        return window.location.origin + '/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/';
      }
    });
    
    clipboard.on('success', function(e) {
      var successTip = document.querySelector('.copy-success');
      successTip.style.display = 'inline';
      setTimeout(function() {
        successTip.style.display = 'none';
      }, 1000);
    });
  });
</script>

     
</div>
          
          <div class="post-tags">
              <a href="/tags/cs193p/" rel="tag"><i class="fa fa-tag"></i> cs193p</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/" rel="prev" title="Stanford cs193p 02 | More SwiftUI">
      <i class="fa fa-chevron-left"></i> Stanford cs193p 02 | More SwiftUI
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/" rel="next" title="Stanford cs193p 04｜MVVM 应用">
      Stanford cs193p 04｜MVVM 应用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-%E6%9C%AC%E8%8A%82%E6%A1%86%E6%9E%B6"><span class="nav-text">0. 本节框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Model-and-UI"><span class="nav-text">1. Model and UI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%B0%86%E2%80%9C%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E2%80%9D%E4%B8%8E%E2%80%9C%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E2%80%9D%E5%88%86%E7%A6%BB"><span class="nav-text">1.1 将“逻辑与数据”与“用户界面”分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B0%86%E6%A8%A1%E5%9E%8B%E8%BF%9E%E6%8E%A5%E5%88%B0%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="nav-text">1.2 将模型连接到用户界面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-MVVM"><span class="nav-text">2. MVVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-MVVM-%E7%AE%80%E4%BB%8B"><span class="nav-text">2.1 MVVM 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-MVVM-%E7%89%B9%E7%82%B9"><span class="nav-text">2.2 MVVM 特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9C%A8-MVVM-%E4%B8%AD%E7%9A%84%E8%BF%90%E4%BD%9C"><span class="nav-text">2.3 数据流在 MVVM 中的运作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E8%A1%A5%E5%85%85%E4%B8%BE%E4%BE%8B%EF%BC%88%E9%9D%9E%E8%A7%86%E9%A2%91%E5%86%85%E5%AE%B9%EF%BC%89"><span class="nav-text">2.4 补充举例（非视频内容）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E6%A8%A1%E5%9E%8B%E5%B1%82%EF%BC%88Model%EF%BC%89"><span class="nav-text">2.4.1 模型层（Model）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%B1%82%EF%BC%88ViewModel%EF%BC%89"><span class="nav-text">2.4.2 视图模型层（ViewModel）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E8%A7%86%E5%9B%BE%E5%B1%82%EF%BC%88View%EF%BC%89"><span class="nav-text">2.4.3 视图层（View）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Varieties-of-Types"><span class="nav-text">3. Varieties of Types</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-struct-and-class"><span class="nav-text">3.1 struct and class</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-struct-class-%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-text">3.1.1 struct &amp; class 共同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-struct-vs-class-%E5%8C%BA%E5%88%AB"><span class="nav-text">3.1.2 struct vs class 区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Generics-%E6%B3%9B%E5%9E%8B"><span class="nav-text">3.2 Generics 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-Generics-%E7%A4%BA%E4%BE%8B%EF%BC%9AArray"><span class="nav-text">3.2.1 Generics 示例：Array</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-protocol-%E5%8D%8F%E8%AE%AE"><span class="nav-text">3.3 protocol 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-protocol-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">3.3.1 protocol 协议的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-protocol-%E6%9C%89%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%86%E4%B8%8D%E8%83%BD%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%88%96%E5%AD%98%E5%82%A8"><span class="nav-text">1. protocol 有函数和方法，但不能具体实现或存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-protocol-%E5%8D%8F%E8%AE%AE%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%85%B6%E4%BB%96-protocol"><span class="nav-text">2. protocol 协议可以继承其他 protocol</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E5%8D%8F%E8%AE%AE"><span class="nav-text">3. 一个类可以同时实现多个协议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-protocol-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-text">3.3.2 protocol 协议的用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.3.3 常见协议示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">3.3.4 协议的优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-enum"><span class="nav-text">3.4 enum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Functions"><span class="nav-text">3.5 Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-%E9%97%AD%E5%8C%85%E7%B1%BB%E5%9E%8B%EF%BC%88Function-as-type%EF%BC%89"><span class="nav-text">3.5.1 闭包类型（Function as type）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Demo"><span class="nav-text">4. Demo</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Serein"
      src="/uploads/avatar.JPEG">
  <p class="site-author-name" itemprop="name">Serein</p>
  <div class="site-description" itemprop="description">Crazy learning, crazy sharing.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Aricyq0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Aricyq0" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ari.cyq@gmail.com" title="E-Mail → mailto:ari.cyq@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Serein</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">122k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:51</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
