<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Stanford cs193p 01 | 课程简介及SwiftUI入门</title>
    <url>/2024/11/21/Stanford-cs193p-01%EF%BD%9C%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B%E5%8F%8ASwiftUI%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 01 集的相关笔记。</p>
<span id="more"></span>

<blockquote>
<p>本文主要内容转载于：<a href="https://nwdan.com/my-learning/stanford-cs193p-1.html">闻者通达的个人博客</a></p>
</blockquote>
<h2 id="0-课程介绍"><a href="#0-课程介绍" class="headerlink" title="0. 课程介绍"></a>0. 课程介绍</h2><blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<ul>
<li><strong>课程网址</strong>：<a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></li>
<li><strong>swift 说明文档</strong>：<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/">英文版</a> ｜ <a href="https://swift.bootcss.com/">中文版</a></li>
</ul>
<h3 id="课程要求-🎓"><a href="#课程要求-🎓" class="headerlink" title="课程要求 🎓"></a>课程要求 🎓</h3><ul>
<li>建议：具备编程经验，熟悉多种编程语言</li>
<li>备注：不具备编程经验学习具有挑战</li>
</ul>
<h3 id="学习内容-🖥️"><a href="#学习内容-🖥️" class="headerlink" title="学习内容 🖥️"></a>学习内容 🖥️</h3><ul>
<li>使用 Xcode 导航</li>
<li>理解 SwiftUI 与功能性编程的结构</li>
</ul>
<h3 id="主要项目-📚"><a href="#主要项目-📚" class="headerlink" title="主要项目 📚"></a>主要项目 📚</h3><ul>
<li>创建卡牌游戏应用 Memorize</li>
<li>动画与用户界面设计</li>
</ul>
<hr>
<h2 id="1-SwiftUI-视图构建和代码结构"><a href="#1-SwiftUI-视图构建和代码结构" class="headerlink" title="1. SwiftUI 视图构建和代码结构"></a>1. SwiftUI 视图构建和代码结构</h2><h3 id="1-1-项目准备工作"><a href="#1-1-项目准备工作" class="headerlink" title="1.1 项目准备工作"></a>1.1 项目准备工作</h3><p>熟悉 Xcode 的安装与使用。新建项目及文件，各类文件的作用与区别。</p>
<ol>
<li>新建项目：对于项目名字、组织与识别 ID 的说明。</li>
<li>配置项目属性：设置项目运行的平台有哪些。</li>
<li>新建项目时生成的各文件介绍。</li>
<li>预览代码及代码属性修改器的介绍和其它使用小技巧等。</li>
</ol>
<h3 id="1-2-实例演练"><a href="#1-2-实例演练" class="headerlink" title="1.2 实例演练"></a>1.2 实例演练</h3><p>完整的 “Hello world” 代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">        	<span class="type">Image</span>(systemName:<span class="string">&quot;globe&quot;</span>)</span><br><span class="line">        		.imageScale(.large)</span><br><span class="line">        		.foregroundStyle(.tint)</span><br><span class="line">        	<span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，将按照由上至下，由外至内的方式对这一段代码进行解释。</p>
<h4 id="1-2-1-struct-和-View"><a href="#1-2-1-struct-和-View" class="headerlink" title="1.2.1 struct 和 View"></a>1.2.1 <code>struct</code> 和 <code>View</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个 ContentView 结构体，并符合 View 协议</span></span><br><span class="line">    <span class="comment">//该结构体符合 View 协议意味着：需要提供一个变量 body</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">//some View的意思是返回行为与View相似的元素</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>struct</code> 结构体，它是 swiftUI 的核心。Swift 不是面向对象的编程语言 (Objective-oriented programming)，是函数式编程 (Functional programming)。</li>
<li><code>ContentView</code> 是结构体的名称，<code>struct ContentView: View</code> 意味着 <code>ContentView</code> 结构体像一个 <code>View</code>。</li>
<li><code>View</code> 和 <code>some View</code> 区分：此处的 View 是一个协议（protocol）。</li>
</ul>
<h4 id="1-2-2-var"><a href="#1-2-2-var" class="headerlink" title="1.2.2 var"></a>1.2.2 <code>var</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="comment">//some View的意思是返回行为与View相似的元素</span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>var</code>是一个变量的关键字，body 是变量名。其他变量可能如下所示：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span></span><br><span class="line"><span class="keyword">var</span> s: <span class="type">String</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Int</code> <code>String</code> 是 <code>struct</code> 结构体</li>
<li><code>some View</code> 是某种类型的 <code>View</code>，只要是一个 <code>View</code> 即可，比如 <code>Text</code>、<code>Image</code>、<code>VStack</code> 、<code>HStack</code> 等。</li>
</ul>
<h4 id="1-2-3-计算属性-Computed-Property"><a href="#1-2-3-计算属性-Computed-Property" class="headerlink" title="1.2.3 计算属性 Computed Property"></a>1.2.3 计算属性 <code>Computed Property</code></h4><p>上边我们解释了 <code>var body: some View</code>，接下来看 <code>body</code> 中的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	<span class="type">VStack</span> &#123;</span><br><span class="line">		<span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">			.imageScale(.large)</span><br><span class="line">			.foregroundStyle(.tint)</span><br><span class="line">		<span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	.padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>var body</code> 是一个属性，<code>body</code> 变量的值不会存储在某个地方，而是在每次程序运行时都会计算一次。在 “Hello World” 代码中，它计算的是如下部分：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">	<span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">		.imageScale(.large)</span><br><span class="line">		.foregroundStyle(.tint)</span><br><span class="line">	<span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">.padding()</span><br></pre></td></tr></table></figure>

<h4 id="1-2-4-视图结构-VStack"><a href="#1-2-4-视图结构-VStack" class="headerlink" title="1.2.4 视图结构 VStack"></a>1.2.4 视图结构 <code>VStack</code></h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">	<span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">		.imageScale(.large)</span><br><span class="line">		.foregroundStyle(.tint)</span><br><span class="line">	<span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>结构体实例</strong> (Instance of structs)：VStack 是一个 SwiftUI 中的结构体，用于垂直堆叠和排列多个子视图，例如 <code>Image</code> 和 <code>Text</code>。</li>
<li><strong>命名参数</strong> (named parameters)：<code>VStack</code> 可以接受不同的参数，默认的 <code>alignment</code> 是 <code>.center</code>，<code>spacing</code> 是 0，表示所有子视图居中对齐，且垂直间距为 0。</li>
<li><strong>参数默认值</strong> (Parameter Defaults)：<code>VStack</code> 允许指定 <code>alignment</code> 和 <code>spacing</code>，但它们有默认值，不指定时会使用默认设置。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span>(alignment: .leading, spacing: <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">        .imageScale(.large)</span><br><span class="line">        .foregroundStyle(.tint)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>内容参数</strong><code>content</code>：<code>VStack</code> 实际上可以用 <code>content</code> 参数来包裹内容，SwiftUI 允许省略 <code>content:</code> 以简化语法。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span>(content: &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">        .imageScale(.large)</span><br><span class="line">        .foregroundStyle(.tint)</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>@ViewBuilder</strong>：<code>VStack</code> 使用 <code>@ViewBuilder</code> 属性包装器将多个子视图（如 <code>Image</code> 和 <code>Text</code>）转换为 <code>TupleView</code>。这意味着 <code>VStack</code> 可以组合多个视图，而 SwiftUI 会自动处理和渲染它们。</li>
</ul>
<h4 id="1-2-5-View-Modifier"><a href="#1-2-5-View-Modifier" class="headerlink" title="1.2.5 View Modifier"></a>1.2.5 View Modifier</h4><p><strong>View Modifier</strong> 是一种用于修改视图外观或行为的轻量方法。通过在视图后链式调用来设置属性和样式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Image</span>(systemName: <span class="string">&quot;globe&quot;</span>)</span><br><span class="line">	 .imageScale(.large)</span><br><span class="line">	 .foregroundStyle(.tint)</span><br></pre></td></tr></table></figure>

<ul>
<li>在上述代码中，<code>.imageScale(.large)</code> 和 <code>.foregroundStyle(.tint)</code> 就是 <strong>View Modifier</strong></li>
<li>支持链式调用，可添加多个样式修改</li>
</ul>
<h4 id="1-2-6-View-Modifier-作用域"><a href="#1-2-6-View-Modifier-作用域" class="headerlink" title="1.2.6 View Modifier 作用域"></a>1.2.6 View Modifier 作用域</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">&quot;Outer Text&quot;</span>)</span><br><span class="line">        .foregroundColor(.red)  <span class="comment">// 仅应用到此 Text</span></span><br><span class="line"></span><br><span class="line">    <span class="type">HStack</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Inner Text 1&quot;</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Inner Text 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .foregroundColor(.blue)  <span class="comment">// 应用于 HStack 内的所有子视图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用于容器视图的 Modifier 影响其所有子视图</strong>：上述代码中的 <code>.foregroundColor(.blue)</code> 应用于 <code>HStack</code> 的所有子视图 <code>Text</code>。</li>
<li><strong>并列层级的视图的 Modifier 互不影响</strong>：在此例中，<code>.foregroundColor(.blue)</code> 应用于 <code>HStack</code>，仅影响 <code>HStack</code> 中的 <code>Text</code> 视图，外层的 <code>Text(&quot;Outer Text&quot;)</code> 视图不受影响。</li>
</ul>
<h3 id="1-3-本节完整代码"><a href="#1-3-本节完整代码" class="headerlink" title="1.3 本节完整代码"></a>1.3 本节完整代码</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">CardView</span>(isFaceUp: <span class="literal">true</span>)</span><br><span class="line">            <span class="type">CardView</span>()</span><br><span class="line">            <span class="type">CardView</span>()</span><br><span class="line">            <span class="type">CardView</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>(content: &#123;</span><br><span class="line">            <span class="keyword">if</span> isFaceUp &#123;</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">                    .foregroundColor(.white)</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">                    .strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;👻&quot;</span>).font(.largeTitle)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="type">Preview</span> &#123;</span><br><span class="line">    <span class="type">ContentView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-后续预习"><a href="#1-4-后续预习" class="headerlink" title="1.4 后续预习"></a>1.4 后续预习</h3><ul>
<li><strong>网格布局过渡</strong></li>
<li><strong>游戏逻辑的整合</strong></li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford cs193p 02 | More SwiftUI</title>
    <url>/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 02 集的相关笔记。</p>
<span id="more"></span>

<blockquote>
<p>本文主要内容转载于：<a href="https://nwdan.com/my-learning/stanford-cs193p-2.html">闻者通达的个人博客</a></p>
</blockquote>
<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>cs193p 课程网址: <a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></p>
<p>继续上一节记忆卡片的游戏制作，笔记按照课程项目制作步骤进行整理，在每个步骤依次对涉及的语法糖进行说明。建议在看第二节视频前预览一遍，了解教程框架，便于针对性的学习。</p>
<p>该笔记基于 <a href="https://nwdan.com/my-learning/stanford-cs193p-2.html">https://nwdan.com/my-learning/stanford-cs193p-2.html</a> 做了适当修改，添加了对于项目制作流程梳理，并在 <code>some View</code>、<code>@State</code>、<code>LazyVGrid</code> 等小节增加了部分说明。（ps：笔记非原创，原博主的笔记非常简洁清晰，推荐阅读。）</p>
<h2 id="1-创建一个-CardView-struct"><a href="#1-创建一个-CardView-struct" class="headerlink" title="1. 创建一个 CardView struct"></a>1. 创建一个 CardView struct</h2><h3 id="1-1-some-View"><a href="#1-1-some-View" class="headerlink" title="1.1 some View"></a>1.1 some View</h3><p>请看一段演示代码，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段演示代码同样可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">Text</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果我们放一些返回值不为 <code>Text</code> 的结构，编译器会报错 (Cannot convert return expression of type <code>&#39;VStack&lt;TupleView&lt;(Text, Text, Text)&gt;&gt;&#39;</code> to return type <code>&#39;Text&#39;</code>)：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">Text</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，如果我们放入多个 <code>Text</code> 的结构，编译器仍然会报错：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">Text</span> &#123;</span><br><span class="line">		<span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">		<span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>some View</code> 可以让编译器自动识别不同的返回类型。</p>
<h3 id="1-2-尾随闭包-Trailing-closure-syntax"><a href="#1-2-尾随闭包-Trailing-closure-syntax" class="headerlink" title="1.2 尾随闭包 (Trailing closure syntax)"></a>1.2 尾随闭包 (Trailing closure syntax)</h3><p>我们如果仔细看看 <code>VStack</code>, 我们传入了一个名为<code>content</code>的参数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>(alignment: .top, content: &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个函数的最后一个参数本身是一个函数，此时我们可以使用尾随闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span>(alignment: .top) &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-RoundedRectangle"><a href="#1-3-RoundedRectangle" class="headerlink" title="1.3 RoundedRectangle"></a>1.3 RoundedRectangle</h3><p>当我们使用 RoundedRectangle 时，如果我们不指定具体的修改器，Swift 会默认填充。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line"><span class="comment">// These two codes are identical in terms of functionality.</span></span><br><span class="line"><span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>).fill()</span><br></pre></td></tr></table></figure>

<h3 id="1-4-局部变量-Local-Variable"><a href="#1-4-局部变量-Local-Variable" class="headerlink" title="1.4 局部变量 (Local Variable)"></a>1.4 局部变量 (Local Variable)</h3><p>我们可以创建一个局部变量:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isFaceUp &#123;</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>).fill(.white)</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>).strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;👻&quot;</span>).font(.largeTitle)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>).fill()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个局部变量名为 <code>base</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base: <span class="type">RoundedRectangle</span> <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            <span class="keyword">if</span> isFaceUp &#123;</span><br><span class="line">                base.fill(.white)</span><br><span class="line">                base.strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">&quot;👻&quot;</span>).font(.largeTitle)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                base.fill()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMPORTANT:</strong> 我们使用了关键字 <code>let</code> 而不是 <code>var</code>，因为这个变量一旦创建就不再能被改变。(<code>let</code> 通常用来创建常量)</p>
<h3 id="1-5-类型推断-Type-Inference"><a href="#1-5-类型推断-Type-Inference" class="headerlink" title="1.5 类型推断 (Type Inference)"></a>1.5 类型推断 (Type Inference)</h3><p>我们可以省略变量类型让 Swift 自动判定。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Without omit the type</span></span><br><span class="line"><span class="keyword">let</span> base: <span class="type">RoundedRectangle</span> <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line"><span class="comment">// Omited the type (using type inference)</span></span><br><span class="line"><span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以按住 <code>option</code> 键然后点击 <code>base</code> 变量，Swift 会显示自动判定的变量类型。</p>
<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_option.png"></p>
<blockquote>
<p>Note: 我们在生产环境几乎都使用类型推断，不手动指定变量类型。如果需要对返回的类型进行检查，则可指定变量类型。</p>
</blockquote>
<h3 id="1-6-onTapGesture"><a href="#1-6-onTapGesture" class="headerlink" title="1.6 .onTapGesture"></a>1.6 <code>.onTapGesture</code></h3><p>单击:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>尾随闭包</strong>：单击的方法为 <code>.onTapGesture(perform:&#123;&#125;)</code> ，此处由于最后一个参数本身是一个函数，所以使用尾随闭包 <code>.onTapGesture &#123; isFaceUp.toggle() &#125;</code></li>
</ul>
<p>双击:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture(count: <span class="number">2</span>) &#123;</span><br><span class="line">            isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-State"><a href="#1-7-State" class="headerlink" title="1.7 @State"></a>1.7 <code>@State</code></h3><p>这一段代码会报错 <code>Error: Cannot assign to property: &#39;self&#39; is immutable</code>。因为结构体的属性默认是不可变的。也就是说，在结构体的实例方法或闭包中不能直接修改它的属性，除非明确标记为 <code>mutating</code>。因此，当你在 struct 中使用一个属性（比如 isFaceUp），它默认是不可变的，在 .onTapGesture 中试图修改 isFaceUp 则会导致这个错误。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">        	isFaceUp <span class="operator">=</span> <span class="operator">!</span>isFaceUp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来说，一个变量在函数被调用后就不可改变。<code>@State</code> 关键字允许变量有临时的状态，因为 <code>@State</code> 会创建一个指针指向堆 (Heap) 中。因此，指针本身没有被改变，改变的是堆里存的数据。</p>
<p>在 <code>SwiftUI</code> 中， <code>@State</code> 属性包装器用来管理视图中的可变状态的，将 <code>isFaceUp</code> 声明为 <code>@State</code>，SwiftUI 会知道这个属性的变化会导致视图重新渲染。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="comment">// ZStack Code</span></span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>isFaceUp</code> 可以在视图中动态可变，且不会触发不可变性错误。</p>
<h2 id="2-生成一组-Card"><a href="#2-生成一组-Card" class="headerlink" title="2. 生成一组 Card"></a>2. 生成一组 Card</h2><h3 id="2-1-数组-Array"><a href="#2-1-数组-Array" class="headerlink" title="2.1 数组(Array)"></a>2.1 数组(Array)</h3><p>Swift 接受以下两种方式新建数组，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A valid array notation</span></span><br><span class="line"><span class="keyword">let</span> emojis: <span class="type">Array</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>]</span><br><span class="line"><span class="comment">// Alternate array notation</span></span><br><span class="line"><span class="keyword">let</span> emojis: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>我们也可以使用类型推论省略类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="2-2-ForEach-循环"><a href="#2-2-ForEach-循环" class="headerlink" title="2.2 ForEach 循环"></a>2.2 ForEach 循环</h3><p><strong>ForEach 不包含最后一个数字</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterate from 0 to 3 (NOT including 4)</span></span><br><span class="line"><span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span><span class="number">4</span>, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">    <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note：<code>id:\.self</code> 会在 cs193p 后续课程中讲解</p>
</blockquote>
<p><strong>ForEach 包含最后一个数字</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterate from 0 to 4 (including 4)</span></span><br><span class="line"><span class="type">ForEach</span>(<span class="number">0</span><span class="operator">...</span><span class="number">4</span>, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">    <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ForEach （基于数组的长度）循环整个数组</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>]</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(emojis.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常在数组长度未知时使用该 <code>.indices</code> 方法。</p>
<h2 id="3-控制-Card-个数"><a href="#3-控制-Card-个数" class="headerlink" title="3. 控制 Card 个数"></a>3. 控制 Card 个数</h2><h3 id="3-1-按钮"><a href="#3-1-按钮" class="headerlink" title="3.1 按钮"></a>3.1 按钮</h3><h4 id="3-1-1-文本按钮"><a href="#3-1-1-文本按钮" class="headerlink" title="3.1.1 文本按钮"></a>3.1.1 文本按钮</h4><p>语法结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">&quot;Remove card&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// action</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>, <span class="string">&quot;💩&quot;</span>, <span class="string">&quot;🎉&quot;</span>, <span class="string">&quot;😎&quot;</span>]</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> cardCount <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                    <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;Remove card&quot;</span>) &#123;</span><br><span class="line">                    cardCount <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                <span class="type">Button</span>(<span class="string">&quot;Add card&quot;</span>) &#123;</span><br><span class="line">                    cardCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_textButton.png"></p>
<h4 id="3-1-2-图标按钮"><a href="#3-1-2-图标按钮" class="headerlink" title="3.1.2 图标按钮"></a>3.1.2 图标按钮</h4><p>语法结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(action: &#123;</span><br><span class="line">    <span class="comment">// action</span></span><br><span class="line">&#125;, label: &#123;</span><br><span class="line">    <span class="comment">// button icon, images, etc...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>, <span class="string">&quot;💩&quot;</span>, <span class="string">&quot;🎉&quot;</span>, <span class="string">&quot;😎&quot;</span>]</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> cardCount <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                    <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    cardCount <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">                &#125;, label: &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.minus.fill&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    cardCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                &#125;, label: &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            .imageScale(.large)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_iconButton.png"></p>
<h3 id="3-2-超出索引的问题"><a href="#3-2-超出索引的问题" class="headerlink" title="3.2 超出索引的问题"></a>3.2 超出索引的问题</h3><p>如果我们添加了太多的卡片，由于索引超出范围会导致程序崩溃。其中一种避免程序的方法是添加一个 <code>if</code> 逻辑。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(action: &#123;</span><br><span class="line">    <span class="keyword">if</span> cardCount <span class="operator">&lt;</span> emojis.count &#123;</span><br><span class="line">        cardCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, label: &#123;</span><br><span class="line">    <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>另一种方法是使用 <code>.disabled</code> 视图修改器</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">cardCountAdjuster</span>(<span class="params">by</span> <span class="params">offset</span>: <span class="type">Int</span>, <span class="params">symbol</span>: <span class="type">String</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(action: &#123;</span><br><span class="line">        cardCount <span class="operator">+=</span> offset</span><br><span class="line">    &#125;, label: &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: symbol)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disabled(cardCount <span class="operator">+</span> offset <span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">||</span> cardCount <span class="operator">+</span> offset <span class="operator">&gt;</span> emojis.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 这节课的后半部分讲解了 Swift 中的函数。</p>
</blockquote>
<h2 id="4-整理代码"><a href="#4-整理代码" class="headerlink" title="4. 整理代码"></a>4. 整理代码</h2><h3 id="4-1-优化代码可读性"><a href="#4-1-优化代码可读性" class="headerlink" title="4.1 优化代码可读性"></a>4.1 优化代码可读性</h3><p>我们先看看 <code>body</code> 中包含的代码，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>, <span class="string">&quot;💩&quot;</span>, <span class="string">&quot;🎉&quot;</span>, <span class="string">&quot;😎&quot;</span>]</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> cardCount <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                    <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .foregroundColor(.orange)</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    <span class="keyword">if</span> cardCount <span class="operator">&gt;</span> <span class="number">1</span> &#123;</span><br><span class="line">                        cardCount <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, label: &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.minus.fill&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    <span class="keyword">if</span> cardCount <span class="operator">&lt;</span> emojis.count &#123;</span><br><span class="line">                        cardCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, label: &#123;</span><br><span class="line">                    <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            .imageScale(.large)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在看起来十分不整洁。我们可以创建其它视图提高代码的可读性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;😈&quot;</span>, <span class="string">&quot;💩&quot;</span>, <span class="string">&quot;🎉&quot;</span>, <span class="string">&quot;😎&quot;</span>]</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> cardCount <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            cards</span><br><span class="line">            cardCountAdjusters</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cardCountAdjusters: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">HStack</span> &#123;</span><br><span class="line">            cardRemover</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            cardAdder</span><br><span class="line">        &#125;</span><br><span class="line">        .imageScale(.large)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cardRemover: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">if</span> cardCount <span class="operator">&gt;</span> <span class="number">1</span> &#123;</span><br><span class="line">                cardCount <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, label: &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.minus.fill&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cardAdder: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">if</span> cardCount <span class="operator">&lt;</span> emojis.count &#123;</span><br><span class="line">                cardCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, label: &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在整理后，我们 <code>body</code> 中的代码现在看起来非常容易理解。</p>
<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_view.png"></p>
<h3 id="4-2-隐式返回值-Implicit-return"><a href="#4-2-隐式返回值-Implicit-return" class="headerlink" title="4.2 隐式返回值 (Implicit return)"></a>4.2 隐式返回值 (Implicit return)</h3><p>如果一个函数只有 1 行代码，我们就可以使用隐式返回。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">HStack</span> &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .foregroundColor(.orange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以使用 <code>return</code> 关键字显式返回。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">HStack</span> &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .foregroundColor(.orange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-函数-Function"><a href="#4-3-函数-Function" class="headerlink" title="4.3 函数 (Function)"></a>4.3 函数 (Function)</h3><p>语法结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">&lt;</span>function name<span class="operator">&gt;</span>(<span class="operator">&lt;</span>para name<span class="operator">&gt;</span>: <span class="operator">&lt;</span>data type<span class="operator">&gt;</span>) -&gt; <span class="operator">&lt;</span><span class="keyword">return</span> type<span class="operator">&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// function code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">cardCountAdjuster</span>(<span class="params">by</span> <span class="params">offset</span>: <span class="type">Int</span>, <span class="params">symbol</span>: <span class="type">String</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(action: &#123;</span><br><span class="line">        cardCount <span class="operator">+=</span> offset</span><br><span class="line">    &#125;, label: &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: symbol)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IMPORTANT:</strong> <code>by offset: Int</code> 我们有时候会使用 2 个标签代表一个参数，第一个参数 <code>by</code> 在调用函数时使用，而第二个标签在函数内使用。第一个标签被称为 external parameter name，第二个标签被称为 internal parameter name。</p>
<p>现在我们的代码看起来更漂亮了,</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">cardCountAdjuster</span>(<span class="params">by</span> <span class="params">offset</span>: <span class="type">Int</span>, <span class="params">symbol</span>: <span class="type">String</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(action: &#123;</span><br><span class="line">        cardCount <span class="operator">+=</span> offset</span><br><span class="line">    &#125;, label: &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: symbol)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cardRemover: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cardCountAdjuster(by: <span class="operator">-</span><span class="number">1</span>, symbol: <span class="string">&quot;rectangle.stack.badge.minus.fill&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cardAdder: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cardCountAdjuster(by: <span class="number">1</span>, symbol: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: 由于我们删除了 <code>if</code> 逻辑，我们程序可能由于数组超出索引范围而崩溃。但是我们在超出索引的问题章节讲了如何解决.</p>
</blockquote>
<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_function.png"></p>
<h2 id="5-优化布局"><a href="#5-优化布局" class="headerlink" title="5. 优化布局"></a>5. 优化布局</h2><h3 id="5-1-LazyVGrid"><a href="#5-1-LazyVGrid" class="headerlink" title="5.1 LazyVGrid"></a>5.1 LazyVGrid</h3><p>为了让这些卡片看起来比较正常，我们需要用<code>LazyVGrid</code>替代<code>HStack</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">120</span>))]) &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .foregroundColor(.orange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>LazyVGrid</code> 和 <code>LazyHGrid</code> 分别是垂直的网格布局、水平网格布局。<code>LazyVGrid</code> 通过制定列的数量然后来填充布局。<code>GridItem</code> 通过设置 Size 来控制格子的宽度：</p>
<ol>
<li><code>fixed</code> 通过指定固定大小来确定格子宽度</li>
<li><code>flexible </code> 弹性大小，会和其他 flexible 的格子分割剩余的空间，可以设置期望的最大和最小值。如果指定的最小值过大可能会超出屏幕</li>
<li><code>adaptive</code> 自适应分布, 这个尺寸会提供一个或者多个格子。需要指定一个最小值, 也可以设置最大值，然后根据最小值在把自身占用的区域平分成若干个满足最小值最大值的的格子。可以理解 adaptive 为一个 flexible 大格子，获得空间后再把这个大格子平分成若干个满足设置定值的小格子。</li>
</ol>
</blockquote>
<p>我们需要在<code>cards</code> 和 <code>cardCountAdjusters</code>之间添加一个<code>Spacer()</code>，这样它们不会挤到一起去。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        cards</span><br><span class="line">        <span class="type">Spacer</span>()</span><br><span class="line">        cardCountAdjusters</span><br><span class="line">    &#125;</span><br><span class="line">    .padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>LazyVGrid</code>会使用尽可能少的空间，因此，当两张卡片都为背面时会被挤压到一起去。</p>
<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_lazyVGrid.png"></p>
<h3 id="5-2-opacity"><a href="#5-2-opacity" class="headerlink" title="5.2 .opacity"></a>5.2 <code>.opacity</code></h3><p>我们需要修改<code>CardView</code>的逻辑</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> content: <span class="type">String</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                base.foregroundColor(.white)</span><br><span class="line">                base.strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(content).font(.largeTitle)</span><br><span class="line">            &#125;</span><br><span class="line">            .opacity(isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            base.fill().opacity(isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题解决！</p>
<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_opacity.png"></p>
<h3 id="5-3-aspectRatio"><a href="#5-3-aspectRatio" class="headerlink" title="5.3 .aspectRatio"></a>5.3 <code>.aspectRatio</code></h3><p>使用 <code>aspectRatio</code> 控制视图的宽高比</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">120</span>))]) &#123;</span><br><span class="line">        <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">                .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .foregroundColor(.orange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/cs193p02_aspectRatio.png"></p>
<h3 id="5-4-ScrollView"><a href="#5-4-ScrollView" class="headerlink" title="5.4 ScrollView"></a>5.4 ScrollView</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">ScrollView</span> &#123;</span><br><span class="line">            cards</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Spacer</span>()</span><br><span class="line">        cardCountAdjusters</span><br><span class="line">    &#125;</span><br><span class="line">    .padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford cs193p 03｜MVVM</title>
    <url>/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 03 集的相关笔记。</p>
<span id="more"></span>

<blockquote>
<p>本文主要内容转载于：<a href="https://nwdan.com/my-learning/stanford-cs193p-3.html">闻者通达的个人博客</a></p>
</blockquote>
<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>本节前言：</p>
<blockquote>
<p>Conceptual overview of the architectural paradigm underlying the development of applications for iOS using SwiftUI (known as MVVM). Explanation of a fundamental component of understanding the Swift programming language: its type system. Start to apply both of these to Memorize.</p>
</blockquote>
<p>cs193p 课程网址: <a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></p>
<p>推荐的拓展练习教程：todolist MVVM（约 130 分钟） <a href="https://ur0.jp/jVOQG">https://ur0.jp/jVOQG</a></p>
<hr>
<h2 id="0-本节框架"><a href="#0-本节框架" class="headerlink" title="0. 本节框架"></a>0. 本节框架</h2><ul>
<li><p>MVVM</p>
<p>MVVM 架构简介与特点</p>
</li>
<li><p><code>swift</code> 类型</p>
<ul>
<li><code>struct</code> vs <code>class</code></li>
<li><code>protocol</code></li>
<li>“don’t care” type (aka <code>generics</code>)</li>
<li><code>enum</code>（略，但很重要）</li>
<li><code>functions</code></li>
</ul>
</li>
<li><p>Demo<br>续上节记忆游戏，因 demo 太短，将 demo 合并到了下一篇笔记中。</p>
</li>
</ul>
<h2 id="1-Model-and-UI"><a href="#1-Model-and-UI" class="headerlink" title="1. Model and UI"></a>1. Model and UI</h2><h3 id="1-1-将“逻辑与数据”与“用户界面”分离"><a href="#1-1-将“逻辑与数据”与“用户界面”分离" class="headerlink" title="1.1 将“逻辑与数据”与“用户界面”分离"></a>1.1 将“逻辑与数据”与“用户界面”分离</h3><ul>
<li>SwiftUI 强调将应用程序逻辑和数据与用户界面分离。我们将这些逻辑和数据称为 <strong>模型（Model）</strong>。</li>
<li>模型可以是 <code>struct</code>、<code>SQL</code> 数据库、机器学习代码或其他多种形式的组合。</li>
<li>用户界面基本上只是一个“可参数化”的外壳，由模型提供数据并赋予其生命。</li>
<li><strong>用户界面是模型的可视化表现</strong>。</li>
<li>模型是存放像 <code>isFaceUp</code> 和 <code>cardCount</code> 这样的状态的地方，而这些状态不应该放在 UI 的 <code>@State</code> 中。</li>
<li>SwiftUI 会确保当模型变化影响到用户界面时，用户界面会被重新构建。</li>
</ul>
<h3 id="1-2-将模型连接到用户界面"><a href="#1-2-将模型连接到用户界面" class="headerlink" title="1.2 将模型连接到用户界面"></a>1.2 将模型连接到用户界面</h3><p>在将模型与用户界面连接时，有几种选择：</p>
<ol>
<li><strong>几乎不分离</strong>：极少数情况下，模型可以作为视图中的 <code>@State</code></li>
<li><strong>完全分离</strong>：模型可能仅能通过一个充当“门卫”的 <strong>视图模型（View Model）</strong> <code>class</code> 进行访问</li>
<li><strong>部分分离</strong>：存在一个视图模型 <code>class</code>，但模型仍然可以直接访问</li>
</ol>
<p>这三种选择主要取决于模型的复杂性：</p>
<ul>
<li>一个由 SQL + <code>struct</code> + 其他元素组成的模型，可能会选择第二种方案</li>
<li>如果模型只是一小段简单数据且涉及的逻辑很少，可能会选择第一种方案</li>
<li>介于两者之间的情况可能会考虑第三种方案</li>
</ul>
<p>本节将重点讨论第二种方案（完全分离）。我们将这种连接模型与用户界面的架构称为 <strong>MVVM</strong> （模型-视图-视图模型）。</p>
<ul>
<li><strong>MVVM</strong> 是相对复杂的 SwiftUI 应用的主要架构</li>
<li>第三种方案（部分分离）是对 MVVM 的细微调整</li>
</ul>
<h2 id="2-MVVM"><a href="#2-MVVM" class="headerlink" title="2. MVVM"></a>2. MVVM</h2><h3 id="2-1-MVVM-简介"><a href="#2-1-MVVM-简介" class="headerlink" title="2.1 MVVM 简介"></a>2.1 MVVM 简介</h3><p><strong>MVVM (Model-View-ViewModel)</strong> 是一种架构模式，将视图（UI）和业务逻辑分离，从而提高代码可读性、可维护性和复用性。它将代码分为三个部分：</p>
<ul>
<li><strong>Model（模型层）：</strong> 负责管理数据和业务逻辑。通常是数据模型，可能包含从服务器或本地数据库获取的内容。</li>
<li><strong>View（视图层）：</strong> 负责展示 UI，声明式地描述界面如何响应数据变化。视图只与 ViewModel 交互，而不直接操作 Model。</li>
<li><strong>ViewModel（视图模型层）：</strong> 负责连接 View 和 Model。ViewModel 通过处理数据和业务逻辑，将数据转换为视图需要的形式，并通过绑定的方式通知视图更新。</li>
</ul>
<h3 id="2-2-MVVM-特点"><a href="#2-2-MVVM-特点" class="headerlink" title="2.2 MVVM 特点"></a>2.2 MVVM 特点</h3><ul>
<li>解耦：View 和 Model 相互独立，ViewModel 承担数据转换任务，减少 UI 和业务逻辑的耦合。</li>
<li>数据驱动：ViewModel 中的属性通常是可观察的（例如 SwiftUI 中的 @Published 属性），使得数据变化时自动触发 UI 更新。</li>
<li>单向数据流：Model 更新时，通知 ViewModel，进而通知 View；用户操作从 View 传递到 ViewModel 进行处理。</li>
</ul>
<p><img src="/2024/12/06/Stanford-cs193p-03%EF%BD%9CMVVM/cs193p03_MVVM.png"></p>
<h3 id="2-3-数据流在-MVVM-中的运作"><a href="#2-3-数据流在-MVVM-中的运作" class="headerlink" title="2.3 数据流在 MVVM 中的运作"></a>2.3 数据流在 MVVM 中的运作</h3><ul>
<li><p><strong>从 Model 到 View</strong></p>
<ol>
<li>ViewModel 从 Model 获取数据（如从网络或本地加载）。</li>
<li>ViewModel 通过 @Published 属性将数据暴露给视图。</li>
<li>视图观察 ViewModel，当数据更新时，自动重新渲染。</li>
</ol>
</li>
<li><p><strong>从 View 到 Model</strong></p>
<ol>
<li>用户在视图中进行交互</li>
<li>交互事件触发 ViewModel 的方法</li>
<li>ViewModel 修改 Model 或处理业务逻辑，更新数据后通知视图。</li>
</ol>
</li>
</ul>
<h3 id="2-4-补充举例（非视频内容）"><a href="#2-4-补充举例（非视频内容）" class="headerlink" title="2.4 补充举例（非视频内容）"></a>2.4 补充举例（非视频内容）</h3><p>以下是一个示例，展示如何在 SwiftUI 中实现 MVVM 架构。</p>
<blockquote>
<p>这一部分是为了辅助理解 MVVM 架构，不用实现。</p>
</blockquote>
<h4 id="2-4-1-模型层（Model）"><a href="#2-4-1-模型层（Model）" class="headerlink" title="2.4.1 模型层（Model）"></a>2.4.1 模型层（Model）</h4><p>模型负责表示应用的数据结构。通常是简单的数据类型，可能从服务器或本地数据库加载。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Habit</span>: <span class="title class_ inherited__">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> isCompleted: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-视图模型层（ViewModel）"><a href="#2-4-2-视图模型层（ViewModel）" class="headerlink" title="2.4.2 视图模型层（ViewModel）"></a>2.4.2 视图模型层（ViewModel）</h4><p><code>ViewModel</code> 负责管理业务逻辑和状态，并通过数据绑定将数据暴露给视图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HabitViewModel</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="comment">// 可观察的属性，视图会自动更新</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> habits: [<span class="type">Habit</span>] <span class="operator">=</span> [</span><br><span class="line">        <span class="type">Habit</span>(id: <span class="number">1</span>, name: <span class="string">&quot;Exercise&quot;</span>, isCompleted: <span class="literal">false</span>),</span><br><span class="line">        <span class="type">Habit</span>(id: <span class="number">2</span>, name: <span class="string">&quot;Read a Book&quot;</span>, isCompleted: <span class="literal">true</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新习惯完成状态</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">toggleHabitCompletion</span>(<span class="keyword">_</span> <span class="params">habit</span>: <span class="type">Habit</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index <span class="operator">=</span> habits.firstIndex(where: &#123; <span class="variable">$0</span>.id <span class="operator">==</span> habit.id &#125;) &#123;</span><br><span class="line">            habits[index].isCompleted.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Published</code>：使得 <code>habits</code> 的变化可以被 SwiftUI 的 <code>View</code> 观察到，从而触发 UI 更新。</li>
<li><strong>方法</strong>：封装了业务逻辑，例如切换习惯完成状态。</li>
</ul>
<h4 id="2-4-3-视图层（View）"><a href="#2-4-3-视图层（View）" class="headerlink" title="2.4.3 视图层（View）"></a>2.4.3 视图层（View）</h4><p>视图是完全声明式的，只关注 UI 和数据的绑定，不直接操作 <code>Model</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HabitListView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> viewModel <span class="operator">=</span> <span class="type">HabitViewModel</span>() <span class="comment">// 创建 ViewModel 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">List</span>(viewModel.habits) &#123; habit <span class="keyword">in</span></span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(habit.name)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Button</span>(action: &#123;</span><br><span class="line">                        viewModel.toggleHabitCompletion(habit) <span class="comment">// 用户操作通知 ViewModel</span></span><br><span class="line">                    &#125;) &#123;</span><br><span class="line">                        <span class="type">Image</span>(systemName: habit.isCompleted <span class="operator">?</span> <span class="string">&quot;checkmark.circle.fill&quot;</span> : <span class="string">&quot;circle&quot;</span>)</span><br><span class="line">                            .foregroundColor(habit.isCompleted <span class="operator">?</span> .green : .gray)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationTitle(<span class="string">&quot;My Habits&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@StateObject</code>：用于初始化 <code>ViewModel</code>，使视图能够观察其状态变化。</li>
<li><strong>数据绑定</strong>：<code>viewModel.habits</code> 与列表内容绑定，<code>@Published</code> 属性变化时自动更新视图。</li>
<li><strong>用户操作</strong>：通过按钮操作调用 <code>ViewModel</code> 方法，而不直接操作 <code>Model</code>。</li>
</ul>
<h2 id="3-Varieties-of-Types"><a href="#3-Varieties-of-Types" class="headerlink" title="3. Varieties of Types"></a>3. Varieties of Types</h2><h3 id="3-1-struct-and-class"><a href="#3-1-struct-and-class" class="headerlink" title="3.1 struct and class"></a>3.1 struct and class</h3><h4 id="3-1-1-struct-class-共同点"><a href="#3-1-1-struct-class-共同点" class="headerlink" title="3.1.1 struct &amp; class 共同点"></a>3.1.1 struct &amp; class 共同点</h4><p>在 Swift 中，<code>struct</code> 和 <code>class</code> 具有以下特征：</p>
<ul>
<li><p><strong>语法相似</strong>：它们的语法几乎完全相同。</p>
</li>
<li><p><strong>存储属性</strong>（stored vars）：类似于你熟悉的那种存储在内存中的属性，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isFaceUp: <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>计算属性</strong>（computed vars）：其值是通过评估一些代码得出的属性，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">Text</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常量</strong>（constant lets）：其值不会改变的属性，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColor <span class="operator">=</span> <span class="type">Color</span>.orange</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="type">CardView</span>().foregroundColor(defaultColor)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数</strong>（functions）：可以定义行为，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">multiply</span>(<span class="params">operand</span>: <span class="type">Int</span>, <span class="params">by</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> operand <span class="operator">*</span> by</span><br><span class="line">&#125;</span><br><span class="line">multiply(operand: <span class="number">5</span>, by: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">multiply</span>(<span class="keyword">_</span> <span class="params">operand</span>: <span class="type">Int</span>, <span class="params">by</span> <span class="params">otherOperand</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> operand <span class="operator">*</span> otherOperand</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">5</span>, by: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化器</strong>（initializers）：在创建 <code>struct</code> 或 <code>class</code> 时调用的特殊函数，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RoundedRectangle</span> &#123;</span><br><span class="line">	<span class="keyword">init</span>(<span class="params">cornerRadius</span>: <span class="type">CGFloat</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 cornerRadius 初始化矩形</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">init</span>(<span class="params">cornerSize</span>: <span class="type">CGSize</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 cornerSize 初始化矩形</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-1-2-struct-vs-class-区别"><a href="#3-1-2-struct-vs-class-区别" class="headerlink" title="3.1.2 struct vs class 区别"></a>3.1.2 struct vs class 区别</h4><table>
<thead>
<tr>
<th>struct</th>
<th>class</th>
</tr>
</thead>
<tbody><tr>
<td>值类型</td>
<td>引用类型</td>
</tr>
<tr>
<td>传递或赋值时会被复制</td>
<td>通过指针传递</td>
</tr>
<tr>
<td>复制时写入（只有在被修改时才真正复制）</td>
<td>自动引用计数</td>
</tr>
<tr>
<td>函数式编程</td>
<td>面向对象编程</td>
</tr>
<tr>
<td>不支持继承</td>
<td>支持单继承</td>
</tr>
<tr>
<td>“免费的” <strong>init</strong>初始化所有的 <strong>var</strong></td>
<td>“免费的” <strong>init</strong> 不初始化任何 <strong>var</strong></td>
</tr>
<tr>
<td>可变性是显式的（<strong>var</strong> 与 <strong>let</strong> 的区分）</td>
<td>始终可变</td>
</tr>
<tr>
<td>常用的数据结构</td>
<td>在特定情况下使用</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>值类型 vs 引用类型</strong>：<code>struct</code> 是值类型，这意味着当它们被传递或赋值时，会创建一个全新的副本；而 <code>class</code> 是引用类型，传递或赋值时只是将引用指向同一实例。</p>
</li>
<li><p><strong>复制时写入</strong>：对于 <code>struct</code>，只有在它们被修改时，才会生成新的副本（写时复制），这通常用于优化内存使用。</p>
</li>
<li><p><strong>自动引用计数</strong>：<code>class</code> 的实例会被 Swift 的内存管理系统自动引用计数，这意味着当没有强引用指向某个实例时，它会被自动释放。</p>
</li>
<li><p><strong>函数式编程 vs 面向对象编程</strong>：<code>struct</code> 常用于函数式编程范式，而 <code>class</code> 则广泛用于面向对象编程，后者强调对象的封装和继承。</p>
</li>
<li><p><strong>继承</strong>：<code>struct</code> 不支持继承，因此它不能从其它结构体派生；而 <code>class</code> 支持单层继承，允许子类从父类继承属性和方法。</p>
</li>
<li><p><strong>初始化器</strong>：对于 <code>struct</code>，默认情况下，Swift 会生成一个初始化器，确保所有属性都有默认值；而 <code>class</code> 的默认初始化器不会初始化任何属性，除非你自己定义。</p>
</li>
<li><p><strong>可变性</strong>：在使用 <code>struct</code> 时，变量（<code>var</code>）和常量（<code>let</code>）的定义影响其可变性，因此你需要显式声明；而 <code>class</code> 实例的属性默认是可变的，不论是用 <code>var</code> 还是 <code>let</code>。</p>
</li>
<li><p><strong>使用场景</strong>：在开发中，<code>struct</code> 通常是更常用的选择，这是因为它们提供了更好的内存管理和性能，特别是在需要值传递的场景；而 <code>class</code> 则适合需要共享状态或需要继承的情况。</p>
</li>
</ul>
<blockquote>
<p>截止目前课程所看到的都是 <code>struct</code>，MVVM 架构中的 ViewModel 是 <code>class</code>。</p>
</blockquote>
<h3 id="3-2-Generics-泛型"><a href="#3-2-Generics-泛型" class="headerlink" title="3.2 Generics 泛型"></a>3.2 Generics 泛型</h3><ul>
<li>有时我们不关心具体类型，想操作类型无关的数据结构。</li>
<li>Swift 是强类型语言，所以我们不能使用无类型的变量。解决办法是使用“泛型”。</li>
</ul>
<h4 id="3-2-1-Generics-示例：Array"><a href="#3-2-1-Generics-示例：Array" class="headerlink" title="3.2.1 Generics 示例：Array"></a>3.2.1 Generics 示例：<code>Array</code></h4><ul>
<li><p><code>Array</code> 可以包含多种类型的元素而不关心具体类型。</p>
</li>
<li><p><code>Array</code> 的声明如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">Element</span>) &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>append</code> 的参数是 <code>Element</code>，表示一种“无所谓”类型。</p>
</li>
<li><p>使用 <code>Array</code> 时，我们可以指定具体类型，如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时 Element 为 Int 类型</span></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">a.append(<span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时 Element 为 String 类型</span></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">a.append(<span class="string">&quot;🌼&quot;</span>)</span><br><span class="line">a.append(<span class="string">&quot;🍉&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Element</code> 的类型在使用 <code>Array</code> 时确定。</p>
</li>
<li><p>泛型允许同时使用多个类型参数（如 <code>&lt;Element, Foo&gt;</code>）。</p>
</li>
<li><p>“无所谓”类型称为 <strong>类型参数</strong>。</p>
</li>
</ul>
<p>总之，泛型能让我们在不知道具体类型的情况下灵活操作数据结构。</p>
<h3 id="3-3-protocol-协议"><a href="#3-3-protocol-协议" class="headerlink" title="3.3 protocol 协议"></a>3.3 protocol 协议</h3><h4 id="3-3-1-protocol-协议的特点"><a href="#3-3-1-protocol-协议的特点" class="headerlink" title="3.3.1 protocol 协议的特点"></a>3.3.1 protocol 协议的特点</h4><h5 id="1-protocol-有函数和方法，但不能具体实现或存储"><a href="#1-protocol-有函数和方法，但不能具体实现或存储" class="headerlink" title="1. protocol 有函数和方法，但不能具体实现或存储"></a><strong>1. protocol 有函数和方法，但不能具体实现或存储</strong></h5><p>声明一个协议的语法与 struct 或 class 很相似，只是没有具体实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protocol</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">move</span>(<span class="params">by</span>: <span class="type">Int</span>)</span><br><span class="line"><span class="keyword">var</span> hasMoved: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> distanceFromStart: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>&#123; &#125;</code> 中的内容用于说明该协议的变量是只读（get）还是可读写（get set）。</p>
<p><strong>举例说明</strong></p>
<p>任意类型都可以实现 Moveable 协议，只需要在 struct 内部实现 <code>move(by)</code> 、<code>hasMoved</code> 和 <code>distanceFromStart</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PortableThing</span>: <span class="title class_ inherited__">Moveable</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里必须实现 move(by:)、hasMoved 和 distanceFromStart</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 <code>PortableThing</code> 结构体便符合 <code>Moveable</code> 协议。</p>
<h5 id="2-protocol-协议可以继承其他-protocol"><a href="#2-protocol-协议可以继承其他-protocol" class="headerlink" title="2. protocol 协议可以继承其他 protocol"></a>2. <strong>protocol</strong> 协议可以继承其他 protocol</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Vehicle</span>: <span class="title class_ inherited__">Moveable</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> passengerCount: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里必须实现 move(by:)、hasMoved、distanceFromStart 和 passengerCount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-一个类可以同时实现多个协议"><a href="#3-一个类可以同时实现多个协议" class="headerlink" title="3. 一个类可以同时实现多个协议"></a>3. 一个类可以同时实现多个协议</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="title class_ inherited__">Vehicle</span>, <span class="title class_ inherited__">Impoundable</span>, <span class="title class_ inherited__">Leasable</span> &#123;</span><br><span class="line">  <span class="comment">// 在这里必须实现所有协议中的函数和变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-protocol-协议的用途"><a href="#3-3-2-protocol-协议的用途" class="headerlink" title="3.3.2 protocol 协议的用途"></a>3.3.2 protocol 协议的用途</h4><ol>
<li><p><strong>统一行为定义</strong></p>
<p>协议可以用于定义一组类型的共同行为，而无需关心这些类型的具体实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">fly</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bird</span>: <span class="title class_ inherited__">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">fly</span>() &#123;</span><br><span class="line">	  <span class="built_in">print</span>(<span class="string">&quot;Bird is flying!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Airplane</span>: <span class="title class_ inherited__">Flyable</span> &#123;</span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">fly</span>() &#123;</span><br><span class="line">	  <span class="built_in">print</span>(<span class="string">&quot;Airplane is flying!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> flyer: [<span class="type">Flyable</span>] <span class="operator">=</span> [<span class="type">Bird</span>(), <span class="type">Airplane</span>()]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> flyer &#123;</span><br><span class="line">  item.fly()  <span class="comment">// 不同类型的对象都可以飞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Flyable 定义了所有可飞行的类型应具备的行为。</li>
<li>通过协议，可以统一处理 Bird 和 Airplane 等符合协议的类型。</li>
</ul>
<p>另外，比如，<code>struct ContentView: View</code>  使得  <code>ContentView</code>  成为一个强大的结构体，虽然需要实现  <code>var body</code>  来满足  <code>View</code>  协议。</p>
</li>
<li><p><strong>协议与泛型</strong></p>
<p>协议可以与泛型结合，约束泛型参数必须符合某些协议，从而提升代码的类型安全性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printDetails</span>&lt;<span class="type">T</span>: <span class="type">CustomStringConvertible</span>&gt;(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">T</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(item.description)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printDetails(<span class="number">42</span>)            <span class="comment">// 输出：42</span></span><br><span class="line">printDetails(<span class="string">&quot;Swift Rocks&quot;</span>) <span class="comment">// 输出：Swift Rocks</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>泛型参数 T 必须符合 CustomStringConvertible 协议。</li>
<li>这种约束确保函数可以使用 description 属性，而不会导致运行时错误。</li>
</ul>
<h4 id="3-3-3-常见协议示例"><a href="#3-3-3-常见协议示例" class="headerlink" title="3.3.3 常见协议示例"></a>3.3.3 常见协议示例</h4><p>常见协议包括：</p>
<ul>
<li><strong>Identifiable</strong></li>
<li><strong>Hashable</strong></li>
<li><strong>Equatable</strong></li>
<li><strong>CustomStringConvertible</strong></li>
<li>特定的协议如 <strong>Animatable</strong>。</li>
</ul>
<h4 id="3-3-4-协议的优点"><a href="#3-3-4-协议的优点" class="headerlink" title="3.3.4 协议的优点"></a>3.3.4 协议的优点</h4><ol>
<li><strong>定义行为的蓝图</strong>：用于统一定义一组行为（方法、属性）。</li>
<li><strong>实现多态性</strong>：使不同类型可以通过统一接口交互。</li>
<li><strong>泛型约束</strong>：提升代码的类型安全性和复用性。</li>
<li><strong>协议扩展</strong>：减少重复代码，为协议提供默认实现。</li>
<li><strong>灵活组合</strong>：通过协议组合构建更强大的接口。</li>
</ol>
<h3 id="3-4-enum"><a href="#3-4-enum" class="headerlink" title="3.4 enum"></a>3.4 <code>enum</code></h3><blockquote>
<p>本节略过，但很重要。</p>
</blockquote>
<h3 id="3-5-Functions"><a href="#3-5-Functions" class="headerlink" title="3.5 Functions"></a>3.5 Functions</h3><p>函数类型可以像其他类型一样使用，由参数类型列表和返回类型组成。语法为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(参数类型列表) -&gt; 返回类型</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">square</span>(<span class="params">operand</span>: <span class="type">Double</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> operand <span class="operator">*</span> operand</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> operation <span class="operator">=</span> square <span class="comment">// just assigning a value to the operation vars, nothing more</span></span><br><span class="line"><span class="keyword">let</span> result1 <span class="operator">=</span> operation(<span class="number">4</span>) <span class="comment">// result1 would equal 16</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>square</code> 函数的类型：<code>(Double) -&gt; Double</code>，表示接收一个 <code>Double</code> 参数并返回一个 <code>Doubel</code> 值。</li>
<li><code>operation</code> 是一个变量：存储了函数 <code>square</code>，可以通过变量调用。</li>
</ul>
<p><strong>函数类型示例</strong>：</p>
<ul>
<li><code>(Int, Int) -&gt; Bool</code>：接受两个 Int 类型参数，返回一个 Bool 值。</li>
<li><code>(Double) -&gt; Void</code>：接受一个 Double 类型参数，无返回值。</li>
<li><code>() -&gt; Array&lt;String&gt;</code>：不接受参数，返回一个 String 数组。</li>
<li><code>() -&gt; Void</code>：不接受参数，无返回值（这是一个常见的用法）。</li>
</ul>
<p>在 Swift 中，函数类型可以像其他类型一样使用，可以存储函数并通过变量调用。</p>
<h4 id="3-5-1-闭包类型（Function-as-type）"><a href="#3-5-1-闭包类型（Function-as-type）" class="headerlink" title="3.5.1 闭包类型（Function as type）"></a>3.5.1 闭包类型（Function as type）</h4><p>函数类型也适用于闭包。闭包是未命名的函数，它的语法更加简洁。你可以将闭包存储在变量中，或直接作为函数的参数，通常被称为“内联函数”。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> operation: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="operator">=</span> &#123; (a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(operation(<span class="number">4</span>, <span class="number">6</span>))  <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure>

<p>在 Swift 中，许多 SwiftUI 的功能（如@ViewBuilders 和 onTapGesture 的动作）都是通过闭包实现的。</p>
<h2 id="4-Demo"><a href="#4-Demo" class="headerlink" title="4. Demo"></a>4. Demo</h2><p>由于 demo 太短（大约只有 15 分钟），将这节课的 demo 合并到下一篇笔记中。</p>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford cs193p 04｜MVVM 应用</title>
    <url>/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 04 集的相关笔记。</p>
<span id="more"></span>

<blockquote>
<p>本文主要内容转载于：<a href="https://nwdan.com/my-learning/stanford-cs193p-4.html">闻者通达的个人博客</a></p>
</blockquote>
<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>cs193p 课程网址: <a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></p>
<p>为便于梳理，本节笔记包含了第三节课最后 15 分钟、第四节课以及第五节课前四分钟的内容。</p>
<hr>
<h2 id="1-第三节课最后-15-分钟"><a href="#1-第三节课最后-15-分钟" class="headerlink" title="1. 第三节课最后 15 分钟"></a>1. 第三节课最后 15 分钟</h2><h3 id="1-1-整理代码"><a href="#1-1-整理代码" class="headerlink" title="1.1 整理代码"></a>1.1 整理代码</h3><p>我们在应用 MVVM 设计思想前需要清理一下代码。</p>
<p>移除以下部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">var</span> cardCount: <span class="type">Int</span> <span class="operator">=</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cardCountAdjsters: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">HStack</span> &#123;</span><br><span class="line">        cardRemover</span><br><span class="line">        <span class="type">Spacer</span>()</span><br><span class="line">        cardAdder</span><br><span class="line">    &#125;</span><br><span class="line">    .imageScale(.large)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">cardCountAdjsters</span>(<span class="params">by</span> <span class="params">offset</span>: <span class="type">Int</span>, <span class="params">symbol</span>: <span class="type">String</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Button</span>(action: &#123;</span><br><span class="line">        cardCount <span class="operator">+=</span> offset</span><br><span class="line">    &#125;, label: &#123;</span><br><span class="line">        <span class="type">Image</span>(systemName: symbol)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disabled(cardCount <span class="operator">+</span> offset <span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">||</span> cardCount <span class="operator">+</span> offset <span class="operator">&gt;</span> emojis.count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cardRemover: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cardCountAdjsters(by: <span class="operator">-</span><span class="number">1</span>, symbol: <span class="string">&quot;rectangle.stack.badge.minus.fill&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cardAdder: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cardCountAdjsters(by: <span class="number">1</span>, symbol: <span class="string">&quot;rectangle.stack.badge.plus.fill&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改成以下部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">...</span></span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">ScrollView</span> &#123;</span><br><span class="line">                cards</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">            cardCountAdjsters</span><br><span class="line">        &#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="comment">// change to</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">        <span class="type">ScrollView</span> &#123;</span><br><span class="line">            cards</span><br><span class="line">        &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">            <span class="type">ForEach</span>(<span class="number">0</span><span class="operator">..&lt;</span>cardCount, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line"><span class="comment">// change to</span></span><br><span class="line">            <span class="type">ForEach</span>(emojis.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-新建一个-Model-文件"><a href="#1-2-新建一个-Model-文件" class="headerlink" title="1.2 新建一个 Model 文件"></a>1.2 新建一个 Model 文件</h3><p><code>File</code> -&gt; <code>New</code> -&gt; <code>File</code> -&gt; <code>Swift File</code>, 并将文件命名为 MemorizeGame</p>
<p><img src="/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/cs193p04_newFile.png"></p>
<p><strong>实现（写）一个 MemorizeGame (Model):</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span></span><br><span class="line">        <span class="keyword">var</span> isMatched: <span class="type">Bool</span></span><br><span class="line">        <span class="keyword">var</span> content: <span class="type">CardContent</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-新建一个-ViewModel-文件"><a href="#1-3-新建一个-ViewModel-文件" class="headerlink" title="1.3 新建一个 ViewModel 文件"></a>1.3 新建一个 ViewModel 文件</h3><p><code>File</code> -&gt; <code>New</code> -&gt; <code>File</code> -&gt; <code>Swift File</code>, then named as EmojiMemoryGame</p>
<p><strong>实现（写）一个 MemorizeGame (ViewModel):</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> model: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-第四节课"><a href="#2-第四节课" class="headerlink" title="2. 第四节课"></a>2. 第四节课</h2><h3 id="2-1-访问控制：实现由部分分离转为全部分离"><a href="#2-1-访问控制：实现由部分分离转为全部分离" class="headerlink" title="2.1 访问控制：实现由部分分离转为全部分离"></a>2.1 访问控制：实现由部分分离转为全部分离</h3><h4 id="2-1-1-部分分离"><a href="#2-1-1-部分分离" class="headerlink" title="2.1.1 部分分离"></a>2.1.1 部分分离</h4><p>我们来看看 MVVM 文件:</p>
<p><strong>View:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ContentView.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> viewModel: <span class="type">EmojiMemoryGame</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>]</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Model:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ViewModel:</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> model: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们现在仍然可以在 <code>View</code> 中通过 <code>viewModel.model.xxx</code> 直接从 View 访问 Model，因此这是部分分离模式。</p>
<h4 id="2-1-2-完全分离"><a href="#2-1-2-完全分离" class="headerlink" title="2.1.2 完全分离"></a>2.1.2 完全分离</h4><p>如果我们想避免 View 直接访问 Model，我们需要使用关键字 <code>private</code> 来实现。这被称为完全分离。</p>
<p>修改 <strong>ViewModel</strong>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们现在如何访问 model 呢？我们需要修改 ViewModel 让它可以被访问。</p>
<p>这是修改过后的 <strong>ViewModel</strong>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">	<span class="comment">// private 使得 View 无法直接访问 model；这里意味着在 ViewModel 中使用 Model</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 ViewModel 中访问 model 中的数据 cards</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> model.cards</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 ViewModel 中实现对 model 中的 card 的 choose 操作</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="params">card</span>: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>) &#123;</span><br><span class="line">        model.choose(card: card)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="private-set"><a href="#private-set" class="headerlink" title="private(set)"></a>private(set)</h5><p>对应的在 <code>Model</code> 中应该怎么修改呢？</p>
<p><code>private(set)</code> 关键字允许其他函数只能读，但不可以修改。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryGame.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-ViewModel-方法补充和-Model-对应修改"><a href="#2-2-ViewModel-方法补充和-Model-对应修改" class="headerlink" title="2.2 ViewModel 方法补充和 Model 对应修改"></a>2.2 ViewModel 方法补充和 Model 对应修改</h3><h4 id="2-2-1-Model-的-choose-函数声明和-ViewModel-的-choose-函数声明调用"><a href="#2-2-1-Model-的-choose-函数声明和-ViewModel-的-choose-函数声明调用" class="headerlink" title="2.2.1 Model 的 choose 函数声明和 ViewModel 的 choose 函数声明调用"></a>2.2.1 <code>Model</code> 的 choose 函数声明和 <code>ViewModel</code> 的 choose 函数声明调用</h4><h5 id="忽略函数标签-No-External-Name"><a href="#忽略函数标签-No-External-Name" class="headerlink" title="忽略函数标签 (No External Name)"></a>忽略函数标签 (No External Name)</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryGame.swift</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>) &#123;</span><br><span class="line">        model.choose(card)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>choose</code>函数在被外部调用后不需要有外部称呼。然而，我们在一些情况下不需要省略外部称呼：</p>
<ol>
<li>数据类型是字符串，整数，或不确定的。</li>
<li>添加外部称呼可以增加代码的可读性。</li>
</ol>
<h4 id="2-2-2-Model-结构体的初始化器和-ViewModel-类初始化"><a href="#2-2-2-Model-结构体的初始化器和-ViewModel-类初始化" class="headerlink" title="2.2.2 Model 结构体的初始化器和 ViewModel 类初始化"></a>2.2.2 <code>Model</code> 结构体的初始化器和 <code>ViewModel</code> 类初始化</h4><p>类初始值设定项没有参数，并且仅当所有变量都有默认值时才起作用。 我们接下来开始写 <strong>ViewModel</strong> (EmojiMemoryGame.swift) 初始化函数。</p>
<p>另外，我们想要通过用 <code>numberOfPairsOfCards</code> 和 <code>cardContentFactory</code> 来初始化 <strong>Model</strong> (MemoryGame.swift)。因此我们先需要自定义 <strong>Model</strong> 的初始化函数。（这两个参数分别代表卡片数，以及通过卡片索引获取卡片内容的函数）</p>
<h5 id="Model-初始化器"><a href="#Model-初始化器" class="headerlink" title="Model 初始化器"></a><code>Model</code> 初始化器</h5><h6 id="1-For-循环"><a href="#1-For-循环" class="headerlink" title="1. For 循环"></a><strong>1. For 循环</strong></h6><p>我们想要对每张原卡片，卡片组中都会有两张存在。我们可以使用 <code>_</code> 来忽略循环的索引。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryGame.swift</span></span><br><span class="line"><span class="keyword">for</span> pairIndex <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numberOfPairsOfCards &#123;</span><br><span class="line">    cards.append(<span class="type">XXXX</span>)</span><br><span class="line">    cards.append(<span class="type">XXXX</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Use _ to ignore the pairIndex</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numberOfPairsOfCards &#123;</span><br><span class="line">    cards.append(<span class="type">XXXX</span>)</span><br><span class="line">    cards.append(<span class="type">XXXX</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XXXX</code> 代表的是 <code>cardContentFactory</code> 通过 <code>pairIndex</code> 索引获取到的卡片内容。下边会讲如何使用闭包来实现该函数。</p>
<h6 id="2-闭包语法"><a href="#2-闭包语法" class="headerlink" title="2. 闭包语法"></a><strong>2. 闭包语法</strong></h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">numberOfPairsOfCards</span>: <span class="type">Int</span>, <span class="params">cardContentFactory</span>: (<span class="type">Int</span>) -&gt; <span class="type">CardContent</span>) &#123;</span><br><span class="line">        cards <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add numberOfParisOfCards x 2 cards</span></span><br><span class="line">        <span class="keyword">for</span> pairIndex <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>numberOfPairsOfCards &#123;</span><br><span class="line">            <span class="keyword">let</span> content <span class="operator">=</span> cardContentFactory(pairIndex)</span><br><span class="line">            cards.append(<span class="type">Card</span>(content: content))</span><br><span class="line">            cards.append(<span class="type">Card</span>(content: content))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在-ViewModel-中初始化-Model-变量"><a href="#在-ViewModel-中初始化-Model-变量" class="headerlink" title="在 ViewModel 中初始化 Model 变量"></a>在 <code>ViewModel</code> 中初始化 <code>Model</code> 变量</h5><p>接下来，我们需要初始化 <code>model</code> 变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">createCardContent</span>(<span class="params">forPairAtIndex</span> <span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][index]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(</span><br><span class="line">        numberOfPairsOfCards: <span class="number">4</span>,</span><br><span class="line">        cardContentFactory: createCardContent</span><br><span class="line">    )</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MemoryGame</code> 初始化器的第二个参数需要传入一个接受整数并返回字符串的函数。<code>createCardContent</code> 是一个接受整数并返回字符串的函数，因此我们可以将它传入。</p>
<p>我们可以使用<strong>闭包语法</strong>让它更变得更简洁一些：将 <code>createCardContent</code> 函数内容移入类初始化参数 <code>cardContentFactory</code> 后，并将函数大括号 <code>&#123;&#125;</code> 替换为 <code>in</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(</span><br><span class="line">        numberOfPairsOfCards: <span class="number">4</span>,</span><br><span class="line">        cardContentFactory: &#123; (index: <span class="type">Int</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][index]</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"><span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<strong>类型推断</strong>，输入参数为 <code>Int</code> 类型，我们可以省略类型声明，如下：</p>
<blockquote>
<p>可按住 option，并 click 查看 <code>Index</code> 推断的类型为 <code>Int</code>。类型推断在第二节有说明：<a href="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/" title="Stanford cs193p 02 | More SwiftUI">Stanford cs193p 02 | More SwiftUI</a></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(</span><br><span class="line">        numberOfPairsOfCards: <span class="number">4</span>,</span><br><span class="line">        cardContentFactory: &#123; index <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][index]</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"><span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，由于 <code>cardContentFactory</code> 是这个函数的最后一个参数，我们可以使用<strong>尾随闭包</strong>：</p>
<blockquote>
<p>尾随闭包在第二节笔记中有说明：<a href="/2024/11/21/Stanford-cs193p-02%EF%BD%9CMore-SwiftUI/" title="Stanford cs193p 02 | More SwiftUI">Stanford cs193p 02 | More SwiftUI</a></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="1-0"><a href="#1-0" class="headerlink" title="1. $0"></a><strong>1. $0</strong></h6><p>$0 是一个用于表示第一个参数的特殊占位符，这里可使用 <code>$0</code> 替代 <code>index</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][index]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="comment">// If we use $0</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; <span class="variable">$0</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>][<span class="variable">$0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h6 id="2-静态变量和函数"><a href="#2-静态变量和函数" class="headerlink" title="2. 静态变量和函数"></a><strong>2. 静态变量和函数</strong></h6><p>倘若，我们还想简化这个类的初始化，想将这个表情数组提取为一个变量 <code>emojis</code> 使用， 以下代码 XCode 会报错：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>错误信息是 “Cannot use instance member ‘emojis’ within property initializer; property initializers run before ‘self’ is available”. <code>emojis</code> 和 <code>model</code> 被称为 property initializer。<strong>由于 property initialized 的运行顺序是不确定的 (不是源代码的顺序)，我们可能会先初始化 model，但此时 emojis 还未被初始化，因此不能使用一个初始化变量去初始化另一个。</strong></p>
<p>那么怎么解决呢？</p>
<p><strong>第一种方法：将 emojis 设置为一个全局变量</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// EmojiMemoryGame.emojis[pairIndex]</span></span><br><span class="line">        <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>但这会污染命名空间，可能会与其他变量或常量发生命名冲突，难以调试。而且全局变量可以在任意位置被修改，<code>View</code> 和 <code>Model</code> 中都可以修改，导致代码很难理解，因为变量的状态可能在不知情的情况下被修改。</p>
<p>所以为了使它具有可封装性，还是得将它放回类 <code>class</code> 中。</p>
<p><strong>第二种方法：使用关键字 <code>static</code> 来解决</strong></p>
<p>我们可以使用关键字 <code>static</code> 来解决这个问题。这个关键字可以让 <code>emojis</code> 变为全局变量 (事实上被称为 type variable) 但仅限于这个类的内部访问。而且全局变量会被优先初始化，不用担心初始化变量的顺序问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">EmojiMemoryGame</span>.emojis[pairIndex]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p><code>private</code> 则可以讲这个变量限制在 <code>class</code> 内部使用，外部无法直接访问或修改。此时不再需要 <code>EmojiMemoryGame</code> 来调用 <code>emojis</code>，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> emojis <span class="operator">=</span> [<span class="string">&quot;👻&quot;</span>, <span class="string">&quot;🎃&quot;</span>, <span class="string">&quot;🕷️&quot;</span>, <span class="string">&quot;🎉&quot;</span>,<span class="string">&quot;😄&quot;</span>, <span class="string">&quot;😎&quot;</span>, <span class="string">&quot;💩&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// EmojiMemoryGame.emojis[pairIndex]</span></span><br><span class="line">        <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：现在 <code>emojis</code> 的全名其实是 <code>EmojiMemoryGame.emojis</code>.</p>
</blockquote>
<p>我们现在将上面的变量变成一个函数，然后存在 model 里：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> createMemoryGame()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">createMemoryGame</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>会有一堆错误信息。</p>
<p>我们需要将函数标记为 <code>static</code> 并增加返回类型。<strong>Swift 是不可以推断返回类型的。</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">createMemoryGame</span>() -&gt; <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> createMemoryGame()</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h6 id="3-“-thing”"><a href="#3-“-thing”" class="headerlink" title="3. “.thing”"></a><strong>3. “.thing”</strong></h6><blockquote>
<p>此处 <code>.thing</code> 是补充说明 <code>privat static</code>，并不涉及 <code>ViewModel</code> 和 <code>Model</code> 的实现</p>
</blockquote>
<p>当我们看到 “.一个东西”时, 它只有可能是静态变量或者枚举类型 <code>enum</code>。如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ContentView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>))]) &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line">.foregroundColor(.orange)</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们在代码中发现了一个 <code>.orange</code> ，它实际与 <code>Color.orange</code> 的含义完全相同。我们再打开 Swift 的开发者文档：<br><img src="/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/cs193p04_static-let-orange.jpg"></p>
<p><code>.orange</code>、<code>.pink</code> 和 <code>.purple</code> 都是静态 <code>static</code> 变量。</p>
<h4 id="2-2-3-问题解决：数组不能超出索引"><a href="#2-2-3-问题解决：数组不能超出索引" class="headerlink" title="2.2.3 问题解决：数组不能超出索引"></a>2.2.3 问题解决：数组不能超出索引</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">createMemoryGame</span>() -&gt; <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们访问数组时不能超出索引，因此需要新增一些逻辑。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">createMemoryGame</span>() -&gt; <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">4</span>) &#123; pairIndex <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> emojis.indices.contains(pairIndex) &#123;</span><br><span class="line">                <span class="keyword">return</span> emojis[pairIndex]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;⁉️&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们同时希望有至少 4 张卡：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">numberOfPairsOfCards</span>: <span class="type">Int</span>, <span class="params">cardContentFactory</span>: (<span class="type">Int</span>) -&gt; <span class="type">CardContent</span>) &#123;</span><br><span class="line">        cards <span class="operator">=</span> []</span><br><span class="line">        <span class="comment">// add numberOfParisOfCards x 2 cards</span></span><br><span class="line">        <span class="keyword">for</span> pairIndex <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="built_in">max</span>(<span class="number">2</span>, numberOfPairsOfCards) &#123;</span><br><span class="line">            <span class="keyword">let</span> content <span class="operator">=</span> cardContentFactory(pairIndex)</span><br><span class="line">            cards.append(<span class="type">Card</span>(content: content))</span><br><span class="line">            cards.append(<span class="type">Card</span>(content: content))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-在-View-中使用-ViewModel"><a href="#2-3-在-View-中使用-ViewModel" class="headerlink" title="2.3 在 View 中使用 ViewModel"></a>2.3 在 View 中使用 ViewModel</h3><blockquote>
<p>注意: 我们将 ContentView.swift 文件重命名为了 EmojiMemoryGameView.swift</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>))]) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(emojis.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(content: emojis[index])</span><br><span class="line">                    .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> content: <span class="type">String</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                base.fill(.white)</span><br><span class="line">                base.strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(content).font(.largeTitle)</span><br><span class="line">            &#125;</span><br><span class="line">            .opacity(isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            base.fill().opacity(isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>现在需要循环卡片。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>))]) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(viewModel.cards.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(card: viewModel.cards[index])</span><br><span class="line">                    .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> card: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                base.fill(.white)</span><br><span class="line">                base.strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(card.content).font(.largeTitle)</span><br><span class="line">            &#125;</span><br><span class="line">            .opacity(card.isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            base.fill().opacity(card.isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>如果我们现在想要查看卡片的正面，只需要更改 Model 即可。（<code>MemorizeGame.swift</code> 文件）</p>
<h4 id="2-3-1-CardView-Struct-优化"><a href="#2-3-1-CardView-Struct-优化" class="headerlink" title="2.3.1 CardView Struct 优化"></a>2.3.1 CardView Struct 优化</h4><p>我们还可以优化一下 CardView。调用时需要写 <code>card:</code> 很麻烦：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">CardView</span>(card: viewModel.cards[index])</span><br></pre></td></tr></table></figure>

<p>我们可以创建自己的初始化函数<code>init</code>忽略函数标签。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>))]) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(viewModel.cards.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(viewModel.cards[index])</span><br><span class="line">                    .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> card: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.card <span class="operator">=</span> card</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-放大-Emoji"><a href="#2-3-2-放大-Emoji" class="headerlink" title="2.3.2 放大 Emoji"></a>2.3.2 放大 Emoji</h4><p><img src="/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/cs193p04_biggerEmoji.png"></p>
<h3 id="2-4-View-和-ViewModel-关联优化"><a href="#2-4-View-和-ViewModel-关联优化" class="headerlink" title="2.4 View 和 ViewModel 关联优化"></a>2.4 <code>View</code> 和 <code>ViewModel</code> 关联优化</h3><h4 id="2-4-1-MARK-Intents"><a href="#2-4-1-MARK-Intents" class="headerlink" title="2.4.1 MARK: - Intents"></a>2.4.1 <code>MARK: - Intents</code></h4><p>当我们使用 <code>MAKR: - XXX</code> 时， <code>-</code> 可以在 Swift 中看起来有一条线一样，如下图。</p>
<p><img src="/2024/12/09/Stanford-cs193p-04%EF%BD%9CMVVM-%E5%BA%94%E7%94%A8/cs193p04_mark.png"></p>
<h4 id="2-4-2-洗牌"><a href="#2-4-2-洗牌" class="headerlink" title="2.4.2 洗牌"></a>2.4.2 洗牌</h4><h5 id="修改-View-和-ViewModel"><a href="#修改-View-和-ViewModel" class="headerlink" title="修改 View 和 ViewModel"></a>修改 View 和 ViewModel</h5><p>实现（修改） ViewModel:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span> &#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">      <span class="operator">...</span></span><br><span class="line">    <span class="comment">// MARK: - Intents</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shuffle</span>() &#123;</span><br><span class="line">        model.shuffle()</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">      <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现（修改）View:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">ScrollView</span> &#123;</span><br><span class="line">                cards</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Shuffle&quot;</span>) &#123;</span><br><span class="line">                viewModel.shuffle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h5 id="mutating"><a href="#mutating" class="headerlink" title="mutating"></a>mutating</h5><p>我们需要让 Model 支持洗牌的操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shuffle</span>() &#123;</span><br><span class="line">        cards.shuffle()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>但是，<code>self (Model)</code> 是不可更改的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">shuffle</span>() &#123;</span><br><span class="line">        cards.shuffle()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>任何函数需要修改 Model 必须要被标记 <strong>mutating</strong> 关键字，因为这会造成写时复制（copy on write）。</p>
<h5 id="Reactive-UI"><a href="#Reactive-UI" class="headerlink" title="Reactive UI"></a>Reactive UI</h5><p><code>@ObservableObject</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">      <span class="meta">@Published</span> <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> createMemoryGame()</span><br><span class="line">      <span class="operator">...</span></span><br><span class="line">    <span class="comment">// MARK: - Intents</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shuffle</span>() &#123;</span><br><span class="line">        model.shuffle()</span><br><span class="line">        objectWillChange.send()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objectWillChange.send()</code> 会通知 UI (View)，有些东西将要变了。 <code>@Published</code> 则在一些东西变动后, 说一些东西已经变了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">EmojiMemoryGame</span> <span class="operator">=</span> <span class="type">EmojiMemoryGame</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">ScrollView</span> &#123;</span><br><span class="line">                cards</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Shuffle&quot;</span>) &#123;</span><br><span class="line">                viewModel.shuffle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们也需要给我们的 <code>viewModel</code> 变量添加 <code>@ObservedObject</code> 。此处 <code>@ObservedObject</code> 的作用会观察 <code>EmojiMemoryGame</code> 中的 <code>@Published</code> 变量变化，如果发生变化了，则会重新渲染 UI。</p>
<p><strong>重要提示：</strong> 有一个 <code>@ObservedObject</code> 然后赋值一些东西是<strong>非常不好</strong>的习惯。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">EmojiMemoryGame</span> <span class="operator">=</span> <span class="type">EmojiMemoryGame</span>()</span><br></pre></td></tr></table></figure>

<p><strong>正确</strong> 的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">EmojiMemoryGame</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="type">Preview</span> &#123;</span><br><span class="line">	<span class="comment">//此处初始化 viewModel 变量，来进行预览</span></span><br><span class="line">    <span class="type">EmojiMemoryGameView</span>(viewModel: <span class="type">EmojiMemoryGame</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还需要修改 App：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeApp.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemorizeApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化 viewModel 对象</span></span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">var</span> game <span class="operator">=</span> <span class="type">EmojiMemoryGame</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">EmojiMemoryGameView</span>(viewModel: game)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@StateObject</code> 意思是你不能和其他 <code>View</code> 共享这个对象。</p>
<h5 id="续第五节课：-ObservedObject-和-StateObject-区别"><a href="#续第五节课：-ObservedObject-和-StateObject-区别" class="headerlink" title="续第五节课：@ObservedObject 和 @StateObject 区别"></a>续第五节课：<code>@ObservedObject</code> 和 <code>@StateObject</code> 区别</h5><p><strong>1. 示例（非课件内容）</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> value <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ParentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> counter <span class="operator">=</span> <span class="type">Counter</span>() <span class="comment">// 由父视图负责创建和管理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ChildView</span>(counter: counter) <span class="comment">// 将 ObservableObject 传递给子视图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChildView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> counter: <span class="type">Counter</span> <span class="comment">// 观察父视图传递过来的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">&quot;Counter: <span class="subst">\(counter.value)</span>&quot;</span>)</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Increment&quot;</span>) &#123;</span><br><span class="line">                counter.value <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>ParentView</code></strong> 创建并管理 <code>Counter</code> 的生命周期。</li>
<li><strong><code>ChildView</code></strong> 使用 <code>@ObservedObject</code> 观察传入的 <code>Counter</code> 实例，但不负责管理其生命周期。</li>
</ul>
<p>使用 <code>@StateObject</code> 和 <code>@ObservedObject</code> 的核心在于对<strong>生命周期的理解</strong>，确保在合适的上下文中管理和观察数据。</p>
<p><strong>2. 总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>@ObservedObject</code></th>
<th><code>@StateObject</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>负责实例创建</strong></td>
<td>否：只观察传入的 <code>ObservableObject</code></td>
<td>是：负责创建并管理 <code>ObservableObject</code> 的生命周期</td>
</tr>
<tr>
<td><strong>生命周期管理</strong></td>
<td>不管理，依赖于外部实例的生命周期</td>
<td>自动管理，当视图销毁时，<code>ObservableObject</code> 也销毁</td>
</tr>
<tr>
<td><strong>初始化时机</strong></td>
<td>外部传入实例，必须在外部已创建</td>
<td>仅在视图首次初始化时创建一次</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>子视图：观察由父视图传递的 <code>ObservableObject</code> 实例</td>
<td>父视图：创建并管理自己的 <code>ObservableObject</code> 实例</td>
</tr>
<tr>
<td><strong>重复渲染</strong></td>
<td>每次视图刷新时，观察相同的实例</td>
<td>不会在视图刷新时重复创建 <code>ObservableObject</code></td>
</tr>
</tbody></table>
<ul>
<li><code>@StateObject</code> 适用于当前视图需要自己创建并管理 <code>ObservableObject</code> 实例的生命周期，常用于父视图或独立视图。</li>
<li><code>@ObservedObject</code>适用于观察由外部传递的 <code>ObservableObject</code>，常用于子视图。</li>
<li><code>@ObservedObject</code> 和 <code>@StateObject</code> 都是用于观察 <code>ObservableObject</code> 的属性包装器，但它们有不同的使用场景和生命周期管理方式。</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford cs193p 05 | Protocol Enum Optional</title>
    <url>/2024/12/20/Stanford-cs193p-05%EF%BD%9CProtocol-Enum-Optional/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 05 集的相关笔记。</p>
<span id="more"></span>

<blockquote>
<p>本文主要内容转载于：<a href="https://nwdan.com/my-learning/stanford-cs193p-5.html">闻者通达的个人博客</a></p>
</blockquote>
<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>cs193p 课程网址: <a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></p>
<hr>
<h2 id="1-Equatable-Protocol"><a href="#1-Equatable-Protocol" class="headerlink" title="1. Equatable Protocol"></a>1. Equatable Protocol</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">EmojiMemoryGame</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">ScrollView</span> &#123;</span><br><span class="line">                cards</span><br><span class="line">                    .animation(.default, value: )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;Shuffle&quot;</span>) &#123;</span><br><span class="line">                viewModel.shuffle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过添加 <code>.animation</code> 视图修饰符来制作动画。<code>value</code> 表示它只会在此值更改时进行动画处理。</p>
<p>但是，这会导致错误 “Referencing instance method ‘animation(:value:)’ on ‘Array’ requires that ‘MemoryGame&lt;String&gt;.Card’ conform to ‘Equatable’”。这表明，如果某些内容发生更改，动画将复制该更改。当某些内容也发生变化时，它需要另一个副本。仅当两个副本不相等时，动画才会进行动画处理。因此，我们需要使 <code>Card</code> 遵循 <code>Equatable</code> 协议（protocol）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Card</span>: <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">    	<span class="comment">// 为了实现 Equatable 协议，此处需要编写一个静态函数如下：</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span> (<span class="params">lhs</span>: <span class="type">Card</span>, <span class="params">rhs</span>: <span class="type">Card</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.isFaceUp <span class="operator">==</span> rhs.isFaceUp <span class="operator">&amp;&amp;</span></span><br><span class="line">            lhs.isMatched <span class="operator">==</span> rhs.isMatched <span class="operator">&amp;&amp;</span></span><br><span class="line">            lhs.content <span class="operator">==</span> rhs.content</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> isMatched <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> content: <span class="type">CardContent</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>为了实现 <code>Equatable</code> 协议，我们需要编写一个静态函数，该函数接受一个函数并返回一个 <code>Bool</code>。该函数需要两个参数，一个左侧 <code>Card</code> 和一个右侧 <code>Card</code>。</p>
<p>但是，错误信息 <code>“Referencing operator function &#39;==&#39; on &#39;Equatable&#39; requires that &#39;CardContent&#39; conform to &#39;Equatable&#39;”</code> 表示我们需要使 <code>CardContent</code> 相等。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; <span class="keyword">where</span> <span class="type">CardContent</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Card</span>: <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span> (<span class="params">lhs</span>: <span class="type">Card</span>, <span class="params">rhs</span>: <span class="type">Card</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.isFaceUp <span class="operator">==</span> rhs.isFaceUp <span class="operator">&amp;&amp;</span></span><br><span class="line">            lhs.isMatched <span class="operator">==</span> rhs.isMatched <span class="operator">&amp;&amp;</span></span><br><span class="line">            lhs.content <span class="operator">==</span> rhs.content</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> isMatched <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> content: <span class="type">CardContent</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使我们的 <code>CardContent</code> 相等，我们使用 <code>where CardContent: Equatable</code> 来实现它。这意味着，我们对 <code>Card</code> 还是有所限制的。另外，Swift 中另一个很酷的特性是，如果我们像上面这样对 <code>CardContent</code> 比较每件事，我们就可以直接删除之前在 <code>Card</code> 结构体中添加的静态函数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; <span class="keyword">where</span> <span class="type">CardContent</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">      <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Card</span>: <span class="title class_ inherited__">Equatable</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> isMatched <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> content: <span class="type">CardContent</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它确实有效，但卡片的动画效果为淡入淡出，看起来不像洗牌。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>), spacing: <span class="number">0</span>)], spacing: <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(viewModel.cards.indices, id: \.<span class="keyword">self</span>) &#123; index <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(viewModel.cards[index])</span><br><span class="line">                    .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">                    .padding(<span class="number">4</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>因为我们的 ForEach 迭代数组的索引。它从卡 0、1、2、3 …并为每个 API 创建 Card 视图。例如，当我们洗牌时，我们会将牌从 0 号移动到 7 号。但是 ForEach 仍然显示从 0、1、2…</p>
<p>我们想要移动卡片本身，即 Card 视图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>), spacing: <span class="number">0</span>)], spacing: <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(viewModel.cards, id: \.<span class="keyword">self</span>) &#123; card <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(card)</span><br><span class="line">                    .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">                    .padding(<span class="number">4</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们对 <code>ForEach</code> 做了一些改变。上面的代码将产生错误 <code>&quot;Referencing initializer &#39;init(\_:id:content:)&#39; on &#39;ForEach&#39; requires that &#39;MemoryGame\\&lt;String\\&gt;.Card&#39; conform to &#39;Hashable&#39;&quot;</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>), spacing: <span class="number">0</span>)], spacing: <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(viewModel.cards) &#123; card <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(card)</span><br><span class="line">                    .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">                    .padding(<span class="number">4</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>现在，是时候谈谈 <code>id: \.self</code> 了，用来识别这些 <code>cards</code>。</p>
<p>在这里，我们想让 <code>id</code> 唯一，即对某张 <code>Card</code> 具有唯一 <code>id</code> 且不会变化，但通过 <code>id:\.self</code> 无法实现，因为 <code>Card</code> 包括 <code>isFaceUp</code> 、<code>isMatch</code> 属性，当我们单击卡片时，这些属性会发生变化，<code>id</code> 就会发生变化。</p>
<p>我们需要一些其他东西来识别 <code>Card</code>。</p>
<h2 id="2-Identifiable-Protocol"><a href="#2-Identifiable-Protocol" class="headerlink" title="2. Identifiable Protocol"></a>2. Identifiable Protocol</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; <span class="keyword">where</span> <span class="type">CardContent</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">numberOfPairsOfCards</span>: <span class="type">Int</span>, <span class="params">cardContentFactory</span>: (<span class="type">Int</span>) -&gt; <span class="type">CardContent</span>) &#123;</span><br><span class="line">        cards <span class="operator">=</span> []</span><br><span class="line">        <span class="comment">// add numberOfParisOfCards x 2 cards</span></span><br><span class="line">        <span class="keyword">for</span> pairIndex <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="built_in">max</span>(<span class="number">2</span>, numberOfPairsOfCards) &#123;</span><br><span class="line">            <span class="keyword">let</span> content <span class="operator">=</span> cardContentFactory(pairIndex)</span><br><span class="line">            cards.append(<span class="type">Card</span>(content: content, id: <span class="string">&quot;<span class="subst">\(pairIndex<span class="operator">+</span><span class="number">1</span>)</span>a&quot;</span>))</span><br><span class="line">            cards.append(<span class="type">Card</span>(content: content, id: <span class="string">&quot;<span class="subst">\(pairIndex<span class="operator">+</span><span class="number">1</span>)</span>b&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">      <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Card</span>: <span class="title class_ inherited__">Equatable</span>, <span class="title class_ inherited__">Identifiable</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> isMatched <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> content: <span class="type">CardContent</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加了一个键入为 String 的 id，并在创建新卡时分配该 id。id 看起来像 1a、1b、2a、2b、3a、3b 等……</p>
<h2 id="3-CustomDebugStringConvertible"><a href="#3-CustomDebugStringConvertible" class="headerlink" title="3. CustomDebugStringConvertible"></a>3. CustomDebugStringConvertible</h2><p><img src="/2024/12/20/Stanford-cs193p-05%EF%BD%9CProtocol-Enum-Optional/cs193p05-1.png"></p>
<p>我们当前的印刷信息相当复杂。所以，我们可以让它变得更好。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Card</span>: <span class="title class_ inherited__">Equatable</span>, <span class="title class_ inherited__">Identifiable</span>, <span class="title class_ inherited__">CustomDebugStringConvertible</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> isMatched <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> content: <span class="type">CardContent</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">        <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;</span><br><span class="line">            <span class="string">&quot;<span class="subst">\(id)</span>: <span class="subst">\(content)</span> <span class="subst">\(isFaceUp <span class="operator">?</span> <span class="string">&quot;up&quot;</span> : <span class="string">&quot;down&quot;</span>)</span> <span class="subst">\(isMatched <span class="operator">?</span> <span class="string">&quot;matched&quot;</span>: <span class="string">&quot;&quot;</span>)</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们为 Card 实施 <code>CustomDebugStringConvertible</code> protocol 协议，并定义 debugDescription。</p>
<p>现在，它变得更简洁了。</p>
<p><img src="/2024/12/20/Stanford-cs193p-05%EF%BD%9CProtocol-Enum-Optional/cs193p05-2.jpg"></p>
<h2 id="4-ViewModel-Intent-Part-1：翻转卡片"><a href="#4-ViewModel-Intent-Part-1：翻转卡片" class="headerlink" title="4. ViewModel Intent - Part 1：翻转卡片"></a>4. ViewModel Intent - Part 1：翻转卡片</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: <span class="number">85</span>), spacing: <span class="number">0</span>)], spacing: <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ForEach</span>(viewModel.cards) &#123; card <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(card)</span><br><span class="line">                    .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">                    .padding(<span class="number">4</span>)</span><br><span class="line">                    .onTapGesture &#123;</span><br><span class="line">                        viewModel.choose(card)</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .foregroundColor(.orange)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line">        card.isFaceUp.toggle()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>现在，我们开始实现用户的意图（翻转卡片）。</p>
<p>我们可以使用 <code>.onTapGesture</code> 和 <code>.toggle()</code> 来在用户触摸屏幕时翻转卡片。但是，由于卡片是值类型，当 choose 函数获取卡片的副本时，我们无法直接使用 <code>.toggle()</code> 来翻转它。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> chosenIndex <span class="operator">=</span> index(of: card)</span><br><span class="line">        cards[chosenIndex].isFaceUp.toggle()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">index</span>(<span class="params">of</span> <span class="params">card</span>: <span class="type">Card</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> cards.indices &#123;</span><br><span class="line">            <span class="keyword">if</span> cards[index].id <span class="operator">==</span> card.id &#123;</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// <span class="doctag">FIXME:</span> bogus!</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们将直接使用卡片的索引来修改卡片数组。我们实现了一个名为 index 的函数，用于查找卡片的索引。</p>
<p>目前，如果找不到卡片，我们将返回索引为 0 的卡片，也就是我们的第一张卡片。</p>
<p>在这之前，需要先了解一下枚举（enum）。</p>
<h2 id="5-Enum"><a href="#5-Enum" class="headerlink" title="5. Enum"></a>5. Enum</h2><h3 id="5-1-Enum-简介"><a href="#5-1-Enum-简介" class="headerlink" title="5.1 Enum 简介"></a>5.1 Enum 简介</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FastFoodMenuItem</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> hamburger</span><br><span class="line">	<span class="keyword">case</span> fries</span><br><span class="line">	<span class="keyword">case</span> drink</span><br><span class="line">	<span class="keyword">case</span> cookie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>Enum</code> 是除了 <code>struct</code> 和 <code>class</code> 以外的另一种数据结构。</strong></p>
</li>
<li><p>它只能包含离散的状态。</p>
</li>
<li><p>枚举是一种值类型（如 <code>struct</code>），因此它会在传递时被复制。</p>
</li>
<li><p>每个状态都可以(但不是必须) 有自己的“关联数据”</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FastFoodMenuItem</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> hamburger(numberOfPatties: <span class="type">Int</span>)</span><br><span class="line">  	<span class="keyword">case</span> fries(size: <span class="type">FryOrderSize</span>)</span><br><span class="line">  	<span class="keyword">case</span> drink(<span class="type">String</span>, ounces: <span class="type">Int</span>) <span class="comment">// the unnamed String is the brand, e.g. &quot;Coke&quot;</span></span><br><span class="line">  	<span class="keyword">case</span> cookie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，饮料案例有 2 条关联数据（其中一条是“未命名的”）<br>在上面的示例中， <code>FryOrderSize</code> 也可能是一个枚举，例如 …</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FryOrderSize</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> large</span><br><span class="line">  <span class="keyword">case</span> small</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-2-设置枚举的值"><a href="#5-2-设置枚举的值" class="headerlink" title="5.2 设置枚举的值"></a>5.2 设置枚举的值</h3><p>设置枚举的值时，如果有关联数据，必须提供关联的数据值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> menuItem: <span class="type">FastFoodMenuItem</span> <span class="operator">=</span> <span class="type">FastFoodMenuItem</span>.hamburger(patties: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> otherItem: <span class="type">FastFoodMenuItem</span> <span class="operator">=</span> <span class="type">FastFoodMenuItem</span>.cookie</span><br></pre></td></tr></table></figure>

<p>Swift 可以在赋值左侧或另一侧推断类型，但不能同时。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> menuItem <span class="operator">=</span> <span class="type">FastFoodMenuItem</span>.hamburger(patties: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> otherItem: <span class="type">FastFoodMenuItem</span> <span class="operator">=</span> .cookie</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift can&#x27;t figure this out</span></span><br><span class="line"><span class="keyword">var</span> yetAnotherItem <span class="operator">=</span> .cookie</span><br></pre></td></tr></table></figure>

<h3 id="5-3-检查枚举的状态"><a href="#5-3-检查枚举的状态" class="headerlink" title="5.3 检查枚举的状态"></a>5.3 检查枚举的状态</h3><p>通常使用 <code>switch</code> 来检查枚举的状态，尽管我们可以使用 <code>if</code> 语句，但如果有关联数据，则这种情况不常见。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuItem <span class="operator">=</span> <span class="type">FastFoodMenuItem</span>.hamburger(patties: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">switch</span> menuItem &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">FastFoodMenuItem</span>.hamburger: <span class="built_in">print</span>(<span class="string">&quot;burger&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">FastFoodMenuItem</span>.fries: <span class="built_in">print</span>(<span class="string">&quot;fries&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">FastFoodMenuItem</span>.drink: <span class="built_in">print</span>(<span class="string">&quot;drink&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">FastFoodMenuItem</span>.cookie: <span class="built_in">print</span>(<span class="string">&quot;cookie&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将在控制台上打印 “burger”。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuItem <span class="operator">=</span> <span class="type">FastFoodMenuItem</span>.hamburger(patties: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">switch</span> menuItem &#123;</span><br><span class="line">  <span class="keyword">case</span> .hamburger: <span class="built_in">print</span>(<span class="string">&quot;burger&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .fries: <span class="built_in">print</span>(<span class="string">&quot;fries&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .drink: <span class="built_in">print</span>(<span class="string">&quot;drink&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .cookie: <span class="built_in">print</span>(<span class="string">&quot;cookie&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有必要使用完全表示的 <code>FastFoodMenuItem.fries</code> （因为 Swift 可以推断出 <code>FastFoodMenuItem</code> ）</p>
<h3 id="5-4-break"><a href="#5-4-break" class="headerlink" title="5.4 break"></a>5.4 <code>break</code></h3><p>如果您不想在给定的情况下执行任何操作，请使用 <code>break</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuItem <span class="operator">=</span> <span class="type">FastFoodMenuItem</span>.hamburger(patties: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">switch</span> menuItem &#123;</span><br><span class="line">  <span class="keyword">case</span> .hamburger: <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> .fries: <span class="built_in">print</span>(<span class="string">&quot;fries&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .drink: <span class="built_in">print</span>(<span class="string">&quot;drink&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .cookie: <span class="built_in">print</span>(<span class="string">&quot;cookie&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码不会在控制台上打印任何内容。</p>
<h3 id="5-5-Default"><a href="#5-5-Default" class="headerlink" title="5.5 Default"></a>5.5 <code>Default</code></h3><p><code>switch</code> 必须处理所有可能的情况，因此通常使用 <code>default</code> 来管理不感兴趣的状态。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuItem <span class="operator">=</span> <span class="type">FastFoodMenuItem</span>.cookie</span><br><span class="line"><span class="keyword">switch</span> menuItem &#123;</span><br><span class="line">  <span class="keyword">case</span> .hamburger: <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> .fries: <span class="built_in">print</span>(<span class="string">&quot;fries&quot;</span>)</span><br><span class="line">  <span class="keyword">default</span>: <span class="built_in">print</span>(<span class="string">&quot;other&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 menuItem 是一个 cookie，则上面的代码将在控制台上打印 “other”。</p>
<p>顺便说一句，你可以 <code>switch</code> 任何类型（不仅仅是 enum），例如 <code>string</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">switch</span> s &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;goodbye&quot;</span>: <span class="operator">...</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>: <span class="operator">...</span></span><br><span class="line">  	<span class="keyword">default</span>: <span class="operator">...</span> <span class="comment">// gotta have this for String because switch has to cover ALL cases</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-6-允许多行"><a href="#5-6-允许多行" class="headerlink" title="5.6 允许多行"></a>5.6 允许多行</h3><p><code>switch</code> 中的每个 case 都可以是多行，并且不会落入下一个 case …</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuItem <span class="operator">=</span> <span class="type">FastFoodMenuItem</span>.fries(size: <span class="type">FryOrderSize</span>.large)</span><br><span class="line"><span class="keyword">switch</span> menuItem &#123;</span><br><span class="line">  <span class="keyword">case</span> .hamburger: <span class="built_in">print</span>(<span class="string">&quot;burger&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .fries:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;yummy&quot;</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;fries&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .drink:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;drink&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .cookie: <span class="built_in">print</span>(<span class="string">&quot;cookie&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码会在控制台上打印 “yummy” 和 “fries”，而不是 “饮料”。</p>
<p>如果您将关键字 <code>fallthrough</code> 放在某个 <code>case</code> 的最后一行，那么它将会继续执行下一个 <code>case</code>。</p>
<p>关于关联数据，您可以通过 <code>switch</code> 语句访问这些数据，使用 <code>let</code>语法进行解构。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menuItem <span class="operator">=</span> <span class="type">FastFoodMenuItem</span>.drink(<span class="string">&quot;Coke&quot;</span>, ounces: <span class="number">32</span>)</span><br><span class="line"><span class="keyword">switch</span> menuItem &#123;</span><br><span class="line">  <span class="keyword">case</span> .hamburger(<span class="keyword">let</span> pattyCount): <span class="built_in">print</span>(<span class="string">&quot;a burger with <span class="subst">\(pattyCount)</span> patties&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .fries(<span class="keyword">let</span> size): <span class="built_in">print</span>(<span class="string">&quot;a <span class="subst">\(size)</span> order of fries!&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .drink(<span class="keyword">let</span> brand, <span class="keyword">let</span> ounces): <span class="built_in">print</span>(<span class="string">&quot;a <span class="subst">\(ounces)</span>oz <span class="subst">\(brand)</span>&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> .cookie: <span class="built_in">print</span>(<span class="string">&quot;a cookie!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，检索关联数据的局部变量可以具有不同的名称</p>
<p>（例如 <code>pattyCount</code> 与 enum 声明中的 patties 的比较）</p>
<p>（例如，上面的 <code>brand</code> 在枚举声明中甚至没有名称）</p>
<h3 id="5-7-有-Method-，不能有存储属性"><a href="#5-7-有-Method-，不能有存储属性" class="headerlink" title="5.7 有 Method ，不能有存储属性"></a>5.7 有 <code>Method</code> ，不能有存储属性</h3><p>枚举可以有方法（和计算属性），但不能有存储属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FastFoodMenuItem</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> hamburger(numberOfPatties: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> fries(size: <span class="type">FryOrderSize</span>)</span><br><span class="line">  <span class="keyword">case</span> drink(<span class="type">String</span>, ounces: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> cookie</span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">isIncludedInSpecialOrder</span>(<span class="params">number</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123; &#125;</span><br><span class="line">  <span class="keyword">var</span> colories: <span class="type">Int</span> &#123; <span class="comment">// switch on self and calculate caloric value here &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>colories</code> 和 <code>isIncludedInSpecialOrder</code> 分别为计算属性和方法。</p>
<p>枚举的状态仅取决于它所处的 <code>case</code> 以及该 <code>case</code> 的关联数据.</p>
<p>在枚举自己的方法中，你可以使用 self …</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">FastFoodMenuItem</span> &#123;</span><br><span class="line">  <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">func</span> <span class="title function_">isIncludedInSpecialOrder</span>(<span class="params">number</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> .hamburger(<span class="keyword">let</span> pettyCount): <span class="keyword">return</span> pettyCount <span class="operator">==</span> number</span><br><span class="line">      <span class="keyword">case</span> .fries, .cookie: <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// a drink and cookie in every special order</span></span><br><span class="line">      <span class="keyword">case</span> .drink(<span class="keyword">_</span>, <span class="keyword">let</span> ounces): <span class="keyword">return</span> ounces <span class="operator">==</span> <span class="number">16</span> <span class="comment">// &amp; 16oz drink of any kind</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-8-获取枚举的所有成员"><a href="#5-8-获取枚举的所有成员" class="headerlink" title="5.8 获取枚举的所有成员"></a>5.8 获取枚举的所有成员</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TeslaModel</span>: <span class="title class_ inherited__">CaseIterable</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">X</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">S</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Three</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，这个枚举将有一个静态变量 <code>.allCases</code>，可以迭代。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> model <span class="keyword">in</span> <span class="type">TestlaModel</span>.allCases &#123;</span><br><span class="line">  reportSalesNumbers(for: model)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">reportSalesNumbers</span>(<span class="params">for</span> <span class="params">model</span>: <span class="type">TeslaModel</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> model &#123; <span class="operator">...</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-optional"><a href="#6-optional" class="headerlink" title="6. optional"></a>6. <code>optional</code></h3><p><strong>optional 是一个枚举</strong>。它看起来像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Optional</span>&lt;<span class="type">T</span>&gt; &#123; <span class="comment">// a generic type</span></span><br><span class="line">  <span class="keyword">case</span> none</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">T</span>) <span class="comment">// the some case has associated value of type T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以看到它只能有两种值： 已设置值的 case （<code>some</code>） 或未设置值的 case（<code>none</code>）。在已设置的 case 中，它可以有一些关联值，它们是“generic type” <code>T</code> 。</p>
<p>我们在哪些地方使用 Optional？我们可能有一个值，它有时可以是“未设置”、“未指定”或“未确定”的。这种情况经常发生。这就是 Swift 引入许多“语法糖”的原因，以便于使用可选值（Optionals）。</p>
<h3 id="6-1-optional-声明"><a href="#6-1-optional-声明" class="headerlink" title="6.1 optional 声明"></a>6.1 optional 声明</h3><p><strong>声明</strong>一个类型为 <code>Optional&lt;T&gt;</code> 的变量可以使用语法 <code>T?</code>。然后，您可以将其赋值为 <code>nil</code>（Optional.none），或者可以将其赋值为类型 <code>T</code> 的某个值（<code>Optional.some</code>，并使得 <code>关联值 = 该值</code>）。</p>
<p>请注意，可选值总是隐式地以 <code>nil</code> 开始。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello: <span class="type">String</span>?             <span class="keyword">var</span> hello: <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> .none</span><br><span class="line"><span class="keyword">var</span> hello: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>   <span class="keyword">var</span> hello: <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> .some(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> hello: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span>       <span class="keyword">var</span> hello: <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> .none</span><br></pre></td></tr></table></figure>

<h3 id="6-2-optional-访问值"><a href="#6-2-optional-访问值" class="headerlink" title="6.2 optional 访问值"></a>6.2 optional 访问值</h3><ol>
<li>你可以通过 <code>!</code> 强制访问关联值。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hello: <span class="type">String</span>? <span class="operator">=</span> <span class="operator">...</span></span><br><span class="line"><span class="built_in">print</span>(hello<span class="operator">!</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> hello &#123;</span><br><span class="line">  <span class="keyword">case</span> .none: <span class="comment">// raise an exception (crash)</span></span><br><span class="line">  <span class="keyword">case</span> .some(<span class="keyword">let</span> data): <span class="built_in">print</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>或者“安全地”使用 <code>if let</code> 然后使用 <code>&#123; &#125;</code> 中安全获取的关联值。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> safehello <span class="operator">=</span> hello &#123;</span><br><span class="line">  <span class="built_in">print</span>(safehello)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> hello &#123;</span><br><span class="line">  <span class="keyword">case</span> .none: <span class="comment">// raise an exception (crash)</span></span><br><span class="line">  <span class="keyword">case</span> .some(<span class="keyword">let</span> safehello): <span class="built_in">print</span>(safehello)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>您也可以使用较短的版本，同 <code>2</code>。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> hello &#123;</span><br><span class="line">  <span class="built_in">print</span>(hello)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>还有 <code>??</code> 它执行 “Optional defaulting”，被称为“nil-coalescng 运算符”。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hello: <span class="type">String</span>? <span class="operator">=</span> <span class="operator">...</span></span><br><span class="line"><span class="keyword">let</span> y <span class="operator">=</span> x <span class="operator">??</span> <span class="string">&quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> hello &#123;</span><br><span class="line">  <span class="keyword">case</span> .none: y <span class="operator">=</span> <span class="string">&quot;foo&quot;</span></span><br><span class="line">  <span class="keyword">case</span> .some(<span class="keyword">let</span> data): y <span class="operator">=</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在回到 Code。</p>
<h2 id="7-ViewModel-Intent-Part-2"><a href="#7-ViewModel-Intent-Part-2" class="headerlink" title="7. ViewModel Intent - Part 2"></a>7. ViewModel Intent - Part 2</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">index</span>(<span class="params">of</span> <span class="params">card</span>: <span class="type">Card</span>) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> cards.indices &#123;</span><br><span class="line">            <span class="keyword">if</span> cards[index].id <span class="operator">==</span> card.id &#123;</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>让我们使用 Optional 修复虚假信息。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> chosenIndex <span class="operator">=</span> index(of: card) &#123;</span><br><span class="line">            cards[chosenIndex].isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们还需要更改 choose 函数，因为 <code>chosenIndex</code> 现在是 Optional 类型。我们可以通过使用 <code>!</code>，但如果 <code>index</code> 返回 <code>nil</code> 会报错。所以，我们使用 safe unwrap。</p>
<h3 id="7-1-函数作为参数"><a href="#7-1-函数作为参数" class="headerlink" title="7.1 函数作为参数"></a>7.1 函数作为参数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> chosenIndex <span class="operator">=</span> cards.firstIndex(where: &#123; <span class="variable">$0</span>.id <span class="operator">==</span> card.id &#125;) &#123;</span><br><span class="line">            cards[chosenIndex].isFaceUp.toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们不必自行实现函数 <code>index</code>。我们实际上可以找到 <code>chosenIndex</code>。</p>
<h3 id="7-2-Flip-the-cards-down-when-NOT-matched"><a href="#7-2-Flip-the-cards-down-when-NOT-matched" class="headerlink" title="7.2 Flip the cards down when NOT matched"></a>7.2 Flip the cards down when NOT matched</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> indexOfTheOneAndOnlyFaceUpCard: <span class="type">Int</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> chosenIndex <span class="operator">=</span> cards.firstIndex(where: &#123; <span class="variable">$0</span>.id <span class="operator">==</span> card.id &#125;) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="operator">!</span>cards[chosenIndex].isFaceUp <span class="operator">&amp;&amp;</span> <span class="operator">!</span>cards[chosenIndex].isMatched &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> potentialMatchIndex <span class="operator">=</span> indexOfTheOneAndOnlyFaceUpCard &#123;</span><br><span class="line">                    <span class="comment">// Two Cards Face Up</span></span><br><span class="line">                    <span class="keyword">if</span> cards[chosenIndex].content <span class="operator">==</span> cards[potentialMatchIndex].content &#123;</span><br><span class="line">                        cards[chosenIndex].isMatched <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                        cards[potentialMatchIndex].isMatched <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    indexOfTheOneAndOnlyFaceUpCard <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> index <span class="keyword">in</span> cards.indices &#123;</span><br><span class="line">                        cards[index].isFaceUp <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    indexOfTheOneAndOnlyFaceUpCard <span class="operator">=</span> chosenIndex</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cards[chosenIndex].isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们的游戏逻辑现在看起来是正确的，但是我们需要在牌匹配时隐藏它们。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                base.fill(.white)</span><br><span class="line">                base.strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(card.content)</span><br><span class="line">                    .font(.system(size: <span class="number">200</span>))</span><br><span class="line">                    .minimumScaleFactor(<span class="number">0.01</span>)</span><br><span class="line">                    .aspectRatio(<span class="number">1</span>, contentMode: .fit)</span><br><span class="line">            &#125;</span><br><span class="line">            .opacity(card.isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            base.fill().opacity(card.isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .opacity(card.isFaceUp <span class="operator">||</span> <span class="operator">!</span>card.isMatched <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>所以，我们回到我们的视图，让匹配的卡片不透明度为 0。</p>
<p>我们的主要游戏逻辑现在应该可以工作了。</p>
<h2 id="7-3-set-get-计算属性"><a href="#7-3-set-get-计算属性" class="headerlink" title="7.3 set+get 计算属性"></a>7.3 set+get 计算属性</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">        <span class="keyword">var</span> indexOfTheOneAndOnlyFaceUpCard: <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> faceUpCardIndices <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> cards.indices &#123;</span><br><span class="line">                <span class="keyword">if</span> cards[index].isFaceUp &#123;</span><br><span class="line">                    faceUpCardIndices.append(index)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> faceUpCardIndices.count <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> faceUpCardIndices.first</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> cards.indices &#123;</span><br><span class="line">                <span class="keyword">if</span> index <span class="operator">==</span> newValue &#123;</span><br><span class="line">                    cards[index].isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cards[index].isFaceUp <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过将 <code>indexOfTheOneAndOnlyFaceUpCard</code> 制作成一个计算属性来优化游戏逻辑。这个计算属性在被获取时将返回其他面朝上的卡片（或 nil）。当被设置（<code>indexOfTheOneAndOnlyFaceUpCard = something </code>）时，它将把传入的卡片设置为面朝上，所有其他卡片则面朝下。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> chosenIndex <span class="operator">=</span> cards.firstIndex(where: &#123; <span class="variable">$0</span>.id <span class="operator">==</span> card.id &#125;) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="operator">!</span>cards[chosenIndex].isFaceUp <span class="operator">&amp;&amp;</span> <span class="operator">!</span>cards[chosenIndex].isMatched &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> potentialMatchIndex <span class="operator">=</span> indexOfTheOneAndOnlyFaceUpCard &#123;</span><br><span class="line">                    <span class="comment">// Two Cards Face Up</span></span><br><span class="line">                    <span class="keyword">if</span> cards[chosenIndex].content <span class="operator">==</span> cards[potentialMatchIndex].content &#123;</span><br><span class="line">                        cards[chosenIndex].isMatched <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                        cards[potentialMatchIndex].isMatched <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    indexOfTheOneAndOnlyFaceUpCard <span class="operator">=</span> chosenIndex</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cards[chosenIndex].isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们的计算属性已经实现了很多步骤，我们可以对 <code>choose</code> 函数进行简化。</p>
<h3 id="7-4-choose-函数优化"><a href="#7-4-choose-函数优化" class="headerlink" title="7.4 choose 函数优化"></a>7.4 <code>choose</code> 函数优化</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> indexOfTheOneAndOnlyFaceUpCard: <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> faceUpCardIndices <span class="operator">=</span> cards.indices.filter &#123; index <span class="keyword">in</span> cards[index].isFaceUp &#125;</span><br><span class="line">            <span class="keyword">return</span> faceUpCardIndices.count <span class="operator">==</span> <span class="number">1</span> <span class="operator">?</span> faceUpCardIndices.first : <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            cards.indices.forEach &#123; cards[<span class="variable">$0</span>].isFaceUp <span class="operator">=</span> (newValue <span class="operator">==</span> <span class="variable">$0</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>现在，我们使用 functional programming 来优化我们的代码。我们还可以使用 <code>extension</code> 使代码变得更好。</p>
<h3 id="7-5-extension"><a href="#7-5-extension" class="headerlink" title="7.5 extension"></a>7.5 <code>extension</code></h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemorizeGame.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; <span class="keyword">where</span> <span class="type">CardContent</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt;</span><br><span class="line"></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">      <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> indexOfTheOneAndOnlyFaceUpCard: <span class="type">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; cards.indices.filter &#123; index <span class="keyword">in</span> cards[index].isFaceUp &#125;.only &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; cards.indices.forEach &#123; cards[<span class="variable">$0</span>].isFaceUp <span class="operator">=</span> (newValue <span class="operator">==</span> <span class="variable">$0</span>) &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">      <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> only: <span class="type">Element</span>? &#123;</span><br><span class="line">        count <span class="operator">==</span> <span class="number">1</span> <span class="operator">?</span> first : <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对 <code>array</code> 类型添加 <code>extension</code>，以便在我们的 <code>indexOfTheOneAndOnlyFaceUpCard</code> 计算属性中使用 <code>.only</code>。</p>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford cs193p 06 | Layout @ViewBuilder</title>
    <url>/2024/12/31/Stanford-cs193p-06-Layout-ViewBuilder/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 06 集的相关笔记。</p>
<span id="more"></span>

<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>cs193p 课程网址: <a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a></p>
<h2 id="0-本节概要"><a href="#0-本节概要" class="headerlink" title="0 本节概要"></a>0 本节概要</h2><ul>
<li><p><strong>布局</strong><br>Swift 如何将空间分配给其视图？<br>演示：根据提供的空间为我们的卡片选择适当的大小。</p>
</li>
<li><p><strong>@ViewBuilder</strong><br>关于它如何工作的更多信息。<br>演示：创建我们自己的“组合视图” (AspectVGrid)。</p>
</li>
</ul>
<h2 id="1-布局"><a href="#1-布局" class="headerlink" title="1. 布局"></a>1. 布局</h2><p><strong>视图是如何分配屏幕上的空间的？</strong></p>
<ol>
<li>容器视图为内部视图提供部分或者全部的容器视图空间。</li>
<li>内部视图接着选择它们想要的大小（只有它们可以这样做）。</li>
<li>然后容器视图对内部视图进行位置排列。</li>
</ol>
<h3 id="1-1-堆叠视图-HStack、VStack"><a href="#1-1-堆叠视图-HStack、VStack" class="headerlink" title="1.1 堆叠视图 HStack、VStack"></a>1.1 堆叠视图 <code>HStack</code>、<code>VStack</code></h3><p>堆叠视图划分空间的步骤如下：</p>
<ul>
<li><p><strong>堆叠视图</strong> 将它们获得的空间划分，然后将空间提供给内部视图。它首先将空间提供给其“最不灵活”（即尺寸方面） 的子视图。</p>
<ul>
<li><strong>“不灵活”视图的示例</strong>：图像（它希望有一个固定的大小）。</li>
<li><strong>另一个示例（稍微灵活一些）</strong>：文本（总是希望根据其文本精准调整大小）。</li>
<li><strong>非常灵活视图示例</strong>：圆角矩形（总是会使用所提供的任何空间）。</li>
</ul>
</li>
<li><p>在一个视图选择它想要的大小后，其大小将从可用空间中移除。然后堆叠视图将继续处理下一个“最不灵活”的视图。</p>
</li>
<li><p><strong>非常灵活的视图</strong>（即那些将占用所有提供空间的视图）会大致均匀分配空间。</p>
</li>
<li><p>重复上述过程。</p>
</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>在堆叠视图内部，视图选择自己的大小后，堆叠视图会调整其大小以适应它们。</li>
<li>如果堆叠中的任何视图是“非常灵活的”，那么堆叠视图也将是“非常灵活的”。</li>
</ul>
<h4 id="1-1-1-布局工具"><a href="#1-1-1-布局工具" class="headerlink" title="1.1.1 布局工具"></a>1.1.1 布局工具</h4><p>有几个非常有价值的布局视图，通常被放置在堆栈中：</p>
<ul>
<li><p><strong>Spacer (minLength: CGFloat)</strong><br>总是占用其所分配的所有空间。<br>不绘制任何内容。<br><code>minLength</code> 默认设置为在特定平台上你可能希望的最小间距。</p>
</li>
<li><p><strong>Divider()</strong><br>在堆叠视图的布局方向上绘制分割线。<br>例如，在 <code>HStack</code> 中，Divider 会绘制一条垂直线。<br>在堆叠的方向上，它只占用绘制该线所需的最小空间。<br>在横向（交叉）方向上，它会占用所有提供给它的空间。</p>
</li>
</ul>
<h4 id="1-1-2-布局优先级"><a href="#1-1-2-布局优先级" class="headerlink" title="1.1.2 布局优先级"></a>1.1.2 布局优先级</h4><p>堆叠视图选择接下来要提供空间的视图，可以通过 <code>.layoutPriority(Double)</code>被覆盖。换句话说，布局优先级可以优先于“最不灵活”的视图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">HStack</span> &#123;</span><br><span class="line">	<span class="type">Text</span>(<span class="string">&quot;Important&quot;</span>).layoutPriority(<span class="number">100</span>) <span class="comment">// 任何浮点数都可以</span></span><br><span class="line">	<span class="type">Image</span>(systemName: <span class="string">&quot;arrow.up&quot;</span>) <span class="comment">// 默认布局优先级为 0</span></span><br><span class="line">	<span class="type">Text</span>(<span class="string">&quot;Unimportant&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的 <code>Text(&quot;important&quot;)</code> 文本将首先获得所需空间。</li>
<li>然后 <code>Image</code> 会获得它的空间（因为它比 <code>Text(&quot;Unimportant&quot;)</code> 更不灵活）。</li>
<li>最后， <code>Text(&quot;Unimportant&quot;)</code> 将必须尝试适应剩余空间。如果文本获得的空间不足，它将省略显示（例如，“Swift is…”而不是“Swift is great！”）。</li>
</ul>
<h4 id="1-1-3-视图对齐"><a href="#1-1-3-视图对齐" class="headerlink" title="1.1.3 视图对齐"></a>1.1.3 视图对齐</h4><p>堆叠视图布局内部视图的另一个重要方面是对齐方式。</p>
<p>当 <code>VStack</code> 将视图按列布局时，如果视图的宽度不相同，会如何处理？它是“左对齐”它们，还是将它们居中，或者以其他方式排列？这可以通过传递给堆叠视图的参数来指定：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为什么使用 <code>.leading</code> 而不是 <code>.left</code>？<br>因为堆叠视图会自动适应文本从右向左的环境（例如阿拉伯语或希伯来语）。<code>leading</code> 对齐方式会将 <code>VStack</code> 中的内容排列到文本开始的边缘。</p>
</li>
<li><p>文本基线也可以用于对齐（例如 <code>HStack(alignment: .firstTextBaseline) &#123; ... &#125;</code>）。</p>
</li>
<li><p>您甚至可以定义自己的“对齐指南”，来指定自定义的对齐方式。目前只使用内置的对齐方式（<code>.textBaselines</code>、<code>.center </code>、<code>.top </code>、<code>.trailing</code> 等）。</p>
</li>
</ul>
<h3 id="1-2-LazyVStack、LazyHStack、LazyVGrid、LazyHGrid-和-Grid"><a href="#1-2-LazyVStack、LazyHStack、LazyVGrid、LazyHGrid-和-Grid" class="headerlink" title="1.2 LazyVStack、LazyHStack、LazyVGrid、LazyHGrid 和 Grid"></a>1.2 <code>LazyVStack</code>、<code>LazyHStack</code>、<code>LazyVGrid</code>、<code>LazyHGrid</code> 和 <code>Grid</code></h3><h4 id="1-2-1-LazyVStack-和-LazyHStack"><a href="#1-2-1-LazyVStack-和-LazyHStack" class="headerlink" title="1.2.1 LazyVStack 和 LazyHStack"></a>1.2.1 <code>LazyVStack</code> 和 <code>LazyHStack</code></h4><ul>
<li>这些“lazy”的堆叠版本不会创建任何不可见的视图。</li>
<li>即使内部有灵活视图，它们也不会占用所有提供给它们的空间。</li>
<li>在 <code>ScrollView</code> 中时，也可以使用这些堆叠视图。</li>
</ul>
<h4 id="1-2-2-LazyVGrid-和-LazyHGrid"><a href="#1-2-2-LazyVGrid-和-LazyHGrid" class="headerlink" title="1.2.2 LazyVGrid 和 LazyHGrid"></a>1.2.2 <code>LazyVGrid</code> 和 <code>LazyHGrid</code></h4><ul>
<li>我们看到它们是如何布局其视图的。</li>
<li>视图的大小基于提供给 <code>LazyVGrid</code> 或 <code>LazyHGrid</code> 的参数信息（例如，<code>columns</code>）。</li>
<li>另一个方向可以随着更多视图的添加而增长或缩小。</li>
<li>如果不需要，<strong>仍不会占用所有提供给它的空间</strong>。</li>
</ul>
<h4 id="1-2-3-Grid"><a href="#1-2-3-Grid" class="headerlink" title="1.2.3 Grid"></a>1.2.3 <code>Grid</code></h4><ul>
<li>在水平和垂直方向上为它的视图分配空间（注意它的名称中没有<code>H</code>或<code>V</code>）。</li>
<li>在列和行之间有许多对齐选项（例如，使用 <code>grid*()</code> 修饰符）。</li>
<li>通常用作“电子表格视图”或“数据表格视图”。</li>
</ul>
<h3 id="1-3-ScrollView、ViewThatFits、Form-、-List、Custom-Layout"><a href="#1-3-ScrollView、ViewThatFits、Form-、-List、Custom-Layout" class="headerlink" title="1.3 ScrollView、ViewThatFits、Form 、 List、Custom Layout"></a>1.3 <code>ScrollView</code>、<code>ViewThatFits</code>、<code>Form</code> 、 <code>List</code>、<code>Custom Layout</code></h3><h4 id="1-3-1-ScrollView"><a href="#1-3-1-ScrollView" class="headerlink" title="1.3.1 ScrollView"></a>1.3.1 <code>ScrollView</code></h4><ul>
<li><code>ScrollView</code> 占用所有提供给它的空间。</li>
<li>其中的视图会自动调整以适应您正在滚动的方向。</li>
</ul>
<h4 id="1-3-2-ViewThatFits"><a href="#1-3-2-ViewThatFits" class="headerlink" title="1.3.2 ViewThatFits"></a>1.3.2 <code>ViewThatFits</code></h4><ul>
<li>接受一组容器视图（例如 <code>HStack</code> 和 <code>VStack</code>），并选择一个适合的视图。</li>
<li>当为横屏与竖屏布局时，这非常有用。或者当使用动态类型字号布局时（较大的字体可能无法在横向上适应）。</li>
</ul>
<h4 id="1-3-3-Form、List、OutlineGroup-和-DisclosureGroup"><a href="#1-3-3-Form、List、OutlineGroup-和-DisclosureGroup" class="headerlink" title="1.3.3 Form、List、OutlineGroup 和 DisclosureGroup"></a>1.3.3 <code>Form</code>、<code>List</code>、<code>OutlineGroup</code> 和 <code>DisclosureGroup</code></h4><ul>
<li>这些类似于“非常智能的 <code>VStack</code>”（具备滚动、选择、层级等功能）。</li>
<li>将在后面的课程中讨论它们。</li>
</ul>
<h4 id="1-3-4-自定义布局协议实现"><a href="#1-3-4-自定义布局协议实现" class="headerlink" title="1.3.4 自定义布局协议实现"></a>1.3.4 自定义布局协议实现</h4><ul>
<li>您可以自定义一个“提供空间、让视图选择其大小，然后对其进行排列”的过程。</li>
<li>实现一个实现 <code>Layout</code> 协议的视图（<code>sizeThatFits</code>、<code>placeSubviews</code>）。</li>
</ul>
<h3 id="1-4-ZStack"><a href="#1-4-ZStack" class="headerlink" title="1.4 ZStack"></a>1.4 <code>ZStack</code></h3><h4 id="1-4-1-ZStack"><a href="#1-4-1-ZStack" class="headerlink" title="1.4.1 ZStack"></a>1.4.1 <code>ZStack</code></h4><ul>
<li><code>ZStack</code> 自适应调整以适应其子视图。</li>
<li>如果其中任何一个子视图是完全灵活的，则 <code>ZStack</code> 也会是灵活的。</li>
</ul>
<h4 id="1-4-2-background-修饰符"><a href="#1-4-2-background-修饰符" class="headerlink" title="1.4.2 .background 修饰符"></a>1.4.2 <code>.background</code> 修饰符</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;hello&quot;</span>).background(<span class="type">Rectangle</span>().foregroundColor(.red))</span><br></pre></td></tr></table></figure>

<ul>
<li>这类似于将 <code>Text</code> 和 <code>Rectangle</code> 的 <code>ZStack</code> 叠加（<code>Text</code> 在前）。</li>
<li>然而，这与使用 <code>ZStack</code> 叠加它们之间存在很大不同。</li>
<li>在这种情况下，生成的视图会根据 <code>Text</code> 的大小来调整（<code>Rectangle</code> 不参与）。</li>
<li>换句话说，<code>Text</code> 完全决定了这个“两个迷你 <code>ZStack</code>”的布局。</li>
</ul>
<h4 id="1-4-3-overlay-修饰符"><a href="#1-4-3-overlay-修饰符" class="headerlink" title="1.4.3 .overlay 修饰符"></a>1.4.3 <code>.overlay</code> 修饰符</h4><p>与 <code>.background</code> 相同的布局规则，但叠加方向相反。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Circle</span>().overlay(<span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>), alignment: .center)</span><br></pre></td></tr></table></figure>

<ul>
<li>这将根据 <code>Circle</code> 的大小调整（即它将是完全灵活的）。</li>
<li><code>Text</code> 将被叠加在 <code>Circle</code> 上（在 <code>Circle</code> 的指定对齐方式内）。</li>
</ul>
<h3 id="1-5-修饰符"><a href="#1-5-修饰符" class="headerlink" title="1.5 修饰符"></a>1.5 修饰符</h3><h4 id="1-5-1-padding"><a href="#1-5-1-padding" class="headerlink" title="1.5.1 .padding"></a>1.5.1 <code>.padding</code></h4><p>请记住，视图修饰符函数（如 <code>.padding</code>）本身返回一个视图。概念上，这个视图 <code>包裹</code> 着它所修饰的视图。</p>
<p>其中许多仅将提供给它们的大小传递下去（如 <code>.font</code> 或 <code>.foregroundColor</code>）。</p>
<p>但也可能有修饰符参与布局过程。例如，<code>.padding(10)</code> 返回的视图会提供一个与它所修改的视图大小相同，但每一侧减少 10 个点的空间。返回的视图 <code>.padding(10)</code> 的尺寸将比它所修饰的视图选择的尺寸大 10 个点。</p>
<h4 id="1-5-2-aspectRatio"><a href="#1-5-2-aspectRatio" class="headerlink" title="1.5.2 .aspectRatio"></a>1.5.2 <code>.aspectRatio</code></h4><p>另一个例子是我们已经使用过的修饰符：<code>.aspectRatio</code>。</p>
<p>通过 <code>.aspectRatio</code> 修饰符返回的视图会根据其比例选择适合的大小。它可以选择较小的尺寸（<code>.fit</code>），以适应给定的空间，或选择较大的尺寸（<code>.fill</code>），以尽可能使用所有可用空间（甚至超过提供的空间），同时遵循比例。（视图可以选择一个大于其所提供空间的大小！）</p>
<p><code>.aspectRatio</code> 会将选择的空间传递给其修饰的视图，作为其“容器”。</p>
<h3 id="1-6-GeometryReader-动态布局"><a href="#1-6-GeometryReader-动态布局" class="headerlink" title="1.6 GeometryReader 动态布局"></a>1.6 <code>GeometryReader</code> 动态布局</h3><p>大多数视图会自动调整大小，以充分利用所提供的空间。例如，各种形状（如圆角矩形）通常会自我调整以适应容器。而自定义视图，如 CardView，也应该根据提供的空间进行适应，以保持美观性。比如，可以调整卡片内文本的字体大小，使其表情符号能填满空间。</p>
<p>然而，当视图需要根据提供的空间进行动态调整时，例如在选择卡片大小以适配 LazyVGrid 使其不需要滚动时，就需要用到一个名为 GeometryReader 的容器视图来获取所提供的空间大小，从而进行动态的布局调整。</p>
<p>您可以用这个 <code>GeometryReader</code> 视图包裹通常出现在您的视图主体中的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span> <span class="comment">// 使用尾随闭包语法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>geometry</code> 参数是一个 <code>GeometryProxy</code> 对象。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GeometryProxy</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> size: <span class="type">CGSize</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">frame</span>(<span class="params">in</span> <span class="params">coordinateSpace</span>: <span class="type">CoordinateSpace</span>) -&gt; <span class="type">CGRect</span></span><br><span class="line">    <span class="keyword">var</span> safeAreaInsets: <span class="type">EdgeInsets</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size</code> 变量是我们的容器提供给我们的“空间大小”。</li>
<li>现在我们可以选择一个适合这个大小空间的卡片尺寸。</li>
<li><code>GeometryReader</code> 本身（它只是一个视图）始终接受所有提供给它的空间。</li>
</ul>
<h3 id="1-7-safeArea"><a href="#1-7-safeArea" class="headerlink" title="1.7 safeArea"></a>1.7 <code>safeArea</code></h3><p>通常，当视图被提供空间时，这个空间并不包括“安全区域”。最明显的安全区域出现在 iPhone X 及其后续型号的刘海部分，这个区域通常用于保护前置摄像头、传感器和扬声器等组件。因此，应用视图时，内容一般不应该绘制在这些安全区域内。</p>
<p>不过，开发者也可以选择忽略这一限制，在指定的边缘内进行绘制。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">ZStack</span> &#123; <span class="operator">...</span> &#125;.edgesIgnoringSafeArea([.top]) <span class="comment">// 在顶部边缘的“安全区域”中绘制</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Demo：布局"><a href="#2-Demo：布局" class="headerlink" title="2. Demo：布局"></a>2. Demo：布局</h2><h3 id="2-1-LazyVGrid、GridItem"><a href="#2-1-LazyVGrid、GridItem" class="headerlink" title="2.1 LazyVGrid、GridItem"></a>2.1 <code>LazyVGrid</code>、<code>GridItem</code></h3><p>这里使用 <code>GridItem()</code> 来设置 <code>Grid</code> 布局中的每一列，<code>[GridItem()]</code> 显示为一列，<code>[GridItem(),GridItem()]</code> 则显示为两列</p>
<p><img src="/2024/12/31/Stanford-cs193p-06-Layout-ViewBuilder/cs193p%EF%BD%9C06%EF%BD%9CViewBuilder.png"></p>
<p><img src="/2024/12/31/Stanford-cs193p-06-Layout-ViewBuilder/cs193p%EF%BD%9C06%EF%BD%9CViewBuilder-1.png"></p>
<p>其中，<code>GridItem.size</code> 为枚举类型，有 <code>adaptive</code>、<code>fixed</code> 和 <code>flexible</code> 三种 case。</p>
<p><img src="/2024/12/31/Stanford-cs193p-06-Layout-ViewBuilder/cs193p%EF%BD%9C06%EF%BD%9CViewBuilder-5.png"></p>
<p>我们用 <code>adaptive</code> 来自适应调整 GridItem，当调整为合适的宽度时，可以在屏幕中全部呈现，不需要 scrollView。</p>
<p>但将 <code>scrollView</code> 去除后，这个 <code>Vstack</code> 无法容纳所有的 card，将底部的 <code>shuffle</code> 从容器中推了出来。</p>
<p><img src="/2024/12/31/Stanford-cs193p-06-Layout-ViewBuilder/cs193p%EF%BD%9C06%EF%BD%9CViewBuilder-6.png"></p>
<p>那如何调整 <code>GridItem</code> 的大小，让 <code>LazyVGrid</code> 占据所有空间?</p>
<h3 id="2-2-GeometryReader"><a href="#2-2-GeometryReader" class="headerlink" title="2.2 GeometryReader"></a>2.2 <code>GeometryReader</code></h3><p>可以使用 <code>GeometryReader</code> 来动态调整 <code>GridItem</code> 的大小。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">	<span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	        <span class="comment">// creates a vertically scrollable collection of views</span></span><br><span class="line">	        <span class="comment">// lazy implies that the views are only created when SwiftUI needs to display them</span></span><br><span class="line">	        <span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">	            <span class="keyword">let</span> gridItemSize <span class="operator">=</span> gridItemWidthThatFits(count: viewModel.cards.count, size: geometry.size, atAspectRatio: <span class="number">2</span><span class="operator">/</span><span class="number">3</span>)</span><br><span class="line">	            <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: gridItemSize),spacing: <span class="number">0</span>)],spacing: <span class="number">0</span>) &#123;</span><br><span class="line">	                <span class="type">ForEach</span>(viewModel.cards) &#123; card <span class="keyword">in</span></span><br><span class="line">	                    <span class="type">CardView</span>(card: card)</span><br><span class="line">	                        .aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>, contentMode: .fit)</span><br><span class="line">	                        .padding(<span class="number">8</span>)</span><br><span class="line">	                        .onTapGesture &#123;</span><br><span class="line">	                            viewModel.choose(card)</span><br><span class="line">	                        &#125;</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        .foregroundColor(.orange)</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">func</span> <span class="title function_">gridItemWidthThatFits</span> (</span><br><span class="line">	        <span class="params">count</span>:<span class="type">Int</span>,</span><br><span class="line">	        <span class="params">size</span>:<span class="type">CGSize</span>,</span><br><span class="line">	        <span class="params">atAspectRatio</span> <span class="params">aspectRatio</span>:<span class="type">CGFloat</span></span><br><span class="line">	    ) -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">	        <span class="keyword">var</span> columnCount <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">	        <span class="keyword">repeat</span> &#123;</span><br><span class="line">	            <span class="keyword">let</span> width <span class="operator">=</span> size.width <span class="operator">/</span> columnCount</span><br><span class="line">	            <span class="keyword">let</span> height <span class="operator">=</span> width <span class="operator">/</span> aspectRatio</span><br><span class="line"></span><br><span class="line">	            <span class="keyword">let</span> rowCount <span class="operator">=</span> (count <span class="operator">/</span> columnCount).rounded(.up)</span><br><span class="line">	            <span class="keyword">if</span> rowCount <span class="operator">*</span> height <span class="operator">&lt;</span> size.height &#123;</span><br><span class="line">	                <span class="keyword">return</span> (size.width <span class="operator">/</span> columnCount).rounded(.down)</span><br><span class="line">	            &#125;</span><br><span class="line">	            columnCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">	        &#125; <span class="keyword">while</span> columnCount <span class="operator">&lt;</span> count</span><br><span class="line">	        <span class="keyword">return</span> <span class="built_in">min</span>(size.width <span class="operator">/</span> count, size.height <span class="operator">*</span> aspectRatio).rounded(.down)</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述在 <code>gridItemWidthThat</code> 中会报错，因为返回类型为 <code>CGFloat</code>, <code>columnCount</code> 和 <code>count</code> 都为 <code>Int</code> 类型，无法进行运算，需要做类型转化。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>:<span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">gridItemWidthThatFits</span> (</span><br><span class="line">	           <span class="params">count</span>:<span class="type">Int</span>,</span><br><span class="line">	           <span class="params">size</span>:<span class="type">CGSize</span>,</span><br><span class="line">	           <span class="params">atAspectRatio</span> <span class="params">aspectRatio</span>:<span class="type">CGFloat</span></span><br><span class="line">	       ) -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">	           <span class="keyword">let</span> count <span class="operator">=</span> <span class="type">CGFloat</span>(count)</span><br><span class="line">	           <span class="keyword">var</span> columnCount <span class="operator">=</span> <span class="number">1.0</span></span><br><span class="line">	           <span class="operator">...</span></span><br><span class="line">	       &#125;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时视图会随着卡片对数的变化而变化，且始终保持在 Vstack 容器内。</p>
<h3 id="2-3-ViewBuilder"><a href="#2-3-ViewBuilder" class="headerlink" title="2.3 ViewBuilder"></a>2.3 <code>ViewBuilder</code></h3><p>我们将 aspectRatio 提取为变量，替换相应代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>:<span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">	 <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	    <span class="keyword">let</span> aspectRatio : <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">/</span><span class="number">3</span></span><br><span class="line">		<span class="comment">// creates a vertically scrollable collection of views</span></span><br><span class="line">		<span class="comment">// lazy implies that the views are only created when SwiftUI needs to display them</span></span><br><span class="line">		<span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">			<span class="keyword">let</span> gridItemSize <span class="operator">=</span> gridItemWidthThatFits(count: viewModel.cards.count, size: geometry.size, atAspectRatio: aspectRatio)</span><br><span class="line">			<span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: gridItemSize),spacing: <span class="number">0</span>)],spacing: <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="type">ForEach</span>(viewModel.cards) &#123; card <span class="keyword">in</span></span><br><span class="line">					<span class="type">CardView</span>(card: card)</span><br><span class="line">						.aspectRatio(aspectRatio, contentMode: .fit)</span><br><span class="line">						.padding(<span class="number">8</span>)</span><br><span class="line">						.onTapGesture &#123;</span><br><span class="line">							viewModel.choose(card)</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		.foregroundColor(.orange)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会报错 <code>Function declares an opaque return type, but has no return statements in its body from which to infer an underlying type</code> ，因为需要返回一个 View。可以在 <code>GeometryReader</code> 前加上 <code>return</code> 或者使用 <code>@ViewBuilder</code> 都可以处理该问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>:<span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">	<span class="meta">@ViewBuilder</span></span><br><span class="line">	 <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	    <span class="keyword">let</span> aspectRatio : <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">/</span><span class="number">3</span></span><br><span class="line">		<span class="comment">// creates a vertically scrollable collection of views</span></span><br><span class="line">		<span class="comment">// lazy implies that the views are only created when SwiftUI needs to display them</span></span><br><span class="line">		<span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">			<span class="operator">...</span></span><br><span class="line">		&#125;</span><br><span class="line">		.foregroundColor(.orange)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这里可以将 <code>aspectRatio</code> 提取出来作为私有变量是一种更简洁易读的办法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>:<span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">let</span> aspectRatio : <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">/</span><span class="number">3</span></span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">		<span class="comment">// creates a vertically scrollable collection of views</span></span><br><span class="line">		<span class="comment">// lazy implies that the views are only created when SwiftUI needs to display them</span></span><br><span class="line">		<span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">			<span class="operator">...</span></span><br><span class="line">		&#125;</span><br><span class="line">		.foregroundColor(.orange)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们会将所有变量设为 <code>private</code> 的，除非它需要共享，或者是协议本身有定义的例如 <code>body</code>。</p>
</blockquote>
<h2 id="3-ViewBuilder"><a href="#3-ViewBuilder" class="headerlink" title="3. @ViewBuilder"></a>3. <code>@ViewBuilder</code></h2><p>基于 Swift 中的一种机制，增强了变量的功能，使其具备特殊的作用。这个机制为视图列表提供了更便捷的语法支持，开发者可以将其应用于任何返回符合 View 协议的函数。</p>
<p>当使用这个机制时，函数仍然返回符合 View 的内容，但它会将这些内容视作一个视图列表，然后将它们合并成一个视图。</p>
<p>合并后的视图可以是多个视图组成的 TupleView，也可以是包含条件判断的 <code>_ConditionalContent</code> 视图，甚至在列表为空的情况下会变成 EmptyView，虽然这可能看起来有些奇怪，但这是被允许的。此外，这些组合可以是更复杂的，例如在条件内部再嵌套条件等。</p>
<p>需要注意的是，某些功能（比如 <code>_ConditionalContent</code>）目前尚未完全公开为 API。然而，对我们来说，我们并不关心合并后生成的具体视图，只要它始终返回某种视图就可以了。</p>
<p>任何函数或只读计算属性都可以标记为 <code>@ViewBuilder</code>。一旦标记，该函数或属性的内容将被解释为视图列表。例如，如果我们想将用于构建卡片前面部分的视图提取出来</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">front</span>(<span class="params">of</span> <span class="params">card</span>: <span class="type">Card</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> shape <span class="operator">=</span> <span class="type">RoundedRectangle</span> (cornerRadius: <span class="number">20</span>)</span><br><span class="line">	shape.fill(.white)</span><br><span class="line">	shape.stroke()</span><br><span class="line">	<span class="type">Text</span> (card.content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码并不是一个合法的函数语法，而仅仅是一个视图列表。我们不能像这样列出视图 Views。</p>
<p>但是如果我们把 <code>@ViewBuilder</code> 放在前面是可以的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ViewBuilder</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">front</span>(<span class="params">of</span> <span class="params">card</span>: <span class="type">Card</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> shape <span class="operator">=</span> <span class="type">RoundedRectangle</span> (cornerRadius: <span class="number">20</span>)</span><br><span class="line">	shape.fill(.white)</span><br><span class="line">	shape.stroke()</span><br><span class="line">	<span class="type">Text</span> (card.content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以合法地使用简单的 if-else 语句来控制列表中包含哪些视图。（不过，这只是我们卡片的前面部分，所以不需要使用任何条件判断。）</p>
<p>上述代码将返回一个 <code>TupleView&lt;RoundedRectangle, RoundedRectangle, Text&gt;</code>。</p>
<p>你还可以使用 <code>@ViewBuilder</code> 来标记函数或初始化方法的参数。该参数的类型必须是“返回 View 的函数”。例如，<code>ZStack</code>、<code>HStack</code>、<code>VStack</code>、<code>ForEach</code>、<code>LazyGrid</code> 等都采用这种方式（它们的 <code>content:</code> 参数）。我们将在后面的演示中展示这一点。</p>
<p>需要注意的是， <code>@ViewBuilder</code> 的内容只是一个视图列表，并不是任意代码。可以使用 if-else（或 switch、if let）语句来选择要包含在列表中的视图。你也可以使用局部的 let 语句。其他类型的代码是不允许的（至少在本次讲座时是这样的）。</p>
<h2 id="4-Demo：创建“合并视图”"><a href="#4-Demo：创建“合并视图”" class="headerlink" title="4. Demo：创建“合并视图”"></a>4. Demo：创建“合并视图”</h2><p>为了更好地理解像 HStack 或 LazyVGrid 这样的组件如何接收参数，接下来将通过创建一个“合并视图” <code>AspectVGrid</code> 来实现这一点。它类似于 LazyVGrid，但不同的是会根据提供给它的空间调整其内容视图的大小。</p>
<p>首先创建一个新的 SwiftUI 文档，并命名为 <code>AspectVGrid.swift</code>。</p>
<p>我们将 <code>EmojiMemoryGameView</code> 中的 <code>GeometryReader </code> 和 <code>gridItemWidthThatFits</code> 移至 <code>AspectVGrid.swift</code>, 将 viewModel.cards 修改为 <code>[Item]</code> 类型变量，其中 <code>Item</code> 为 <code>generic type </code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>:<span class="title class_ inherited__">View</span>&#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">	<span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">		<span class="type">AspectVGrid</span>(viewModel.cards,aspectRatio:aspectRatio) &#123; card <span class="keyword">in</span></span><br><span class="line">			<span class="type">CardView</span>(card: card)</span><br><span class="line">				.aspectRatio(aspectRatio, contentMode: .fit)</span><br><span class="line">				.padding(<span class="number">8</span>)</span><br><span class="line">				.onTapGesture &#123;</span><br><span class="line">					viewModel.choose(card)</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		.foregroundColor(.orange)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AspectVGrid.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AspectVGrid</span>&lt;<span class="type">Item</span>:<span class="type">Identifiable</span>&gt;:<span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> items:[<span class="type">Item</span>]</span><br><span class="line">    <span class="keyword">var</span> aspectRatio:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body:<span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> gridItemSize <span class="operator">=</span> gridItemWidthThatFits(count: items.count, size: geometry.size, atAspectRatio: aspectRatio)</span><br><span class="line">            <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: gridItemSize),spacing: <span class="number">0</span>)],spacing: <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">ForEach</span>(items) &#123;item <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">gridItemWidthThatFits</span> (</span><br><span class="line">        <span class="params">count</span>:<span class="type">Int</span>,</span><br><span class="line">        <span class="params">size</span>:<span class="type">CGSize</span>,</span><br><span class="line">        <span class="params">atAspectRatio</span> <span class="params">aspectRatio</span>:<span class="type">CGFloat</span></span><br><span class="line">    ) -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> count <span class="operator">=</span> <span class="type">CGFloat</span>(count)</span><br><span class="line">        <span class="keyword">var</span> columnCount <span class="operator">=</span> <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> width <span class="operator">=</span> size.width <span class="operator">/</span> columnCount</span><br><span class="line">            <span class="keyword">let</span> height <span class="operator">=</span> width <span class="operator">/</span> aspectRatio</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> rowCount <span class="operator">=</span> (count <span class="operator">/</span> columnCount).rounded(.up)</span><br><span class="line">            <span class="keyword">if</span> rowCount <span class="operator">*</span> height <span class="operator">&lt;</span> size.height &#123;</span><br><span class="line">                <span class="keyword">return</span> (size.width <span class="operator">/</span> columnCount).rounded(.down)</span><br><span class="line">            &#125;</span><br><span class="line">            columnCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">while</span> columnCount <span class="operator">&lt;</span> count</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(size.width <span class="operator">/</span> count, size.height <span class="operator">*</span> aspectRatio).rounded(.down)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码会报错：<code>Failed to produce diagnostic for expression; please submit a bug report</code>。这表面 <code>view Builder</code> 存在问题。因为此处的 <code>aspectRatio</code> 没有定义。而 <code>ForEach</code> 要求 <code>Item</code> 为 <code>Identifiable</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AspectVGrid.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AspectVGrid</span>&lt;<span class="type">Item</span>:<span class="type">Identifiable</span>&gt;: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> items:[<span class="type">Item</span>]</span><br><span class="line">    <span class="keyword">var</span> aspectRatio:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"> 	<span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再回到 <code>EmojiMemoryGameView.swift</code>，我们需要将 <code>&#123;card in ...&#125;</code> 这个尾随闭包传递给 <code>AspectVGrid</code>，在 <code>AspectVGrid</code> 中定义一个返回值为符合 View 协议的视图的函数类型参数 <code>content</code>，在 <code>ForEach</code> 中补充相应 View。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AspectVGrid.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AspectVGrid</span>&lt;<span class="type">Item</span>:<span class="type">Identifiable</span>, <span class="type">ItemView</span>:<span class="type">View</span>&gt;: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> items:[<span class="type">Item</span>]</span><br><span class="line">    <span class="keyword">var</span> aspectRatio:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> content:(<span class="type">View</span>) -&gt; (<span class="type">ItemView</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> body:<span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	        <span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">	            <span class="keyword">let</span> gridItemSize <span class="operator">=</span> gridItemWidthThatFits(count: items.count, size: geometry.size, atAspectRatio: aspectRatio)</span><br><span class="line">	            <span class="type">LazyVGrid</span>(columns: [<span class="type">GridItem</span>(.adaptive(minimum: gridItemSize),spacing: <span class="number">0</span>)],spacing: <span class="number">0</span>) &#123;</span><br><span class="line">	                <span class="type">ForEach</span>(items) &#123;item <span class="keyword">in</span></span><br><span class="line">	                	content(item)</span><br><span class="line">	                		.aspectRatio(aspectRatio, contentMode:.fit)</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>:<span class="title class_ inherited__">View</span>&#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">	<span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">		<span class="type">AspectVGrid</span>(items: viewModel.cards,aspectRatio:aspectRatio) &#123; card <span class="keyword">in</span></span><br><span class="line">			<span class="type">CardView</span>(card: card)</span><br><span class="line">				.aspectRatio(aspectRatio, contentMode: .fit)</span><br><span class="line">				.padding(<span class="number">8</span>)</span><br><span class="line">				.onTapGesture &#123;</span><br><span class="line">					viewModel.choose(card)</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		.foregroundColor(.orange)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford cs193p 07｜Shape ViewModifier Constants</title>
    <url>/2025/01/05/Stanford-cs193p-07%EF%BD%9CShape-ViewModifier-Constants/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 07 集的相关笔记。</p>
<span id="more"></span>

<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>cs193p 课程网址: <a href="https://cs193p.sites.stanford.edu/2023">https://cs193p.sites.stanford.edu/2023</a>–</p>
<h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. <strong>引言</strong></h2><p>本节概述了与 SwiftUI 和 Swift 编程相关的关键概念和主题。讨论的主题包括：</p>
<p><strong>代码演示插曲</strong></p>
<ul>
<li>将视图分离到各自的文件中。</li>
<li>理解 Swift 中的常量。</li>
</ul>
<p><strong>形状(Shape)</strong></p>
<ul>
<li>绘制自定义形状。</li>
<li>Demo：在卡片中绘制一个“饼状”的倒计时（未添加动画）。</li>
</ul>
<p><strong>动画(Animation)</strong></p>
<ul>
<li>如何工作的</li>
</ul>
<p><strong>视图调整器(ViewModifier)</strong></p>
<ul>
<li>视图调整器的工作机制</li>
</ul>
<h2 id="2-演示插曲"><a href="#2-演示插曲" class="headerlink" title="2. 演示插曲"></a>2. <strong>演示插曲</strong></h2><h3 id="2-1-分离视图"><a href="#2-1-分离视图" class="headerlink" title="2.1 分离视图"></a>2.1 分离视图</h3><p>新建一个 <code>swiftUI</code> 文件，命名为 <code>CardView</code>。我们将 <code>EmojiMemoryGameView</code> 中的 <code>CardView</code> 视图分离出来放在单独的 <code>CardView.swift</code> 文件中，以实现模块化。为了便于检查代码，设置卡片的预览视图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CardView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> card: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">card</span>:<span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.card <span class="operator">=</span> card</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">                base.fill(.white)</span><br><span class="line">                base.strokeBorder(lineWidth: <span class="number">2</span>)</span><br><span class="line">                <span class="type">Text</span>(card.content)</span><br><span class="line">                    .font(.system(size: <span class="number">200</span>))</span><br><span class="line">                    .minimumScaleFactor(<span class="number">0.01</span>)</span><br><span class="line">                    .aspectRatio(<span class="number">1</span>, contentMode: .fit)</span><br><span class="line">            &#125;</span><br><span class="line">            .opacity(card.isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            base.fill().opacity(card.isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        .opacity(card.isFaceUp <span class="operator">||</span> <span class="operator">!</span>card.isMatched <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView_Previews</span>:<span class="title class_ inherited__">PreviewProvider</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span>&#123;</span><br><span class="line">     <span class="type">CardView</span>(<span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>(content: <span class="string">&quot;X&quot;</span>, id: <span class="string">&quot;test1&quot;</span>))</span><br><span class="line">        .padding()</span><br><span class="line">        .foregroundColor(.green)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-typealias"><a href="#2-1-1-typealias" class="headerlink" title="2.1.1 typealias"></a>2.1.1 typealias</h4><p>需要经常输入 <code>MemoryGame&lt;String&gt;.Card</code> 实在很麻烦，可以使用类型别名 <code>typealias</code> 来简化代码。我们首先在预览中设置类型别名。</p>
<blockquote>
<p><code>typealias</code> 为现有类型提供一个新的别名，使代码更简洁易读。当你需要使用复杂的类型（如嵌套类型或具有多个类型的 tuple）时，使用 <code>typealias</code> 可以让代码更清晰。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CardView.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> card: <span class="type">Card</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">card</span>:<span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.card <span class="operator">=</span> card</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView_Previews</span>:<span class="title class_ inherited__">PreviewProvider</span> &#123;</span><br><span class="line">	<span class="keyword">typealias</span> <span class="type">Card</span> <span class="operator">=</span> <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span>&#123;</span><br><span class="line">    	<span class="type">CardView</span>(<span class="type">Card</span>(content: <span class="string">&quot;X&quot;</span>, id: <span class="string">&quot;test1&quot;</span>))</span><br><span class="line">    	    .padding()</span><br><span class="line">    	    .foregroundColor(.green)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是由于使用类型别名的命名空间不同，在 <code>struct CardView</code> 中无法将 <code>MemoryGame&lt;String&gt;.Card</code> 替换为 <code>Card</code>，需要在 <code>CardView</code> 结构体中再次使用类型别名 <code>typealias</code> 来简化代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CardView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Card</span> <span class="operator">=</span> <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> card: <span class="type">Card</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">card</span>:<span class="type">Card</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.card <span class="operator">=</span> card</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>另外，对 <code>EmojiMemoryGame</code> 的 <code>MemoryGame&lt;String&gt;.Card</code> 做同样的处理。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGame.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span>:<span class="title class_ inherited__">ObservableObject</span>&#123;</span><br><span class="line">	<span class="keyword">typealias</span> <span class="type">Card</span> <span class="operator">=</span> <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span></span><br><span class="line"></span><br><span class="line">	<span class="operator">...</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cards: <span class="type">Array</span>&lt;<span class="type">Card</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> model.cards</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>:<span class="type">Card</span>)&#123;</span><br><span class="line">        model.choose(card)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于我们在 <code>CardView</code> 结构体中已经定义了类型别名，我们可以将预览中的类型别名赋值为 <code>CardView.Card</code>，还可以创建多个 CardView 视图来提供预览效果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CardView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView_Previews</span>: <span class="title class_ inherited__">PreviewProvider</span> &#123;</span><br><span class="line">       <span class="keyword">typealias</span> <span class="type">Card</span> <span class="operator">=</span> <span class="type">CardView</span>.<span class="type">Card</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">           <span class="type">VStack</span> &#123;</span><br><span class="line">               <span class="type">HStack</span> &#123;</span><br><span class="line">                   <span class="type">CardView</span>(<span class="type">Card</span>(isFaceUp: <span class="literal">true</span>, content: <span class="string">&quot;X&quot;</span>, id: <span class="string">&quot;test1&quot;</span>))</span><br><span class="line">                   <span class="type">CardView</span>(<span class="type">Card</span>(content: <span class="string">&quot;X&quot;</span>, id: <span class="string">&quot;test1&quot;</span>))</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="type">HStack</span> &#123;</span><br><span class="line">                   <span class="type">CardView</span>(<span class="type">Card</span>(isFaceUp: <span class="literal">true</span>, isMatched: <span class="literal">true</span>, content: <span class="string">&quot;long long long string and i hope it fits&quot;</span>,id: <span class="string">&quot;test1&quot;</span>))</span><br><span class="line">                   <span class="type">CardView</span>(<span class="type">Card</span>(content: <span class="string">&quot;X&quot;</span>, id: <span class="string">&quot;test1&quot;</span>))</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           .padding()</span><br><span class="line">           .foregroundColor(.green)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>预览效果如下：</p>
<!-- 使图片居中显示 -->
<div style="text-align:center">
    <img src="/2025/01/05/Stanford-cs193p-07%EF%BD%9CShape-ViewModifier-Constants/cs193p|07|1.png">
</div>

<p>我们发现在有多行文本时，视图文本会靠左对齐，对 <code>CardView</code> 视图进行调整使其在多行文本时居中显示。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CardView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">        	<span class="operator">...</span></span><br><span class="line">            <span class="type">Group</span> &#123;</span><br><span class="line">            	<span class="operator">...</span></span><br><span class="line">                <span class="type">Text</span>(card.content)</span><br><span class="line">                    .font(.system(size: <span class="number">200</span>))</span><br><span class="line">                    .minimumScaleFactor(<span class="number">0.01</span>)</span><br><span class="line">                    .multilineTextAlignment(.center)</span><br><span class="line">                    .aspectRatio(<span class="number">1</span>, contentMode: .fit)</span><br><span class="line">                    .padding()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-处理常量"><a href="#2-2-处理常量" class="headerlink" title="2.2 处理常量"></a>2.2 处理常量</h3><p>为了更方便对视图的布局进行统一调整，我们使用私有结构体来为这些视图调整器的常量创建命名空间，并声明类型。这样可以使得代码结构更清晰。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CardView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>:<span class="title class_ inherited__">View</span>&#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">	<span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	        <span class="type">ZStack</span> &#123;</span><br><span class="line">	            <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="type">Constants</span>.cornerRadius)</span><br><span class="line">	            <span class="type">Group</span> &#123;</span><br><span class="line">	                base.fill(.white)</span><br><span class="line">	                base.strokeBorder(lineWidth: <span class="type">Constants</span>.lineWidth)</span><br><span class="line">	                <span class="type">Text</span>(card.content)</span><br><span class="line">	                    .font(.system(size: <span class="type">Constants</span>.<span class="type">FontSize</span>.largest))</span><br><span class="line">	                    .minimumScaleFactor(<span class="type">Constants</span>.<span class="type">FontSize</span>.scaleFactor)</span><br><span class="line">	                    .multilineTextAlignment(.center)</span><br><span class="line">	                    .aspectRatio(<span class="number">1</span>, contentMode: .fit)</span><br><span class="line">	                    .padding(<span class="type">Constants</span>.in<span class="keyword">set</span>)</span><br><span class="line">	            &#125;</span><br><span class="line">	            .opacity(card.isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">	            base.fill().opacity(card.isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">	        &#125;</span><br><span class="line">	        .opacity(card.isFaceUp <span class="operator">||</span> <span class="operator">!</span>card.isMatched <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">struct</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">let</span> cornerRadius:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">let</span> lineWidth:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">let</span> inset:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">FontSize</span> &#123;</span><br><span class="line">			<span class="keyword">static</span> <span class="keyword">let</span> largest:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">200</span></span><br><span class="line">			<span class="keyword">static</span> <span class="keyword">let</span> smallest:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">			<span class="keyword">static</span> <span class="keyword">let</span> scaleFactor <span class="operator">=</span> smallest <span class="operator">/</span> largest</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但我们会注意到，还会有一些常量 <code>1</code> 、<code>0</code> 或者颜色常量没有添加到结构体中，因为通常不具有特别的意义，当然根据情况也可以添加到私其中。</p>
<p>另外，还有一些特别的颜色，比如卡片游戏中的颜色背景，没有添加。因为我们希望将其置于视图层级来调整它们，它属于游戏配置。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGameView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>&#123;</span><br><span class="line">            cards</span><br><span class="line">                .foregroundColor(viewModel.color)</span><br><span class="line">                .animation(.default, value: viewModel.cards)</span><br><span class="line">                .padding()</span><br><span class="line">		<span class="operator">...</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">AspectVGrid</span>(items:viewModel.cards,aspectRatio:aspectRatio) &#123; card <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(card)</span><br><span class="line">                .aspectRatio(aspectRatio, contentMode: .fit)</span><br><span class="line">                .padding(<span class="number">8</span>)</span><br><span class="line">                .onTapGesture &#123;</span><br><span class="line">                    viewModel.choose(card)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmojiMemoryGame.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span>:<span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> color:<span class="type">Color</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .orange</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-图形（Shape）"><a href="#2-图形（Shape）" class="headerlink" title="2. 图形（Shape）"></a><strong>2. 图形（Shape）</strong></h2><p><code>Shape</code> 是一种继承自 <code>View</code> 的协议（protocol），也就是说，所有的 <code>shape</code> 都是 <code>View</code>，比如 <code>RoundedRectangle</code> 、<code>Circle</code>、<code>Capsule</code> 等。</p>
<h3 id="2-1-绘制自定义图形"><a href="#2-1-绘制自定义图形" class="headerlink" title="2.1 绘制自定义图形"></a><strong>2.1 绘制自定义图形</strong></h3><p>自定义图形的实现基于 SwiftUI 的 <code>Shape</code> 协议：</p>
<h4 id="2-1-1-Shape-协议的默认行为："><a href="#2-1-1-Shape-协议的默认行为：" class="headerlink" title="2.1.1 Shape 协议的默认行为："></a>2.1.1 <strong><code>Shape</code> 协议的默认行为：</strong></h4><p>图形通过当前的前景色（<code>foregroundColor</code>）进行填充。也可以使用 <code>.fill()</code> 和 <code>.stroke()</code> 方法自定义绘制方式。</p>
<p>这些修饰符返回一个以指定方式（通过描边或填充）绘制形状的视图。在我们的演示中，<code>fill</code> 的参数看起来是一个颜色（例如，<code>Color.white</code>）。但情况并非完全如此…</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">fill</span>&lt;<span class="type">S</span>&gt;(<span class="keyword">_</span> <span class="params">whatToFillWith</span>: <span class="type">S</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> <span class="keyword">where</span> <span class="type">S</span>: <span class="type">ShapeStyle</span></span><br></pre></td></tr></table></figure>

<p>这是一个泛型函数（类似于但不同于泛型类型）。<code>S</code> 是一个不关心的类型（但由于有 <code>where</code> 语句，它变成了“稍微关心一下”）。<code>S</code> 可以是任何实现了 <code>ShapeStyle</code> 协议的类型。<code>ShapeStyle</code> 协议通过对形状应用某些样式<strong>将形状转换为视图</strong>。这样的例子包括：<code>Color</code>、<code>ImagePaint</code>、<code>AngularGradient</code>、<code>LinearGradient</code>。</p>
<h4 id="2-1-2-实现-Shape-协议的方法："><a href="#2-1-2-实现-Shape-协议的方法：" class="headerlink" title="2.1.2 实现 Shape 协议的方法："></a>2.1.2 <strong>实现 <code>Shape</code> 协议的方法：</strong></h4><p>但是要怎么实现自定义 <code>Shape</code> 呢？</p>
<p>实现 <code>shape</code> 协议必须实现以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">path</span>(<span class="params">in</span> <span class="params">rect</span>: <span class="type">CGRect</span>) -&gt; <span class="type">Path</span></span><br></pre></td></tr></table></figure>

<p>该方法返回一个 <code>Path</code>，用于定义图形的路径。</p>
<p><strong>Path 的能力：</strong></p>
<ul>
<li>支持添加线条、弧线、贝塞尔曲线等。</li>
<li>可以通过组合这些路径创建任意形状。</li>
</ul>
<h3 id="2-2-Demo-示例：绘制一个未动画化的“倒计时饼图”"><a href="#2-2-Demo-示例：绘制一个未动画化的“倒计时饼图”" class="headerlink" title="2.2 Demo 示例：绘制一个未动画化的“倒计时饼图”"></a>2.2 Demo 示例：绘制一个未动画化的“倒计时饼图”</h3><p>为了更清晰的观察饼图的样式:</p>
<ul>
<li>我们先将卡片数量设置为 4 张（EmojiMemoryGame.swift）</li>
<li>使卡片默认朝上(MemoryGame.swift)</li>
<li>在 Card 中添加一个 <code>Circle</code> 并调整 <code>padding</code> 和 <code>opacity</code>，将 <code>Text</code> 放置在 <code>circle</code> 的 <code>overlay</code> 中，由于 <code>padding</code> 和 <code>opacity</code> 的值为常数，我们将其添加到下面的常量中（CardView.swift）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EMojiMemoryGame.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiMemoryGame</span>:<span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">createMemoryGame</span>() -&gt; <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MemoryGame</span>(numberOfPairsOfCards: <span class="number">2</span>) &#123; <span class="type">Index</span> <span class="keyword">in</span></span><br><span class="line">        	<span class="operator">...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="operator">...</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MemoryGame.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; <span class="keyword">where</span> <span class="type">CardContent</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Card</span>: <span class="title class_ inherited__">Equatable</span>,<span class="title class_ inherited__">Identifiable</span>,<span class="title class_ inherited__">CustomDebugStringConvertible</span>  &#123;</span><br><span class="line">		<span class="operator">...</span></span><br><span class="line">        <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">		<span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  CardView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">		 <span class="type">ZStack</span> &#123;</span><br><span class="line">			 <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="type">Constants</span>.cornerRadius)</span><br><span class="line">			 <span class="type">Group</span> &#123;</span><br><span class="line">				 base.fill(.white)</span><br><span class="line">				 base.strokeBorder(lineWidth: <span class="type">Constants</span>.lineWidth)</span><br><span class="line">				 <span class="type">Circle</span>()</span><br><span class="line">					 .opacity(<span class="type">Constants</span>.<span class="type">Pie</span>.opacity)</span><br><span class="line">					 .overlay(</span><br><span class="line">						 <span class="type">Text</span>(card.content)</span><br><span class="line">							 .font(.system(size: <span class="type">Constants</span>.<span class="type">FontSize</span>.largest))</span><br><span class="line">							 .minimumScaleFactor(<span class="type">Constants</span>.<span class="type">FontSize</span>.scaleFactor)</span><br><span class="line">							 .multilineTextAlignment(.center)</span><br><span class="line">							 .aspectRatio(<span class="number">1</span>, contentMode: .fit)</span><br><span class="line">							 .padding(<span class="type">Constants</span>.<span class="type">Pie</span>.in<span class="keyword">set</span>)</span><br><span class="line">					 )</span><br><span class="line">					 .padding(<span class="type">Constants</span>.in<span class="keyword">set</span>)</span><br><span class="line"></span><br><span class="line">			 &#125;</span><br><span class="line">			 .opacity(card.isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">			 base.fill().opacity(card.isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">		 &#125;</span><br><span class="line">		 .opacity(card.isFaceUp <span class="operator">||</span> <span class="operator">!</span>card.isMatched <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">struct</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">	   <span class="keyword">static</span> <span class="keyword">let</span> cornerRadius:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">	   <span class="keyword">static</span> <span class="keyword">let</span> lineWidth:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">	   <span class="keyword">static</span> <span class="keyword">let</span> inset:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">	   <span class="keyword">struct</span> <span class="title class_">FontSize</span> &#123;</span><br><span class="line">		   <span class="keyword">static</span> <span class="keyword">let</span> largest:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">200</span></span><br><span class="line">		   <span class="keyword">static</span> <span class="keyword">let</span> smallest:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">		   <span class="keyword">static</span> <span class="keyword">let</span> scaleFactor <span class="operator">=</span> smallest <span class="operator">/</span> largest</span><br><span class="line">	   &#125;</span><br><span class="line"></span><br><span class="line">	   <span class="keyword">struct</span> <span class="title class_">Pie</span> &#123;</span><br><span class="line">		   <span class="keyword">static</span> <span class="keyword">let</span> opacity:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0.5</span></span><br><span class="line">		   <span class="keyword">static</span> <span class="keyword">let</span> inset:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">	   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-创建一个-Pie（shape）"><a href="#2-2-1-创建一个-Pie（shape）" class="headerlink" title="2.2.1 创建一个 Pie（shape）"></a>2.2.1 创建一个 Pie（shape）</h4><p>虽然 <code>Pie</code> 是一个 <code>View</code>，但它是一个 <code>Shape</code>，所以我们创建一个 <code>swift</code> 文档，而非 <code>swiftUI</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Pie.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> CoreGraphics</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pie</span>: <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> startAngle: <span class="type">Angle</span> <span class="operator">=</span> .zero</span><br><span class="line">    <span class="keyword">let</span> endAngle: <span class="type">Angle</span></span><br><span class="line">    <span class="comment">// 顺时针</span></span><br><span class="line">    <span class="keyword">var</span> clockwise <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shape协议 方法</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">path</span>(<span class="params">in</span> <span class="params">rect</span>: <span class="type">CGRect</span>) -&gt; <span class="type">Path</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> center <span class="operator">=</span> <span class="type">CGPoint</span>(x: rect.midX, y: rect.midY)</span><br><span class="line">        <span class="keyword">let</span> radius <span class="operator">=</span> <span class="built_in">min</span>(rect.width, rect.height) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> start <span class="operator">=</span> <span class="type">CGPoint</span>(</span><br><span class="line">            x: center.x <span class="operator">+</span> radius <span class="operator">*</span> cos(startAngle.radians),</span><br><span class="line">            y: center.y <span class="operator">+</span> radius <span class="operator">*</span> sin(startAngle.radians)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> p <span class="operator">=</span> <span class="type">Path</span>()</span><br><span class="line">        p.move(to: center)</span><br><span class="line">        p.addLine(to: start)</span><br><span class="line">        p.addArc(</span><br><span class="line">            center: center,</span><br><span class="line">            radius: radius,</span><br><span class="line">            startAngle: startAngle,</span><br><span class="line">            endAngle: endAngle,</span><br><span class="line">            clockwise: clockwise</span><br><span class="line">        )</span><br><span class="line">        p.addLine(to: center)</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再将 <code>CardView.swift</code> 中的 <code>circle()</code> 改为 <code>Pie()</code>。</p>
<p>我们试图创建一个从 12 点钟方向到 8 点钟方向的顺时针饼图，但这似乎不太对劲：</p>
<p><img src="/2025/01/05/Stanford-cs193p-07%EF%BD%9CShape-ViewModifier-Constants/cs193p%7C07%7C2.png"></p>
<p>因为这的 0 度和时钟不同，它遵循直角坐标系，是 x 轴正向。</p>
<p>另外，此处的坐标系原点是在左上角，y 轴正向是向下的，所以顺时针方向也和通常的情况相反。接下来进行修正。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Pie.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pie</span>: <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">path</span>(<span class="params">in</span> <span class="params">rect</span>: <span class="type">CGRect</span>) -&gt; <span class="type">Path</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> startAngle <span class="operator">=</span> startAngle <span class="operator">-</span> .degrees(<span class="number">90</span>)</span><br><span class="line">        <span class="keyword">let</span> endAngle <span class="operator">=</span> endAngle <span class="operator">-</span> .degrees(<span class="number">90</span>)</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">        p.addArc(</span><br><span class="line">            center: center,</span><br><span class="line">            radius: radius,</span><br><span class="line">            startAngle: startAngle,</span><br><span class="line">            endAngle: endAngle,</span><br><span class="line">            clockwise: <span class="operator">!</span>clockwise</span><br><span class="line">        )</span><br><span class="line">		<span class="operator">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修正后预览效果如下：</p>
<p><img src="/2025/01/05/Stanford-cs193p-07%EF%BD%9CShape-ViewModifier-Constants/cs193p%7C07%7C3.png"></p>
<h2 id="3-动画（Animation）"><a href="#3-动画（Animation）" class="headerlink" title="3. 动画（Animation）"></a><strong>3. 动画（Animation）</strong></h2><h3 id="3-1-动画的工作原理"><a href="#3-1-动画的工作原理" class="headerlink" title="3.1 动画的工作原理"></a><strong>3.1 动画的工作原理</strong></h3><p>动画是提升移动端用户界面交互体验的重要组成部分。</p>
<p>SwiftUI 提供了便捷的动画工具：</p>
<ul>
<li>通过 Shape 动画化图形。</li>
<li>使用 ViewModifiers 动画化视图。</li>
</ul>
<h3 id="3-2-示例：动画化-Shape"><a href="#3-2-示例：动画化-Shape" class="headerlink" title="3.2 示例：动画化 Shape"></a><strong>3.2 示例：动画化 Shape</strong></h3><p>动画化一个 <code>Shape</code>（例如移动的饼图）：</p>
<ul>
<li>可以通过在 <code>Shape</code> 的属性上添加动画支持。</li>
<li>示例将在下一节演示中补充。</li>
</ul>
<hr>
<h2 id="4-视图修饰符（ViewModifier）"><a href="#4-视图修饰符（ViewModifier）" class="headerlink" title="4. 视图修饰符（ViewModifier）"></a><strong>4. 视图修饰符（ViewModifier）</strong></h2><h3 id="4-1-什么是-ViewModifier？"><a href="#4-1-什么是-ViewModifier？" class="headerlink" title="4.1 什么是 ViewModifier？"></a><strong>4.1 什么是 ViewModifier？</strong></h3><p>SwiftUI 中的修饰符（如 <code>foregroundColor</code>、<code>font</code>、<code>padding</code>）是如何工作的？</p>
<p>它们是 <code>ViewModifier</code> 协议的实现。示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.aspectRatio(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>)</span><br><span class="line"><span class="comment">// 实际上等价于：</span></span><br><span class="line">.modifier(<span class="type">AspectModifier</span>(<span class="number">2</span><span class="operator">/</span><span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p><strong><code>ViewModifier</code> 的核心功能</strong>是通过 <code>body(content:)</code> 方法接收一个视图并返回修改后的视图。 <code>ViewModifier</code> 协议只有一个函数。这个函数的唯一任务是根据传入的内容创建一个新的视图。从概念上讲，这个协议大致如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ViewModifier</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// Content 是一个“稍微关心一下”的视图，即被修饰的视图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">some</span> <span class="type">View，几乎肯定会包含内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在一个视图上调用 <code>modifier</code> 时，传递给这个 <code>body</code> 函数的内容就是该视图。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">aView.modifier(<span class="type">MyViewModifier</span>(arguments: <span class="operator">...</span>))</span><br></pre></td></tr></table></figure>

<p><code>MyViewModifier</code> 实现了 <code>ViewModifier</code> 协议，而 <code>aView</code> 将通过 <code>content</code> 传递给它的 <code>body</code> 函数。</p>
<h3 id="4-2-创建自定义-ViewModifier"><a href="#4-2-创建自定义-ViewModifier" class="headerlink" title="4.2 创建自定义 ViewModifier"></a><strong>4.2 创建自定义 ViewModifier</strong></h3><p><strong>目标</strong></p>
<ul>
<li>将任意视图转换为“卡片”样式。</li>
</ul>
<p><strong>使用方法</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">	.modifier(<span class="type">Cardify</span>(isFaceUp: <span class="literal">true</span>))</span><br></pre></td></tr></table></figure>

<p><code>.modifier</code> 将返回一个如下的视图</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cardify</span>: <span class="title class_ inherited__">ViewModifier</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> isFaceUp: <span class="type">Bool</span></span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">		<span class="type">ZStack</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> isFaceUp &#123;</span><br><span class="line">				<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>).fill(<span class="type">Color</span>.white)</span><br><span class="line">				<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>).stroke()</span><br><span class="line">				content</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>).fill(<span class="type">Color</span>.gray)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们要如何将其从 <code>.modifier(Cardify(isFaceUp: true))</code> 转变为 <code>.cardify(isFaceUp:true)</code> 呢？通过 <code>extension</code> 来实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">View</span> &#123;</span><br><span class="line">   <span class="keyword">func</span> <span class="title function_">cardify</span>(<span class="params">isFaceUp</span>: <span class="type">Bool</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	   modifier(<span class="type">Cardify</span>(isFaceUp: isFaceUp))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3-Demo：：实现-Cardify-修饰符"><a href="#4-3-Demo：：实现-Cardify-修饰符" class="headerlink" title="4.3 Demo：：实现 Cardify 修饰符"></a>4.3 Demo：：实现 <code>Cardify</code> 修饰符</h3><p>因为不需要预览（preview），所以创建一个 swift 文件，命名为 <code>Cardify.swift</code> 。</p>
<p>我们在 <code>CardView</code> 中截取 Card 部分，并删除会被 <code>Cardify</code> 的部分（即饼图）作为 content，并声明私有结构体 <code>Constants</code> 创建常数的命名空间。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Cardify.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cardify</span>: <span class="title class_ inherited__">ViewModifier</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> isFaceUp: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">        	<span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="type">Constants</span>.cornerRadius)</span><br><span class="line">        	<span class="type">Group</span> &#123;</span><br><span class="line">        		base.fill(.white)</span><br><span class="line">        		base.strokeBorder(lineWidth: <span class="type">Constants</span>.lineWidth)</span><br><span class="line">        		content</span><br><span class="line">			 &#125;</span><br><span class="line">			 .opacity(isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            base.fill()</span><br><span class="line">                .opacity(isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">struct</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> cornerRadius: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> lineWidth: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  CardView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">   	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Pie</span>(endAngle: .degrees(<span class="number">240</span>))</span><br><span class="line">            .opacity(<span class="type">Constants</span>.<span class="type">Pie</span>.opacity)</span><br><span class="line">            .overlay(</span><br><span class="line">                <span class="type">Text</span>(card.content)</span><br><span class="line">                    .font(.system(size: <span class="type">Constants</span>.<span class="type">FontSize</span>.largest))</span><br><span class="line">                    .minimumScaleFactor(<span class="type">Constants</span>.<span class="type">FontSize</span>.scaleFactor)</span><br><span class="line">                    .multilineTextAlignment(.center)</span><br><span class="line">                    .aspectRatio(<span class="number">1</span>, contentMode: .fit)</span><br><span class="line">                    .padding(<span class="type">Constants</span>.<span class="type">Pie</span>.in<span class="keyword">set</span>)</span><br><span class="line">            )</span><br><span class="line">            .padding(<span class="type">Constants</span>.in<span class="keyword">set</span>)</span><br><span class="line">            .modifier(<span class="type">Cardify</span>(isFaceUp: card.isFaceUp))</span><br><span class="line">            .opacity(card.isFaceUp <span class="operator">||</span> <span class="operator">!</span>card.isMatched <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">struct</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> inset: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">FontSize</span> &#123;</span><br><span class="line">        	<span class="operator">...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Pie</span> &#123;</span><br><span class="line">            <span class="operator">...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>我们想将 <code>.modifier</code> 变为 <code>.cardify</code> 则需要添加一个协议扩展：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cardify.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cardify</span>: <span class="title class_ inherited__">ViewModifier</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="type">Constants</span>.cornerRadius)</span><br><span class="line">            base.strokeBorder(lineWidth: <span class="type">Constants</span>.lineWidth)</span><br><span class="line">                .background(base.fill(.white))</span><br><span class="line">                .overlay(content)</span><br><span class="line">                .opacity(isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            base.fill()</span><br><span class="line">                .opacity(isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cardify</span>(<span class="params">isFaceUp</span>: <span class="type">Bool</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        modifier(<span class="type">Cardify</span>(isFaceUp: isFaceUp))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  CardView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">   	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Pie</span>(endAngle: .degrees(<span class="number">240</span>))</span><br><span class="line">            .opacity(<span class="type">Constants</span>.<span class="type">Pie</span>.opacity)</span><br><span class="line">            .overlay(</span><br><span class="line">                <span class="operator">...</span></span><br><span class="line">            )</span><br><span class="line">            .padding(<span class="type">Constants</span>.in<span class="keyword">set</span>)</span><br><span class="line">            .<span class="type">Cardify</span>(isFaceUp: card.isFaceUp)</span><br><span class="line">            .opacity(card.isFaceUp <span class="operator">||</span> <span class="operator">!</span>card.isMatched <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h2 id="5-协议（Protocol）"><a href="#5-协议（Protocol）" class="headerlink" title="5. 协议（Protocol）"></a><strong>5. 协议（Protocol）</strong></h2><h3 id="5-1-协议的用途"><a href="#5-1-协议的用途" class="headerlink" title="5.1 协议的用途"></a>5.1 协议的用途</h3><h4 id="5-1-1-协议的核心作用"><a href="#5-1-1-协议的核心作用" class="headerlink" title="5.1.1 协议的核心作用"></a><strong>5.1.1 协议的核心作用</strong></h4><ul>
<li>协议是 Swift 中用于<strong>定义行为和约定</strong>的工具。</li>
<li>它是代码共享的核心，允许在多个类型之间复用功能。</li>
<li>协议可以通过<strong>扩展（<code>extension</code>）</strong>来添加实现。<ul>
<li>示例：<ul>
<li><code>View</code> 协议的扩展为视图提供了许多修饰符，例如 <code>foregroundColor</code> 和 <code>font</code>。</li>
<li>通过扩展，开发者可以在协议中添加函数和属性的默认实现。</li>
<li>例如：<code>ObservableObject</code> 协议通过扩展获得了 <code>objectWillChange</code> 的默认实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-1-2-协议扩展的例子"><a href="#5-1-2-协议扩展的例子" class="headerlink" title="5.1.2 协议扩展的例子"></a><strong>5.1.2 协议扩展的例子</strong></h4><h5 id="5-1-2-1-示例-1：在协议中添加修饰符功能"><a href="#5-1-2-1-示例-1：在协议中添加修饰符功能" class="headerlink" title="5.1.2.1 示例 1：在协议中添加修饰符功能"></a><strong>5.1.2.1 示例 1：在协议中添加修饰符功能</strong></h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">foregroundColor</span>(<span class="keyword">_</span> <span class="params">color</span>: <span class="type">Color</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">font</span>(<span class="keyword">_</span> <span class="params">font</span>: <span class="type">Font</span>?) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这些扩展使视图类型（如 <code>Text</code> 和 <code>Image</code>）自动获得上述修饰符功能。</li>
</ul>
<h5 id="5-1-2-2-示例-2：filter-的实现"><a href="#5-1-2-2-示例-2：filter-的实现" class="headerlink" title="5.1.2.2 示例 2：filter 的实现"></a><strong>5.1.2.2 示例 2：<code>filter</code> 的实现</strong></h5><p><code>filter</code> 函数通过扩展被添加到 <code>Sequence</code> 协议中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Sequence</span> &#123;</span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">filter</span>(<span class="keyword">_</span> <span class="params">isIncluded</span>: (<span class="type">Element</span>) -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">		<span class="comment">// 实现代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着，<code>filter</code> 可以直接用于 <code>Array</code>、<code>Range</code> 和 <code>Dictionary</code> 等类型，而无需单独实现。</p>
<h3 id="5-2-泛型与协议"><a href="#5-2-泛型与协议" class="headerlink" title="5.2 泛型与协议"></a><strong>5.2 泛型与协议</strong></h3><h4 id="5-2-1-协议中的泛型类型"><a href="#5-2-1-协议中的泛型类型" class="headerlink" title="5.2.1 协议中的泛型类型"></a><strong>5.2.1 协议中的泛型类型</strong></h4><ul>
<li>协议支持泛型（”don’t care” 类型），允许它与不同类型结合使用。</li>
<li><strong><code>associatedtype</code> 关键字：</strong><ul>
<li>用于声明协议中的泛型类型。</li>
<li>示例：<code>Identifiable</code> 协议：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">ID</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">ID</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ID</code> 是一个泛型类型，它可以是任何类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-2-2-使用泛型约束"><a href="#5-2-2-使用泛型约束" class="headerlink" title="5.2.2 使用泛型约束"></a><strong>5.2.2 使用泛型约束</strong></h4><ul>
<li>可以通过泛型约束限制泛型类型的行为。<ul>
<li>示例：让 <code>ID</code> 必须遵循 <code>Hashable</code> 协议：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">ID</span>: <span class="type">Hashable</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">ID</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>解释：<ul>
<li><code>Hashable</code> 是一个协议，保证 <code>ID</code> 可以被用于哈希表中（例如字典或集合）。</li>
<li>这样可以确保 <code>Identifiable</code> 类型的对象是可查找的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-3-View-协议与-SwiftUI-类型系统"><a href="#5-3-View-协议与-SwiftUI-类型系统" class="headerlink" title="5.3 View 协议与 SwiftUI 类型系统"></a><strong>5.3 <code>View</code> 协议与 SwiftUI 类型系统</strong></h3><h4 id="5-3-1-View-协议的结构"><a href="#5-3-1-View-协议的结构" class="headerlink" title="5.3.1 View 协议的结构"></a><strong>5.3.1 <code>View</code> 协议的结构</strong></h4><ul>
<li>SwiftUI 中的 <code>View</code> 协议大致如下：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所有的视图（如 <code>Text</code>、<code>Button</code> 等）都需要实现 <code>body</code> 属性，并返回一个符合 <code>View</code> 协议的类型。</li>
</ul>
</li>
</ul>
<h4 id="5-3-2-扩展-View-协议"><a href="#5-3-2-扩展-View-协议" class="headerlink" title="5.3.2 扩展 View 协议"></a><strong>5.3.2 扩展 <code>View</code> 协议</strong></h4><ul>
<li>通过扩展 <code>View</code> 协议，SwiftUI 添加了许多常用功能：<ul>
<li>修饰符方法（如 <code>foregroundColor</code> 和 <code>font</code>）：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">foregroundColor</span>(<span class="keyword">_</span> <span class="params">color</span>: <span class="type">Color</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">font</span>(<span class="keyword">_</span> <span class="params">font</span>: <span class="type">Font</span>?) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这些方法为实现了 <code>View</code> 协议的所有类型（如 <code>Text</code>）提供了额外的功能。</li>
</ul>
</li>
</ul>
<h3 id="5-4-some-和-any-的用法"><a href="#5-4-some-和-any-的用法" class="headerlink" title="5.4 some 和 any 的用法"></a><strong>5.4 <code>some</code> 和 <code>any</code> 的用法</strong></h3><h4 id="5-4-1-some-关键字"><a href="#5-4-1-some-关键字" class="headerlink" title="5.4.1 some 关键字"></a><strong>5.4.1 <code>some</code> 关键字</strong></h4><ul>
<li><code>some</code> 用于返回<strong>不透明类型</strong>。</li>
<li><strong>返回不透明类型的示例：</strong><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>body</code> 的返回值是 <code>some View</code>，表示它返回的是一种符合 <code>View</code> 协议的具体类型，但具体是什么类型由 Swift 推断。</li>
<li>注意：<code>some</code> 类型在所有执行路径中必须一致。</li>
</ul>
</li>
</ul>
<h4 id="5-4-2-使用-some-创建函数示例"><a href="#5-4-2-使用-some-创建函数示例" class="headerlink" title="5.4.2 使用 some 创建函数示例"></a><strong>5.4.2 使用 <code>some</code> 创建函数示例</strong></h4><p>示例：返回不同的 <code>Shape</code> 类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getShape</span>(<span class="params">rounded</span>: <span class="type">Bool</span>) -&gt; <span class="keyword">some</span> <span class="type">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> rounded &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">12</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Rectangle</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值是 <code>some Shape</code>，保证调用方只需知道结果是某种 <code>Shape</code>。</p>
<h4 id="5-4-3-any-关键字"><a href="#5-4-3-any-关键字" class="headerlink" title="5.4.3 any 关键字"></a><strong>5.4.3 <code>any</code> 关键字</strong></h4><ul>
<li><p><code>any</code> 用于创建协议类型的异构集合。</p>
</li>
<li><p><strong>示例：协议类型数组</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ids: [<span class="keyword">any</span> <span class="type">Identifiable</span>] <span class="operator">=</span> []</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ids</code> 是一个可以存放不同 <code>Identifiable</code> 类型实例的数组。</li>
</ul>
</li>
<li><p><strong>限制：</strong></p>
<ul>
<li>要操作 <code>any</code> 协议类型的对象，必须通过接受具体协议的函数。</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printId</span>(<span class="params">of</span> <span class="params">identifiable</span>: <span class="keyword">some</span> <span class="type">Identifiable</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(identifiable.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-6-Identifiable-协议的例子"><a href="#5-6-Identifiable-协议的例子" class="headerlink" title="5.6 Identifiable 协议的例子"></a><strong>5.6 <code>Identifiable</code> 协议的例子</strong></h3><h4 id="5-6-1-协议定义"><a href="#5-6-1-协议定义" class="headerlink" title="5.6.1 协议定义"></a><strong>5.6.1 协议定义</strong></h4><ul>
<li><code>Identifiable</code> 是一个 Swift 标准库协议，定义如下：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">ID</span>: <span class="type">Hashable</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">ID</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用途：通过唯一标识符 <code>id</code> 区分对象。</li>
</ul>
</li>
</ul>
<h4 id="5-6-2-示例应用"><a href="#5-6-2-示例应用" class="headerlink" title="5.6.2 示例应用"></a><strong>5.6.2 示例应用</strong></h4><ul>
<li>在内存游戏中，为卡片定义标识符：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Card</span>: <span class="title class_ inherited__">Identifiable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">String</span> <span class="comment">// `id` 遵循 `Hashable` 协议</span></span><br><span class="line">    <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford-cs193p-08｜Animation</title>
    <url>/2025/01/20/Stanford-cs193p-08%EF%BD%9CAnimation/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第08集的相关笔记。</p>
<span id="more"></span>
<p>cs193p 课程介绍:</p>
<blockquote>
<p> The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.). </p>
</blockquote>
<p>cs193p 课程网址: [<a href="https://cs193p.sites.stanford.edu/2023]">https://cs193p.sites.stanford.edu/2023]</a></p>
<h2 id="1-动画的基础概念"><a href="#1-动画的基础概念" class="headerlink" title="1. 动画的基础概念"></a>1. 动画的基础概念</h2><h3 id="1-1-动画的作用"><a href="#1-1-动画的作用" class="headerlink" title="1.1 动画的作用"></a>1.1 动画的作用</h3><ul>
<li>动画展示了已经发生的改变（即“最近的过去”）。</li>
<li>动画的核心是通过改变 <strong>视图修饰符（ViewModifiers）</strong> 或 <strong>形状（shapes）</strong> 来呈现效果。</li>
<li>视图的出现与消失（存在与否）也可以通过动画体现。</li>
</ul>
<h3 id="1-2-动画的前提条件"><a href="#1-2-动画的前提条件" class="headerlink" title="1.2 动画的前提条件"></a>1.2 动画的前提条件</h3><ul>
<li>动画仅适用于已经在用户界面中（ui）的视图。</li>
<li>如果视图是新加入的，它必须添加到一个已经存在的容器中（即“已在屏幕上的容器”，简称 ctaaos）。</li>
</ul>
<h2 id="2-动画的实现方式"><a href="#2-动画的实现方式" class="headerlink" title="2. 动画的实现方式"></a>2. 动画的实现方式</h2><h3 id="2-1-隐式动画（implicit-animation）"><a href="#2-1-隐式动画（implicit-animation）" class="headerlink" title="2.1 隐式动画（implicit animation）"></a>2.1 隐式动画（implicit animation）</h3><ul>
<li>隐式动画通过 <code>animation</code> 修饰符自动应用到视图的更改上。</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    .opacity(isVisible <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">    .animation(.easeInOut, value: isVisible)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>isVisible</code> 的变化会触发 <code>opacity</code> 的动画。</li>
<li>适用于“叶子视图”（独立于其他视图工作的非容器视图）。</li>
</ul>
</li>
</ul>
<h3 id="2-2-显式动画（explicit-animation）"><a href="#2-2-显式动画（explicit-animation）" class="headerlink" title="2.2 显式动画（explicit animation）"></a>2.2 显式动画（explicit animation）</h3><ul>
<li>显式动画需要通过 <code>withAnimation</code> 函数手动触发，适合需要在多个属性变化之间协调或精细可控制动画的场景</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">import</span> SwiftUI  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">ExplicitAnimationExample</span>: <span class="title class_ inherited__">View</span> &#123;  </span><br><span class="line">       <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> rotationAngle <span class="operator">=</span> <span class="number">0.0</span>  </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">VStack</span> &#123;  </span><br><span class="line">               <span class="type">Image</span>(systemName: <span class="string">&quot;arrow.right.circle.fill&quot;</span>)  </span><br><span class="line">                   .font(.largeTitle)  </span><br><span class="line">                   .rotationEffect(.degrees(rotationAngle)) <span class="comment">// 应用旋转效果  </span></span><br><span class="line">               </span><br><span class="line">               <span class="type">Button</span>(<span class="string">&quot;Rotate&quot;</span>) &#123;  </span><br><span class="line">                   withAnimation(.spring()) &#123; <span class="comment">// 显式触发动画  </span></span><br><span class="line">                       rotationAngle <span class="operator">+=</span> <span class="number">90</span>  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           .padding()  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">ExplicitAnimationExample_PreViews</span>: <span class="title class_ inherited__">PreViewProvider</span> &#123;  </span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">var</span> preViews: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">ExplicitAnimationExample</span>()  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>withAnimation</code> 包裹 <code>rotationAngle</code> 的更改，视图的旋转会以动画形式更新。</li>
<li>显示动画常用于多个视图同步动画，例如响应用户交互时。</li>
</ul>
</li>
</ul>
<h3 id="2-3-转场动画（transition）"><a href="#2-3-转场动画（transition）" class="headerlink" title="2.3 转场动画（transition）"></a>2.3 转场动画（transition）</h3><ul>
<li>转场动画定义视图<strong>出现（插入）或消失</strong>的方式。过渡只在视图添加到或从视图层次结构移除时生效，常用于切换视图或动态视图更新。必须配合条件渲染（如 <code>if</code> 或 <code>@state</code>）以及 <code>.transition</code> 使用。</li>
<li>本质上是两个视图修饰符的组合：<ul>
<li>一个修饰符定义视图插入时的初始状态。</li>
<li>另一个修饰符定义视图移除后的最终状态。</li>
</ul>
</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> isfaceup &#123;</span><br><span class="line">    roundedrectangle(cornerradius: <span class="number">10</span>).transition(.scale)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    roundedrectangle(cornerradius: <span class="number">10</span>).transition(.opacity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当 <code>isfaceup</code> 变化时，视图会按定义的方式出现或消失。</li>
<li><strong>动画细节设置：</strong><ul>
<li>使用 <code>anytransition</code> 提供动画参数，例如：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">.transition(anytransition.opacity.animation(.easeInOut))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-动画曲线（animation-curve）"><a href="#2-4-动画曲线（animation-curve）" class="headerlink" title="2.4 动画曲线（animation curve）"></a>2.4 动画曲线（animation curve）</h3><h2 id="动画曲线决定动画的播放节奏：-linear-：匀速动画。"><a href="#动画曲线决定动画的播放节奏：-linear-：匀速动画。" class="headerlink" title="动画曲线决定动画的播放节奏：- **linear**：匀速动画。"></a>动画曲线决定动画的播放节奏：<br>- **<code>linear</code>**：匀速动画。</h2><p>&#96;**：缓慢开始和结束，中间加速。</p>
<ul>
<li>**<code>spring</code>**：带弹性效果的动画，结尾会有“反弹”效果。</li>
</ul>
<p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;hello, animation!&quot;</span>)</span><br><span class="line">    .scaleeffect(scale)</span><br><span class="line">    .animation(.spring(response: <span class="number">0.5</span>, dampingFraction: <span class="number">0.7</span>), value: scale)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-5-区别对比：隐式动画、显示动画、过渡"><a href="#2-5-区别对比：隐式动画、显示动画、过渡" class="headerlink" title="2.5 区别对比：隐式动画、显示动画、过渡"></a>2.5 区别对比：隐式动画、显示动画、过渡</h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>隐式动画</strong></th>
<th><strong>显式动画</strong></th>
<th><strong>过渡（transition）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>触发方式</strong></td>
<td>使用 <code>.animation()</code> 修饰符绑定属性变化</td>
<td>使用 <code>withAnimation()</code> 包裹状态更改</td>
<td>配合 <code>if</code> 或条件渲染，使用 <code>.transition()</code> 定义</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>属性的值随状态变化自动应用动画</td>
<td>需要手动触发动画或协调多个动画时</td>
<td>视图插入或移除时应用动画</td>
</tr>
<tr>
<td><strong>控制力度</strong></td>
<td>简单绑定，适合单个属性变化</td>
<td>更灵活，可精确控制动画的执行</td>
<td>专注于视图的出现和消失</td>
</tr>
<tr>
<td><strong>是否绑定状态</strong></td>
<td>是</td>
<td>是</td>
<td>是（针对视图的插入和移除）</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>.animation(.easeInOut(duration: 1))</code></td>
<td><code>withAnimation(.spring()) &#123; state.toggle() &#125;</code></td>
<td><code>.transition(.opacity)</code></td>
</tr>
</tbody></table>
<p><strong>示例：隐式动画、显式动画和过渡的结合</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">CombinedAnimationExample</span>: <span class="title class_ inherited__">View</span> &#123;  </span><br><span class="line">       <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> showRectangle <span class="operator">=</span> <span class="literal">false</span>  </span><br><span class="line">       <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> rotationAngle <span class="operator">=</span> <span class="number">0.0</span>  </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">VStack</span> &#123;  </span><br><span class="line">               <span class="keyword">if</span> showRectangle &#123;  </span><br><span class="line">                   <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">25</span>)  </span><br><span class="line">                       .fill(<span class="type">Color</span>.blue)  </span><br><span class="line">                       .frame(width: <span class="number">200</span>, height: <span class="number">200</span>)  </span><br><span class="line">                       .rotationEffect(.degrees(rotationAngle)) <span class="comment">// 动态旋转  </span></span><br><span class="line">                       .transition(.slide) <span class="comment">// 定义过渡效果  </span></span><br><span class="line">                       .animation(.easeInOut(duration: <span class="number">1</span>), value: rotationAngle) <span class="comment">// 隐式动画  </span></span><br><span class="line">               &#125;  </span><br><span class="line">   </span><br><span class="line">               <span class="type">Button</span>(<span class="string">&quot;Toggle Rectangle&quot;</span>) &#123;  </span><br><span class="line">                   withAnimation(.easeInOut) &#123; <span class="comment">// 显式触发动画  </span></span><br><span class="line">                       showRectangle.toggle()  </span><br><span class="line">                       rotationAngle <span class="operator">+=</span> <span class="number">180</span> <span class="comment">// 动态旋转  </span></span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           .padding()  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">CombinedAnimationExample_PreViews</span>: <span class="title class_ inherited__">PreViewProvider</span> &#123;  </span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">var</span> preViews: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">CombinedAnimationExample</span>()  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>隐式动画</strong>：<code>animation</code> 修饰符绑定 <code>rotationAngle</code>，动态旋转时使用平滑动画。</li>
<li><strong>显式动画</strong>：<code>withAnimation</code> 控制视图的插入和移除。</li>
<li><strong>过渡</strong>：<code>.transition(.slide)</code>，定义视图插入或移除时的滑动效果。</li>
</ul>
<h2 id="3-动画的高级主题"><a href="#3-动画的高级主题" class="headerlink" title="3. 动画的高级主题"></a>3. 动画的高级主题</h2><h3 id="3-1-匹配几何效果（matched-geometry-effect）"><a href="#3-1-匹配几何效果（matched-geometry-effect）" class="headerlink" title="3.1 匹配几何效果（matched geometry effect）"></a>3.1 匹配几何效果（matched geometry effect）</h3><p><strong>定义</strong><br><code>matchedGeometryEffect</code> 是一种动画工具，用于在视图间切换时创建流畅的动画过渡效果。它可以将两个视图关联起来，swiftui 会自动为它们在几何空间上的变化添加动画效果。</p>
<p><strong>特点</strong></p>
<ul>
<li>通过在两个视图之间共享一个唯一的 <code>namespace</code> 标识，swiftui 知道它们是同一个元素在不同状态下的表示。</li>
<li>支持位置、大小、形状和样式等几何属性的动画。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>动态切换视图或布局。</li>
<li>创建复杂的过渡动画，例如从网格到详细视图的切换。</li>
</ul>
<p><strong>示例：简单应用</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  matchegeometryexample.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MatchedGeometryExample</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@Namespace</span> <span class="keyword">private</span> <span class="keyword">var</span> animationnamespace <span class="comment">// 创建 namespace</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isExpanded <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> isExpanded &#123;</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">25</span>)</span><br><span class="line">                    .fill(<span class="type">Color</span>.blue)</span><br><span class="line">                    .matchedGeometryEffect(id: <span class="string">&quot;rectangle&quot;</span>, in: animationnamespace)</span><br><span class="line">                    .frame(width: <span class="number">300</span>, height: <span class="number">200</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">25</span>)</span><br><span class="line">                    .fill(<span class="type">Color</span>.blue)</span><br><span class="line">                    .matchedGeometryEffect(id: <span class="string">&quot;rectangle&quot;</span>, in: animationnamespace)</span><br><span class="line">                    .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Button</span>(<span class="string">&quot;toggle&quot;</span>) &#123;</span><br><span class="line">                withAnimation(.easeInOut) &#123;</span><br><span class="line">                    isExpanded.toggle()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="type">PreView</span> &#123;</span><br><span class="line">    <span class="type">MatchedGeometryExample</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>@namespace</code>**：创建一个动画范围（<code>namespace</code>）。</li>
<li>**<code>matchedGeometryEffect</code>**：将两个视图绑定到同一个 <code>id</code> 和 <code>namespace</code>，swiftui 会在它们之间自动插入动画过渡。</li>
<li><strong>效果</strong>：点击按钮后，矩形在大小和位置之间平滑过渡。</li>
</ul>
<h3 id="3-2-onappear"><a href="#3-2-onappear" class="headerlink" title="3.2 onappear"></a>3.2 onappear</h3><p><strong>定义</strong><br><code>onAppear</code> 是一个 swiftui 的视图修饰符，用于在视图第一次出现时触发特定的操作。</p>
<p><strong>特点：</strong></p>
<ul>
<li>适用于加载数据、初始化状态或启动动画。</li>
<li>每当视图进入屏幕时都会触发，包括首次加载和被隐藏视图重新显示。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>视图初始化逻辑，例如从网络加载数据。</li>
<li>在视图出现时开始动画。</li>
</ul>
<p><strong>示例：加载数据</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">onappearexample</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@state</span> <span class="keyword">private</span> <span class="keyword">var</span> message <span class="operator">=</span> <span class="string">&quot;loading...&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(message)</span><br><span class="line">            .onappear &#123;</span><br><span class="line">                <span class="comment">// 模拟数据加载</span></span><br><span class="line">                dispatchqueue.main.asyncafter(deadline: .now() <span class="operator">+</span> <span class="number">2</span>) &#123;</span><br><span class="line">                    message <span class="operator">=</span> <span class="string">&quot;data loaded!&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>onappear</code>**：在视图第一次出现在屏幕上时触发，更新 <code>message</code>。</li>
</ul>
<p><strong>示例：启动动画</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">AnimationOnAppear</span>: <span class="title class_ inherited__">View</span> &#123;  </span><br><span class="line">       <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> scale <span class="operator">=</span> <span class="number">0.5</span>  </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">Circle</span>()  </span><br><span class="line">               .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)  </span><br><span class="line">               .scaleEffect(scale)  </span><br><span class="line">               .onAppear &#123;  </span><br><span class="line">                   withAnimation(.spring()) &#123;  </span><br><span class="line">                       scale <span class="operator">=</span> <span class="number">1.0</span>  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">AnimationOnAppear_PreViews</span>: <span class="title class_ inherited__">PreViewProvider</span> &#123;  </span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">var</span> preViews: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">AnimationOnAppear</span>()  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>效果</strong>：圆形从缩小状态平滑扩展到原始大小。</li>
</ul>
<h3 id="3-3-animatable-协议"><a href="#3-3-animatable-协议" class="headerlink" title="3.3 animatable 协议"></a>3.3 animatable 协议</h3><p><strong>定义</strong><br><code>animatable</code> 协议是 swiftui 的一个协议，用于创建自定义动画。符合 <code>animatable</code> 的类型需要定义一个 <code>animatableData</code> 属性，该属性会在动画过程中自动更新。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> animatableData: type</span><br></pre></td></tr></table></figure>
<p><code>type</code> 必须实现 <code>vectorarithmetic</code> 协议，用于分割动画路径。</p>
<p><strong>特点</strong></p>
<ul>
<li>适合需要对自定义属性进行动画的场景。</li>
<li>通过 <code>animatabledata</code> 属性插入动画的插值逻辑。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>创建复杂的动画效果，例如路径变换、颜色渐变等。</li>
<li>对不直接支持动画的属性（如自定义绘图）添加动画。</li>
</ul>
<h4 id="3-3-1-animatabledate-动画数据的读写"><a href="#3-3-1-animatabledate-动画数据的读写" class="headerlink" title="3.3.1 animatabledate 动画数据的读写"></a>3.3.1 animatabledate 动画数据的读写</h4><ul>
<li><code>animatableData</code> 是一个<strong>读写属性</strong>：<ul>
<li><strong>写操作：</strong> 动画系统告诉 <code>shape</code> 或 <code>ViewModifier</code> 应该绘制的当前动画帧。</li>
<li><strong>读操作：</strong> 动画系统获取动画的起点和终点值。</li>
</ul>
</li>
<li>示例：<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cardify</span>: <span class="title class_ inherited__">ViewModifier</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> rotation: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; rotation &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; rotation <span class="operator">=</span> newvalue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: content) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 rotation 值绘制视图</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-3-2-示例：路径变换动画"><a href="#3-3-2-示例：路径变换动画" class="headerlink" title="3.3.2 示例：路径变换动画"></a>3.3.2 示例：路径变换动画</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">AnimatableShape</span>: <span class="title class_ inherited__">Shape</span> &#123;  </span><br><span class="line">       <span class="keyword">var</span> animatableData: <span class="type">CGFloat</span> <span class="comment">// 定义可动画数据  </span></span><br><span class="line">   </span><br><span class="line">       <span class="keyword">func</span> <span class="title function_">path</span>(<span class="params">in</span> <span class="params">rect</span>: <span class="type">CGRect</span>) -&gt; <span class="type">Path</span> &#123;  </span><br><span class="line">           <span class="keyword">var</span> path <span class="operator">=</span> <span class="type">Path</span>()  </span><br><span class="line">           path.move(to: <span class="type">CGPoint</span>(x: rect.midX, y: rect.minY))  </span><br><span class="line">           path.addLine(to: <span class="type">CGPoint</span>(x: rect.maxX, y: rect.maxY))  </span><br><span class="line">           path.addLine(to: <span class="type">CGPoint</span>(x: rect.minX, y: rect.maxY))  </span><br><span class="line">           path.closeSubpath()  </span><br><span class="line">           <span class="keyword">return</span> path  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">AnimatableExample</span>: <span class="title class_ inherited__">View</span> &#123;  </span><br><span class="line">       <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0.0</span>  </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">AnimatableShape</span>(animatableData: value)  </span><br><span class="line">               .fill(<span class="type">Color</span>.blue)  </span><br><span class="line">               .frame(width: <span class="number">200</span>, height: <span class="number">200</span>)  </span><br><span class="line">               .onAppear &#123;  </span><br><span class="line">                   withAnimation(.easeInOut(duration: <span class="number">2</span>)) &#123;  </span><br><span class="line">                       value <span class="operator">=</span> <span class="number">1.0</span> <span class="comment">// 触发动画  </span></span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>animatabledata</code>**：定义可动画的属性，在动画过程中插值变化。</li>
<li><strong>效果</strong>：<code>animatableshape</code> 会根据动画数据的变化动态更新其路径。</li>
</ul>
<h3 id="3-4-示例：综合使用-matchedGeometryEffect-和-animatable"><a href="#3-4-示例：综合使用-matchedGeometryEffect-和-animatable" class="headerlink" title="3.4 示例：综合使用 matchedGeometryEffect 和 animatable"></a>3.4 示例：综合使用 matchedGeometryEffect 和 animatable</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">CombinedExample</span>: <span class="title class_ inherited__">View</span> &#123;  </span><br><span class="line">       <span class="meta">@Namespace</span> <span class="keyword">private</span> <span class="keyword">var</span> namespace  </span><br><span class="line">       <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isExpanded <span class="operator">=</span> <span class="literal">false</span>  </span><br><span class="line">       <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> customValue: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0.5</span>  </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">VStack</span> &#123;  </span><br><span class="line">               <span class="keyword">if</span> isExpanded &#123;  </span><br><span class="line">                   <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">25</span>)  </span><br><span class="line">                       .fill(<span class="type">Color</span>.blue)  </span><br><span class="line">                       .matchedGeometryEffect(id: <span class="string">&quot;rectangle&quot;</span>, in: namespace)  </span><br><span class="line">                       .frame(width: <span class="number">300</span>, height: <span class="number">200</span>)  </span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                   <span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">25</span>)  </span><br><span class="line">                       .fill(<span class="type">Color</span>.blue)  </span><br><span class="line">                       .matchedGeometryEffect(id: <span class="string">&quot;rectangle&quot;</span>, in: namespace)  </span><br><span class="line">                       .frame(width: <span class="number">100</span>, height: <span class="number">100</span>)  </span><br><span class="line">               &#125;  </span><br><span class="line">   </span><br><span class="line">               <span class="type">Slider</span>(value: <span class="variable">$customValue</span>)  </span><br><span class="line">                   .padding()  </span><br><span class="line">                   .onAppear &#123;  </span><br><span class="line">                       withAnimation(.easeInOut) &#123;  </span><br><span class="line">                           customValue <span class="operator">=</span> <span class="number">1.0</span>  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">   </span><br><span class="line">               <span class="type">Button</span>(<span class="string">&quot;Toggle&quot;</span>) &#123;  </span><br><span class="line">                   withAnimation(.spring()) &#123;  </span><br><span class="line">                       isExpanded.toggle()  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           .padding()  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>-<br>：用于矩形的大小和位置动画。</p>
<ul>
<li><strong>onAppear</strong>：在视图首次加载时触发滑块的动画。</li>
<li><strong>animatable</strong>：通过滑块调整自定义动画属性（如路径）。</li>
</ul>
<h3 id="4-demo"><a href="#4-demo" class="headerlink" title="4. demo"></a>4. demo</h3><h4 id="4-1-显式动画（shuffle-and-choosing-cards）"><a href="#4-1-显式动画（shuffle-and-choosing-cards）" class="headerlink" title="4.1 显式动画（shuffle and choosing cards）"></a>4.1 显式动画（shuffle and choosing cards）</h4><p><strong>shuffle cards</strong></p>
<p>shuffle 动画用于响应用户交互，此时更适合使用显示动画（<br>）。如果使用隐式动画，当用户频繁点击 <code>shuffle</code> 时，动画有时难以及时响应。</p>
<p>shuffle 时发生了什么变化？它对 <code>LazyVGrid</code> 视图中的 <code>ForEach</code> 中<br>s&#96; 的位置参数进行了重排序。</p>
<p><strong>choose cards</strong></p>
<p>choose card 的动画同样用于响应用户交互，适合使用显示动画。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGameView.swift  </span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">import</span> SwiftUI  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;  </span><br><span class="line">       <span class="comment">// ...  </span></span><br><span class="line">   </span><br><span class="line">       <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">VStack</span> &#123;  </span><br><span class="line">               cards  </span><br><span class="line">                   .foregroundColor(<span class="type">ViewModel</span>.color)  </span><br><span class="line">               <span class="type">Button</span>(<span class="string">&quot;Shuffle&quot;</span>) &#123;  </span><br><span class="line">                   <span class="comment">// 使用显式动画来处理用户交互：shuffle  </span></span><br><span class="line">                   withAnimation &#123;  </span><br><span class="line">                       <span class="type">ViewModel</span>.shuffle()  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           .padding()  </span><br><span class="line">       &#125;  </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">AspectVGrid</span>(items: <span class="type">ViewModel</span>.cards, aspectRatio: aspectRatio) &#123; card <span class="keyword">in</span>  </span><br><span class="line">               <span class="type">CardView</span>(card)  </span><br><span class="line">                   .aspectRatio(aspectRatio, contentMode: .fit)  </span><br><span class="line">                   .padding(<span class="number">8</span>)  </span><br><span class="line">                   .overlay(<span class="type">FlyingNumber</span>(number: scoreChange(causedBy: card)))  </span><br><span class="line">                   .onTapGesture &#123;  </span><br><span class="line">                       <span class="comment">// 使用显式动画处理用户交互：choose  </span></span><br><span class="line">                       withAnimation &#123;  </span><br><span class="line">                           <span class="type">ViewModel</span>.choose(card)  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-隐式动画（celebrating-a-match-）"><a href="#4-2-隐式动画（celebrating-a-match-）" class="headerlink" title="4.2 隐式动画（celebrating a match!）"></a>4.2 隐式动画（celebrating a match!）</h4><p>当卡片朝上时，我们希望给卡片设置一个庆祝动作。（不论用户是否点击该卡片，当卡片 <code>isMatched</code> 参数为 <code>true</code> 时，显示动画，与用户交互无关，shuffle 不会影响该动画）</p>
<p>我们希望简化动画的代码，为 <code>animation</code> 添加一个扩展 <code>spin</code> 动画。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  cardView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">        <span class="type">Pie</span>(endAngle: .degrees(<span class="number">240</span>))  </span><br><span class="line">            .opacity(<span class="type">Constants</span>.pie.opacity)  </span><br><span class="line">            .overlay(  </span><br><span class="line">                <span class="type">Text</span>(card.content)  </span><br><span class="line">                    .font(.system(size: <span class="type">Constants</span>.fontSize.largest))  </span><br><span class="line">                    .minimumScaleFactor(<span class="type">Constants</span>.fontSize.scaleFactor)  </span><br><span class="line">                    .multilineTextAlignment(.center)  </span><br><span class="line">                    .aspectRatio(<span class="number">1</span>, contentMode: .fit)  </span><br><span class="line">                    .padding(<span class="type">Constants</span>.pie.in<span class="keyword">set</span>)  </span><br><span class="line">                    .rotationEffect(.degrees(card.isMatched <span class="operator">?</span> <span class="number">360</span> : <span class="number">0</span>))  </span><br><span class="line">                    .animation(.spin(duration: <span class="number">1</span>), value: card.isMatched)  </span><br><span class="line">            )  </span><br><span class="line">            <span class="comment">// ...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Animation</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">spin</span>(<span class="params">duration</span>: <span class="type">TimeInterval</span>) -&gt; <span class="type">Animation</span> &#123;  </span><br><span class="line">        .linear(duration: duration).repeatForever(autoreverses: <span class="literal">false</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-animate-Viewmodifier-flipping-the-cards-over"><a href="#4-3-animate-Viewmodifier-flipping-the-cards-over" class="headerlink" title="4.3 animate Viewmodifier (flipping the cards over)"></a>4.3 animate Viewmodifier (flipping the cards over)</h4><p>我们想要为卡片添加一个翻转动画，显然这与 <code>cardify</code> Viewmodifier 有关。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cardify.swift  </span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">import</span> SwiftUI  </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Cardify</span>: <span class="title class_ inherited__">ViewModifier</span>, <span class="title class_ inherited__">Animatable</span> &#123;  </span><br><span class="line">     <span class="comment">// isFaceUp 为 true 时，再次点击卡片不会有动画效果  </span></span><br><span class="line">     <span class="keyword">init</span>(<span class="params">isFaceUp</span>: <span class="type">Bool</span>) &#123;  </span><br><span class="line">         rotation <span class="operator">=</span> isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">180</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 令此处的 isFaceUp 为一个计算属性，确保在还未翻转 90 度前，看不到卡片内容  </span></span><br><span class="line">     <span class="keyword">var</span> isFaceUp: <span class="type">Bool</span> &#123;  </span><br><span class="line">         rotation <span class="operator">&lt;</span> <span class="number">90</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> </span><br><span class="line">     <span class="keyword">var</span> rotation: <span class="type">Double</span>  </span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 符合 Animatable 协议，需要 animatableData 可读写的计算属性  </span></span><br><span class="line">     <span class="keyword">var</span> animatableData: <span class="type">Double</span> &#123;  </span><br><span class="line">         <span class="keyword">get</span> &#123;  </span><br><span class="line">             <span class="keyword">return</span> rotation  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">set</span> &#123;  </span><br><span class="line">             rotation <span class="operator">=</span> newValue  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> </span><br><span class="line">     <span class="keyword">func</span> <span class="title function_">body</span>(<span class="params">content</span>: <span class="type">Content</span>) -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">         <span class="type">ZStack</span> &#123;  </span><br><span class="line">             <span class="keyword">let</span> base <span class="operator">=</span> <span class="type">RoundedRectangle</span>(cornerRadius: <span class="type">Constants</span>.cornerRadius)  </span><br><span class="line">             base.strokeBorder(lineWidth: <span class="type">Constants</span>.lineWidth)  </span><br><span class="line">                 .background(base.fill(<span class="type">Color</span>.white))  </span><br><span class="line">                 .overlay(content)  </span><br><span class="line">                 .opacity(isFaceUp <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)  </span><br><span class="line">             base.fill()  </span><br><span class="line">                 .opacity(isFaceUp <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)  </span><br><span class="line">         &#125;  </span><br><span class="line">         .rotation3DEffect(.degrees(rotation), axis: (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>))  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="operator">...</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>
<h4 id="4-4-取消不想要的动画（-animation-nil-）"><a href="#4-4-取消不想要的动画（-animation-nil-）" class="headerlink" title="4.4 取消不想要的动画（.animation(nil)）"></a>4.4 取消不想要的动画（.animation(nil)）</h4><p>接下来，要实现记分的功能，我们需要在 <code>memorygame</code> 中添加分数的计算属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MemorizeGame.swift  </span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">import</span> Foundation  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; <span class="keyword">where</span> <span class="type">CardContent</span>: <span class="type">Equatable</span> &#123;  </span><br><span class="line">       <span class="keyword">private(set)</span> <span class="keyword">var</span> cards: [<span class="type">Card</span>]  </span><br><span class="line">       <span class="keyword">private(set)</span> <span class="keyword">var</span> score <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">init</span>(<span class="params">numberOfPairsOfCards</span>: <span class="type">Int</span>, <span class="params">cardContentFactory</span>: (<span class="type">Int</span>) -&gt; <span class="type">CardContent</span>) &#123;  </span><br><span class="line">           <span class="comment">// ...  </span></span><br><span class="line">       &#125;  </span><br><span class="line">   </span><br><span class="line">       <span class="comment">// ...  </span></span><br><span class="line">       <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) &#123;  </span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">let</span> chosenIndex <span class="operator">=</span> cards.firstIndex(where: &#123; <span class="variable">$0</span>.id <span class="operator">==</span> card.id &#125;) &#123;  </span><br><span class="line">               <span class="keyword">if</span> <span class="operator">!</span>cards[chosenIndex].isFaceUp <span class="operator">&amp;&amp;</span> <span class="operator">!</span>cards[chosenIndex].isMatched &#123;  </span><br><span class="line">                   <span class="keyword">if</span> <span class="keyword">let</span> potentialMatchIndex <span class="operator">=</span> indexOfTheOneAndOnlyFaceUpCard &#123;  </span><br><span class="line">                       <span class="keyword">if</span> cards[chosenIndex].content <span class="operator">==</span> cards[potentialMatchIndex].content &#123;  </span><br><span class="line">                           cards[chosenIndex].isMatched <span class="operator">=</span> <span class="literal">true</span>  </span><br><span class="line">                           cards[potentialMatchIndex].isMatched <span class="operator">=</span> <span class="literal">true</span>  </span><br><span class="line">                           score <span class="operator">+=</span> <span class="number">2</span>  </span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                           <span class="keyword">if</span> cards[chosenIndex].hasBeenSeen &#123;  </span><br><span class="line">                               score <span class="operator">-=</span> <span class="number">1</span>  </span><br><span class="line">                           &#125;  </span><br><span class="line">                           <span class="keyword">if</span> cards[potentialMatchIndex].hasBeenSeen &#123;  </span><br><span class="line">                               score <span class="operator">-=</span> <span class="number">1</span>  </span><br><span class="line">                           &#125;  </span><br><span class="line">                       &#125;  </span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                       indexOfTheOneAndOnlyFaceUpCard <span class="operator">=</span> chosenIndex  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   cards[chosenIndex].isFaceUp <span class="operator">=</span> <span class="literal">true</span>  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">struct</span> <span class="title class_">Card</span>: <span class="title class_ inherited__">Identifiable</span>, <span class="title class_ inherited__">Equatable</span>, <span class="title class_ inherited__">CustomDebugStringConvertible</span> &#123;  </span><br><span class="line">           <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">false</span> &#123;  </span><br><span class="line">               <span class="keyword">didSet</span> &#123;  </span><br><span class="line">                   <span class="keyword">if</span> oldValue <span class="operator">&amp;&amp;</span> <span class="operator">!</span>isFaceUp &#123;  </span><br><span class="line">                       hasBeenSeen <span class="operator">=</span> <span class="literal">true</span>  </span><br><span class="line">                   &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">           <span class="keyword">var</span> isMatched <span class="operator">=</span> <span class="literal">false</span>  </span><br><span class="line">           <span class="keyword">var</span> hasBeenSeen <span class="operator">=</span> <span class="literal">false</span>  </span><br><span class="line">           <span class="keyword">var</span> content: <span class="type">CardContent</span>  </span><br><span class="line">           </span><br><span class="line">           <span class="keyword">var</span> id: <span class="type">String</span>  </span><br><span class="line">           <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;  </span><br><span class="line">               <span class="string">&quot;<span class="subst">\(id)</span>: <span class="subst">\(content)</span> <span class="subst">\(isFaceUp <span class="operator">?</span> <span class="string">&quot;up&quot;</span> : <span class="string">&quot;down&quot;</span>)</span> <span class="subst">\(isMatched <span class="operator">?</span> <span class="string">&quot;matched&quot;</span> : <span class="string">&quot;&quot;</span>)</span>&quot;</span>  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<p>在 <code>EmojiMemoryGameView</code> 中添加 <code>score</code> 视图并调整布局。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGameView.swift  </span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">import</span> SwiftUI  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;  </span><br><span class="line">       <span class="keyword">typealias</span> <span class="type">Card</span> <span class="operator">=</span> <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span>  </span><br><span class="line">   </span><br><span class="line">       <span class="comment">// @StateObject 意味着你不能和其他 View 共享 EmojiMemoryGame 这个对象  </span></span><br><span class="line">       <span class="comment">// @ObservedObject 表明你会观察这个变量，一旦这个变量发生改变，会重新渲染这个 UI 界面  </span></span><br><span class="line">       <span class="meta">@ObservedObject</span> <span class="keyword">var</span> <span class="type">ViewModel</span>: <span class="type">EmojiMemoryGame</span>  </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">let</span> aspectRatio: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">/</span> <span class="number">3</span>  </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">VStack</span> &#123;  </span><br><span class="line">               cards  </span><br><span class="line">                   .foregroundColor(<span class="type">ViewModel</span>.color)  </span><br><span class="line">               <span class="type">HStack</span> &#123;  </span><br><span class="line">                   score  </span><br><span class="line">                   <span class="type">Spacer</span>()  </span><br><span class="line">                   shuffle  </span><br><span class="line">               &#125;  </span><br><span class="line">               .font(.largeTitle)  </span><br><span class="line">           &#125;  </span><br><span class="line">           .padding()  </span><br><span class="line">       &#125;  </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">var</span> score: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">Text</span>(<span class="string">&quot;Score: <span class="subst">\(ViewModel.score)</span>&quot;</span>)  </span><br><span class="line">               <span class="comment">// 取消 Score 视图的动画效果  </span></span><br><span class="line">               .animation(<span class="literal">nil</span>)  </span><br><span class="line">       &#125;  </span><br><span class="line">   </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">var</span> shuffle: <span class="keyword">some</span> <span class="type">View</span> &#123;  </span><br><span class="line">           <span class="type">Button</span>(<span class="string">&quot;Shuffle&quot;</span>) &#123;  </span><br><span class="line">               withAnimation &#123;  </span><br><span class="line">                   <span class="type">ViewModel</span>.shuffle()  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">// ...  </span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-onappear-动画（飞行的分数变化）"><a href="#4-5-onappear-动画（飞行的分数变化）" class="headerlink" title="4.5 onappear 动画（飞行的分数变化）"></a>4.5 onappear 动画（飞行的分数变化）</h4><p>这里希望每当出现得分，或者负分等不为 0 的情况时，会有飞行的记分动画。</p>
<p>我们添加一个 <code>FlyingNumber</code> 视图重叠在 <code>cards</code> 视图上，关于 <code>scoreChange</code> 函数会在下一节课继续。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Card</span> <span class="operator">=</span> <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span></span><br><span class="line">	<span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">AspectVGrid</span>(items: <span class="type">ViewModel</span>.cards, aspectRatio: aspectRatio) &#123; card <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(card)</span><br><span class="line">                .aspectRatio(aspectRatio, contentMode: .fit)</span><br><span class="line">                .padding(<span class="number">8</span>)</span><br><span class="line">                .overlay(<span class="type">FlyingNumber</span>(number: scoreChange(causedBy: card)))</span><br><span class="line">                .onTapGesture &#123;</span><br><span class="line">                    withAnimation &#123;</span><br><span class="line">                        <span class="type">ViewModel</span>.choose(card)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">scoreChange</span>(<span class="params">causedBy</span> <span class="params">card</span>: <span class="type">Card</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="type">PreView</span> &#123;</span><br><span class="line">    <span class="type">EmojiMemoryGameView</span>(ViewModel: <span class="type">EmojiMemoryGame</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-课程预告-09"><a href="#5-课程预告-09" class="headerlink" title="5. 课程预告 09"></a>5. 课程预告 09</h2><ul>
<li>TimelineView （animating our pie-shaped countdown timer）</li>
<li>过渡动画（animating the arrival and departure of Views）</li>
<li>matchedGeometryEffect（dealing our cards out）</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford-cs193p-09｜Animation-2</title>
    <url>/2025/01/20/Stanford-cs193p-09%EF%BD%9CAnimation-2/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 09 集的相关笔记。</p>
<span id="more"></span>

<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>cs193p 课程网址: [<a href="https://cs193p.sites.stanford.edu/2023]">https://cs193p.sites.stanford.edu/2023]</a></p>
<h2 id="1-Demo-onAppear-animation"><a href="#1-Demo-onAppear-animation" class="headerlink" title="1. Demo: onAppear animation"></a>1. Demo: onAppear animation</h2><blockquote>
<p><strong>flying score change indications (incl. Property Observer and Tuples)</strong></p>
</blockquote>
<p>为了同时观察当前卡片，和当前卡片得分的变化，我们使用 tuple <code>lastScoreChange = (scoreChange:Int,causeByCardId:&quot;&quot;)</code> 来记录。在 <code>withAnimation</code> 中制定卡片得分变化的动画规则。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">AspectVGrid</span>(items: viewModel.cards, aspectRatio: aspectRatio) &#123; card <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(card)</span><br><span class="line">                .aspectRatio(aspectRatio, contentMode: .fit)</span><br><span class="line">                .padding(<span class="number">4</span>)</span><br><span class="line">                .overlay(<span class="type">FlyingNumber</span>(number: scoreChange(causedBy: card)))</span><br><span class="line">                .onTapGesture &#123;</span><br><span class="line">                    withAnimation &#123;</span><br><span class="line">                        <span class="keyword">let</span> scoreBeforeChoosing <span class="operator">=</span> viewModel.score</span><br><span class="line">                        viewModel.choose(card)</span><br><span class="line">                        <span class="keyword">let</span> scoreChange <span class="operator">=</span> viewModel.score <span class="operator">-</span> scoreBeforeChoosing</span><br><span class="line">                        lastScoreChange <span class="operator">=</span> (scoreChange, causedByCardId:card.id)</span><br><span class="line">                        <span class="comment">// 等同于：lastScoreChange = (scoreChange,card.id)，但为了代码的易读性，更推荐上一种写法</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> lastScoreChange <span class="operator">=</span> (<span class="number">0</span>,causedByCardId:<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">scoreChange</span>(<span class="params">causedBy</span> <span class="params">card</span>: <span class="type">Card</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-tuple-解构"><a href="#1-1-tuple-解构" class="headerlink" title="1.1 tuple 解构"></a>1.1 tuple 解构</h3><p>解构 <code>tuple</code>：我们可以通过名称或者索引解构 <code>tuple</code>，例如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> (name: <span class="string">&quot;Alice&quot;</span>, age: <span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(person.age)  <span class="comment">// 输出：25</span></span><br><span class="line"><span class="built_in">print</span>(person.<span class="number">0</span>)  <span class="comment">// 输出：25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以同时解构并赋值给另一个变量</span></span><br><span class="line"><span class="keyword">let</span> (name01,age01) <span class="operator">=</span> person</span><br><span class="line"><span class="built_in">print</span>(name01) <span class="comment">// 输出：Alice</span></span><br><span class="line"><span class="built_in">print</span>(age01) <span class="comment">// 输出:25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 tuple 值同理</span></span><br><span class="line">person.age <span class="operator">=</span> <span class="number">27</span></span><br><span class="line"><span class="built_in">print</span>(person.age) <span class="comment">//输出 27</span></span><br></pre></td></tr></table></figure>

<p>通常使用名称解构使代码易读性更好。</p>
<p>在 <code>scoreChange</code> 中对 <code>lastScoreChange</code> 解构并赋值，获取当前卡片得分。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">   <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> lastScoreChange <span class="operator">=</span> (<span class="number">0</span>,causedByCardId:<span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">scoreChange</span>(<span class="params">causedBy</span> <span class="params">card</span>: <span class="type">Card</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (amount,id) <span class="operator">=</span> lastScoreChange</span><br><span class="line">        <span class="keyword">return</span> card.id <span class="operator">==</span> id <span class="operator">?</span> amount : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-number-sign-startegy-always"><a href="#1-2-number-sign-startegy-always" class="headerlink" title="1.2 .number.sign(startegy:.always())"></a>1.2 <code>.number.sign(startegy:.always())</code></h3><p>此时在匹配时会有数字显示，但不明显。我们让数字更清晰一些。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  FlyingNumber.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FlyingNumber</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> number: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> number <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(number,format: .number.sign(strategy: .always()))</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .foregroundColor(number <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">?</span> .red : .green)</span><br><span class="line">                .shadow(color: .black, radius: <span class="number">1.5</span>, x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.number.sign(startegy:.always())</code> 确保数字始终显示一个符号，正数显示 <code>+</code> 符号，负数显示 <code>-</code> 符号。</p>
<h3 id="1-3-offset、onAppear、onDisappear"><a href="#1-3-offset、onAppear、onDisappear" class="headerlink" title="1.3 offset、onAppear、onDisappear"></a>1.3 offset、onAppear、onDisappear</h3><p>现在来制作这个数字的偏移动画。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  FlyingNumber.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FlyingNumber</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> offset : <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> number <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(number,format: .number.sign(strategy: .always()))</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                .foregroundColor(number <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">?</span> .red : .green)</span><br><span class="line">                .shadow(color: .black, radius: <span class="number">1.5</span>, x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line">                .offset(x : <span class="number">0</span>, y : offset)</span><br><span class="line">                .opacity(offset <span class="operator">!=</span> <span class="number">0</span> <span class="operator">?</span> <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">                .onAppear &#123;</span><br><span class="line">                    withAnimation(.easeOut(duration: <span class="number">2.0</span>))&#123;</span><br><span class="line">                        offset <span class="operator">=</span> number <span class="operator">&lt;</span> <span class="number">0</span> <span class="operator">?</span> <span class="number">200</span>: <span class="operator">-</span><span class="number">200</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .onDisappear &#123;</span><br><span class="line">                    offset <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>offset</code> 是相对于当前位置的绝对位置偏移</li>
<li><code>.onAppear</code> 设置当这个数字出现时产生的动画。</li>
<li><code>.onDisappear</code> 设置当数字消失时让其回到原来的位置，否则下一次数字出现时会在上一次偏移后的位置。</li>
</ul>
<h4 id="1-4-zIndex"><a href="#1-4-zIndex" class="headerlink" title="1.4 zIndex"></a>1.4 <code>zIndex</code></h4><p>上面的代码有一个问题，在点击两张不匹配的卡片时，负分在飞行时会在其他卡片下方不能正常显示。因为后生成的 Card 层级会 overlay 前边生成的 Card 层级。</p>
<p>为确保分数始终能在所有卡片上方飞过，使用 <code>zIndex</code> 来手动调整 FlyingNumber card 的层级。当 <code>scoreChange</code> 不为 0 时，则让其位于最上方。</p>
<p>我们将 <code>onTApGesture</code> 中的交互动作提取为一个私有函数 <code>choose</code> 以使函数更易读。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">AspectVGrid</span>(items: viewModel.cards, aspectRatio: aspectRatio) &#123; card <span class="keyword">in</span></span><br><span class="line">            <span class="type">CardView</span>(card)</span><br><span class="line">                .aspectRatio(aspectRatio, contentMode: .fit)</span><br><span class="line">                .padding(<span class="number">4</span>)</span><br><span class="line">                .overlay(<span class="type">FlyingNumber</span>(number: scoreChange(causedBy: card)))</span><br><span class="line">                .zIndex(scoreChange(causedBy: card) <span class="operator">!=</span> <span class="number">0</span> <span class="operator">?</span> <span class="number">100</span> : <span class="number">0</span>)</span><br><span class="line">                .onTapGesture &#123;</span><br><span class="line">                	choose(card)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>:<span class="type">Card</span>) &#123;</span><br><span class="line">		withAnimation &#123;</span><br><span class="line">			<span class="keyword">let</span> scoreBeforeChoosing <span class="operator">=</span> viewModel.score</span><br><span class="line">			viewModel.choose(card)</span><br><span class="line">			<span class="keyword">let</span> scoreChange <span class="operator">=</span> viewModel.score <span class="operator">-</span> scoreBeforeChoosing</span><br><span class="line">			lastScoreChange <span class="operator">=</span> (scoreChange, causedByCardId:card.id)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> lastScoreChange <span class="operator">=</span> (<span class="number">0</span>,causedByCardId:<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">scoreChange</span>(<span class="params">causedBy</span> <span class="params">card</span>: <span class="type">Card</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (amount,id) <span class="operator">=</span> lastScoreChange</span><br><span class="line">        <span class="keyword">return</span> card.id <span class="operator">==</span> id <span class="operator">?</span> amount : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Demo-TimelineView"><a href="#2-Demo-TimelineView" class="headerlink" title="2. Demo: TimelineView"></a>2. Demo: TimelineView</h2><blockquote>
<p><strong>animation our pie shaped countdown timer</strong></p>
</blockquote>
<p>倒计时部分新增 model 代码，在每次牌朝上时使用奖励时间，在每次卡牌面朝下时停止奖励时间，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  MemoryGame.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MemoryGame</span>&lt;<span class="type">CardContent</span>&gt; <span class="keyword">where</span> <span class="type">CardContent</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">  	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">choose</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> chosenIndex <span class="operator">=</span> cards.firstIndex(where: &#123; <span class="variable">$0</span>.id <span class="operator">==</span> card.id &#125;) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="operator">!</span>cards[chosenIndex].isFaceUp <span class="operator">&amp;&amp;</span> <span class="operator">!</span>cards[chosenIndex].isMatched &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> potentialMatchIndex <span class="operator">=</span> indexOfTheOneAndOnlyFaceUpCard &#123;</span><br><span class="line">                    <span class="keyword">if</span> cards[chosenIndex].content <span class="operator">==</span> cards[potentialMatchIndex].content &#123;</span><br><span class="line">                        cards[chosenIndex].isMatched <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                        cards[potentialMatchIndex].isMatched <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                        score <span class="operator">+=</span> <span class="number">2</span> <span class="operator">+</span> cards[chosenIndex].bonus <span class="operator">+</span> cards[potentialMatchIndex].bonus</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> cards[chosenIndex].hasBeenSeen &#123;</span><br><span class="line">                            score <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> cards[potentialMatchIndex].hasBeenSeen &#123;</span><br><span class="line">                            score <span class="operator">-=</span> <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    indexOfTheOneAndOnlyFaceUpCard <span class="operator">=</span> chosenIndex</span><br><span class="line">                &#125;</span><br><span class="line">                cards[chosenIndex].isFaceUp <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Card</span>: <span class="title class_ inherited__">Equatable</span>, <span class="title class_ inherited__">Identifiable</span>, <span class="title class_ inherited__">CustomStringConvertible</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> isFaceUp <span class="operator">=</span> <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">didSet</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> isFaceUp &#123;</span><br><span class="line">                    startUsingBonusTime()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stopUsingBonusTime()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> oldValue <span class="operator">&amp;&amp;</span> <span class="operator">!</span>isFaceUp &#123;</span><br><span class="line">                    hasBeenSeen <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> hasBeenSeen <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> isMatched <span class="operator">=</span> <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">didSet</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> isMatched &#123;</span><br><span class="line">                    stopUsingBonusTime()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> content: <span class="type">CardContent</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">        <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">            <span class="string">&quot;<span class="subst">\(id)</span>: <span class="subst">\(content)</span> <span class="subst">\(isFaceUp <span class="operator">?</span> <span class="string">&quot;up&quot;</span> : <span class="string">&quot;down&quot;</span>)</span><span class="subst">\(isMatched <span class="operator">?</span> <span class="string">&quot; matched&quot;</span> : <span class="string">&quot;&quot;</span>)</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MARK: - Bonus Time</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// call this when the card transitions to face up state</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">startUsingBonusTime</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> isFaceUp <span class="operator">&amp;&amp;</span> <span class="operator">!</span>isMatched <span class="operator">&amp;&amp;</span> bonusPercentRemaining <span class="operator">&gt;</span> <span class="number">0</span>, lastFaceUpDate <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                lastFaceUpDate <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call this when the card goes back face down or gets matched</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">stopUsingBonusTime</span>() &#123;</span><br><span class="line">            pastFaceUpTime <span class="operator">=</span> faceUpTime</span><br><span class="line">            lastFaceUpDate <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the bonus earned so far (one point for every second of the bonusTimeLimit that was not used)</span></span><br><span class="line">        <span class="comment">// this gets smaller and smaller the longer the card remains face up without being matched</span></span><br><span class="line">        <span class="keyword">var</span> bonus: <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="type">Int</span>(bonusTimeLimit <span class="operator">*</span> bonusPercentRemaining)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// percentage of the bonus time remaining</span></span><br><span class="line">        <span class="keyword">var</span> bonusPercentRemaining: <span class="type">Double</span> &#123;</span><br><span class="line">            bonusTimeLimit <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">?</span> <span class="built_in">max</span>(<span class="number">0</span>, bonusTimeLimit <span class="operator">-</span> faceUpTime)<span class="operator">/</span>bonusTimeLimit : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// how long this card has ever been face up and unmatched during its lifetime</span></span><br><span class="line">        <span class="comment">// basically, pastFaceUpTime + time since lastFaceUpDate</span></span><br><span class="line">        <span class="keyword">var</span> faceUpTime: <span class="type">TimeInterval</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> lastFaceUpDate &#123;</span><br><span class="line">                <span class="keyword">return</span> pastFaceUpTime <span class="operator">+</span> <span class="type">Date</span>().timeIntervalSince(lastFaceUpDate)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> pastFaceUpTime</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// can be zero which would mean &quot;no bonus available&quot; for matching this card quickly</span></span><br><span class="line">        <span class="keyword">var</span> bonusTimeLimit: <span class="type">TimeInterval</span> <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// the last time this card was turned face up</span></span><br><span class="line">        <span class="keyword">var</span> lastFaceUpDate: <span class="type">Date</span>?</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the accumulated time this card was face up in the past</span></span><br><span class="line">        <span class="comment">// (i.e. not including the current time it&#x27;s been face up if it is currently so)</span></span><br><span class="line">        <span class="keyword">var</span> pastFaceUpTime: <span class="type">TimeInterval</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-TimelineView"><a href="#2-1-TimelineView" class="headerlink" title="2.1 TimelineView"></a>2.1 <code>TimelineView</code></h3><p><code>TimeLineView</code> 是一个可以根据时间变化更新视图的组件。我们将动画时间间隔设置为 1&#x2F;5 秒，意味着每 200 毫秒会更新一次视图。</p>
<p>另外将 overlay 里边的视图提取为 <code>cardContent</code>，使代码更易读。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  CardView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.animation(minimumInterval: <span class="number">1</span> <span class="operator">/</span> <span class="number">5</span>)) &#123; timeline <span class="keyword">in</span></span><br><span class="line">			<span class="type">Pie</span>(endAngle: .degrees(card.bonusPercentRemaining <span class="operator">*</span> <span class="number">360</span>))</span><br><span class="line">				.opacity(<span class="type">Constants</span>.<span class="type">Pie</span>.opacity)</span><br><span class="line">				.overlay(</span><br><span class="line">					cardContents.padding(<span class="type">Constants</span>.<span class="type">Pie</span>.in<span class="keyword">set</span>)</span><br><span class="line">				)</span><br><span class="line">				.padding(<span class="type">Constants</span>.in<span class="keyword">set</span>)</span><br><span class="line">				.cardify(isFaceUp: card.isFaceUp)</span><br><span class="line">				.opacity(card.isFaceup <span class="operator">||</span> <span class="operator">!</span>card.isMatched <span class="operator">?</span> <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cardContents: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	        <span class="type">Text</span>(card.content)</span><br><span class="line">	            .font(.system(size: <span class="type">Constants</span>.<span class="type">FontSize</span>.largest))</span><br><span class="line">	            .minimumScaleFactor(<span class="type">Constants</span>.<span class="type">FontSize</span>.scaleFactor)</span><br><span class="line">	            .multilineTextAlignment(.center)</span><br><span class="line">	            .aspectRatio(<span class="number">1</span>, contentMode: .fit)</span><br><span class="line">	            .padding(<span class="type">Constants</span>.<span class="type">Pie</span>.in<span class="keyword">set</span>)</span><br><span class="line">	            .rotationEffect(.degrees(card.isMatched <span class="operator">?</span> <span class="number">360</span> : <span class="number">0</span>))</span><br><span class="line">	            .animation(.spin(duration: <span class="number">1</span>), value: card.isMatched)</span><br><span class="line">	    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Demo-transitions"><a href="#3-Demo-transitions" class="headerlink" title="3. Demo: transitions"></a>3. Demo: transitions</h2><blockquote>
<p><strong>animation the arrival and departure of Views</strong></p>
</blockquote>
<p>当匹配卡片消失时，仍然是翻转动画，但此时希望让匹配的卡片消失而非翻转。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  CardView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.animation(minimumInterval: <span class="number">1</span> <span class="operator">/</span> <span class="number">5</span>)) &#123; timeline i</span><br><span class="line">			<span class="keyword">if</span> card.isFaceUp <span class="operator">||</span> <span class="operator">!</span>card.isMatched &#123;</span><br><span class="line">				<span class="type">Pie</span>(endAngle: .degrees(card.bonusPercentRemaining <span class="operator">*</span> <span class="number">360</span>))</span><br><span class="line">					.opacity(<span class="type">Constants</span>.<span class="type">Pie</span>.opacity)</span><br><span class="line">					.overlay(</span><br><span class="line">						cardContents.padding(<span class="type">Constants</span>.<span class="type">Pie</span>.in<span class="keyword">set</span>)</span><br><span class="line">					)</span><br><span class="line">					.padding(<span class="type">Constants</span>.in<span class="keyword">set</span>)</span><br><span class="line">					.cardify(isFaceUp: card.isFaceUp)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-Color-clear-、transition"><a href="#3-1-Color-clear-、transition" class="headerlink" title="3.1 Color.clear 、transition"></a>3.1 <code>Color.clear</code> 、<code>transition</code></h3><p>此时，卡牌朝下且卡牌匹配时，view 为空，<code>AspectVGrid</code> 会认为此时没有 view，后边的卡片会挤压至前边来。为避免这种情况，使用 <code>Color.clear</code> 来保留一个看不到矩形空间。</p>
<p>在卡片消失时添加 <code>transition(.scale)</code> 动画。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  CardView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CardView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TimelineView</span>(.animation(minimumInterval: <span class="number">1</span> <span class="operator">/</span> <span class="number">5</span>)) &#123; timeline i</span><br><span class="line">			<span class="keyword">if</span> card.isFaceUp <span class="operator">||</span> <span class="operator">!</span>card.isMatched &#123;</span><br><span class="line">				<span class="type">Pie</span>(endAngle: .degrees(card.bonusPercentRemaining <span class="operator">*</span> <span class="number">360</span>))</span><br><span class="line">					.opacity(<span class="type">Constants</span>.<span class="type">Pie</span>.opacity)</span><br><span class="line">					.overlay(</span><br><span class="line">						cardContents.padding(<span class="type">Constants</span>.<span class="type">Pie</span>.in<span class="keyword">set</span>)</span><br><span class="line">					)</span><br><span class="line">					.padding(<span class="type">Constants</span>.in<span class="keyword">set</span>)</span><br><span class="line">					.cardify(isFaceUp: card.isFaceUp)</span><br><span class="line">					.transition(.scale)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">Color</span>.clear</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Demo-matchedGeometryEffect"><a href="#4-Demo-matchedGeometryEffect" class="headerlink" title="4. Demo: matchedGeometryEffect"></a>4. Demo: matchedGeometryEffect</h2><blockquote>
<p><strong>dealing our cards out</strong></p>
</blockquote>
<p>怎么发牌？我们需要首先让卡牌的容器视图 <code>Aspect</code> 出现在屏幕中，当卡牌容器一出现则开始发牌。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">	<span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	        <span class="type">AspectVGrid</span>(items: viewModel.cards, aspectRatio: aspectRatio) &#123; card <span class="keyword">in</span></span><br><span class="line">	            <span class="keyword">if</span> isDealt(card)&#123;</span><br><span class="line">	                <span class="type">CardView</span>(card)</span><br><span class="line">	                    .aspectRatio(aspectRatio, contentMode: .fit)</span><br><span class="line">	                    .padding(<span class="number">8</span>)</span><br><span class="line">	                    .overlay(<span class="type">FlyingNumber</span>(number: scoreChange(causedBy: card)))</span><br><span class="line">	                    .zIndex(scoreChange(causedBy: card) <span class="operator">!=</span> <span class="number">0</span> <span class="operator">?</span> <span class="number">100</span> : <span class="number">0</span>)</span><br><span class="line">	                    .onTapGesture &#123;</span><br><span class="line">	                        choose(card)</span><br><span class="line">	                    &#125;</span><br><span class="line">	                    .transition(.offset(</span><br><span class="line">	                    	x: <span class="type">CGFloat</span>.random(in: <span class="operator">-</span><span class="number">1000</span><span class="operator">...</span><span class="number">1000</span>),</span><br><span class="line">	                    	y: <span class="type">CGFloat</span>.random(in: <span class="operator">-</span><span class="number">1000</span><span class="operator">...</span><span class="number">1000</span>)</span><br><span class="line">	                    ))</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        .onAppear&#123;</span><br><span class="line">	            <span class="comment">// deal the cards</span></span><br><span class="line">	            withAnimation(.easeInOut(duration: <span class="number">2</span>)) &#123;</span><br><span class="line">	                <span class="keyword">for</span> card <span class="keyword">in</span> viewModel.cards &#123;</span><br><span class="line">	                    dealt.insert(card.id)</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> dealt <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Card</span>.<span class="type">ID</span>&gt;()</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">isDealt</span>(<span class="keyword">_</span> <span class="params">card</span>: <span class="type">Card</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">	        dealt.contains(card.id)</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">var</span> undealtCards: [<span class="type">Card</span>] &#123;</span><br><span class="line">	        viewModel.cards.filter&#123;<span class="operator">!</span>isDealt(<span class="variable">$0</span>)&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="operator">...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由于发牌这一动画只与 UI 有关，与 model 和 viewModel 都无关，所以可以创建一个私有的 <code>@State</code> 变量 <code>dealt</code> 来管理发牌的状态。</li>
<li>我们创建一个函数 <code>isDealt</code> 来判断卡片是否发牌，<code>undealtCards</code> 用于获取未发牌的卡片。</li>
<li>为卡片的出现添加 transition（从随机位置飞至卡片位置）</li>
<li>卡片容器视图中只出现发牌状态为 <code>true</code> 的卡片。</li>
</ul>
<p>使用预览无法观察 <code>onAppear</code> 的效果，这里需要使用模拟器进行观察。</p>
<p>我们希望卡片不是直接呈现在屏幕上，而是通过点击某一个地方，开始随机发牌。创建一个 <code>deck</code> 用于触发发牌事件。并将 <code>cards.onAppear()</code> 中的动作放置在 <code>deck.onTapGesture()</code> 中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            cards.foregroundColor(viewModel.color)</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                score</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                deck</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">                shuffle</span><br><span class="line">            &#125;</span><br><span class="line">            .font(.largeTitle)</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">AspectVGrid</span>(items: viewModel.cards, aspectRatio: aspectRatio) &#123; card <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> isDealt(card)&#123;</span><br><span class="line">                <span class="type">CardView</span>(card)</span><br><span class="line">                    .aspectRatio(aspectRatio, contentMode: .fit)</span><br><span class="line">                    .padding(<span class="number">8</span>)</span><br><span class="line">                    .overlay(<span class="type">FlyingNumber</span>(number: scoreChange(causedBy: card)))</span><br><span class="line">                    .zIndex(scoreChange(causedBy: card) <span class="operator">!=</span> <span class="number">0</span> <span class="operator">?</span> <span class="number">100</span> : <span class="number">0</span>)</span><br><span class="line">                    .onTapGesture &#123;</span><br><span class="line">                        choose(card)</span><br><span class="line">                    &#125;</span><br><span class="line">                    .transition(.offset(</span><br><span class="line">                        x: <span class="type">CGFloat</span>.random(in: <span class="operator">-</span><span class="number">1000</span><span class="operator">...</span><span class="number">1000</span>),</span><br><span class="line">                        y: <span class="type">CGFloat</span>.random(in: <span class="operator">-</span><span class="number">1000</span><span class="operator">...</span><span class="number">1000</span>)</span><br><span class="line">                    ))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> deck: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(undealtCards) &#123; card <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(card)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .frame(width: deckWidth, height: deckWidth <span class="operator">/</span> aspectRatio)</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            <span class="comment">// deal the cards</span></span><br><span class="line">            withAnimation(.easeInOut(duration: <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> card <span class="keyword">in</span> viewModel.cards &#123;</span><br><span class="line">                    dealt.insert(card.id)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> deckWidth: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">50</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-matchedGeometryEffect"><a href="#4-1-matchedGeometryEffect" class="headerlink" title="4.1 matchedGeometryEffect"></a>4.1 <code>matchedGeometryEffect</code></h3><p>我们想要卡片从 <code>deck</code> 消失后，出现在 <code>AspectVGrid</code> 中。通过在 <code>deck</code> 和 <code>AspectVGrid</code> 两个地方添加 <code>matchedGeometryEffect</code> 来实现这个动画。</p>
<p>在发牌的过程中，我们发现卡片在发出时为黑色的，我们不希望它是黑色的。当我们不希望出现某个动画时。</p>
<p>这里使用 <code>.transition(.asymmetric(insertion: .identity, removal: .identity) </code> 来清楚消失和出现时的动画效果，其中：</p>
<ul>
<li><code>.asymmetric</code> 表示插入和移除的动画效果不同。</li>
<li><code>insertion: .identity</code> 表示插入时没有额外的动画效果（即视图将立即出现在屏幕上）。</li>
<li><code>removal: .identity</code> 意味着在移除时同样没有任何动画效果。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cards: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">AspectVGrid</span>(items: viewModel.cards, aspectRatio: aspectRatio) &#123; card <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> isDealt(card)&#123;</span><br><span class="line">                <span class="type">CardView</span>(card)</span><br><span class="line">                    .matchedGeometryEffect(id: card.id, in: dealingNamespace)</span><br><span class="line">                    .transition(.asymmetric(insertion: .identity, removal: .identity))</span><br><span class="line">                    .aspectRatio(aspectRatio, contentMode: .fit)</span><br><span class="line">                    .padding(<span class="number">8</span>)</span><br><span class="line">                    .overlay(<span class="type">FlyingNumber</span>(number: scoreChange(causedBy: card)))</span><br><span class="line">                    .zIndex(scoreChange(causedBy: card) <span class="operator">!=</span> <span class="number">0</span> <span class="operator">?</span> <span class="number">100</span> : <span class="number">0</span>)</span><br><span class="line">                    .onTapGesture &#123;</span><br><span class="line">                        choose(card)</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Namespace</span> <span class="keyword">private</span> <span class="keyword">var</span> dealingNamespace</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> deck: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(undealtCards) &#123; card <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(card)</span><br><span class="line">                    .matchedGeometryEffect(id: card.id, in: dealingNamespace)</span><br><span class="line">                    .transition(.asymmetric(insertion: .identity, removal: .identity))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .frame(width: deckWidth, height: deckWidth <span class="operator">/</span> aspectRatio)</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            <span class="comment">// deal the cards</span></span><br><span class="line">            withAnimation(.easeInOut(duration: <span class="number">2</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> card <span class="keyword">in</span> viewModel.cards &#123;</span><br><span class="line">                    dealt.insert(card.id)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> deckWidth: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">50</span></span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常在发牌时，不会一次性发出，因此我们为发牌添加一些延迟。每一张牌间隔 0.15 s 发出。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> deck: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(undealtCards) &#123; card <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(card)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .frame(width: deckWidth, height: deckWidth <span class="operator">/</span> aspectRatio)</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            <span class="comment">// deal the cards</span></span><br><span class="line">            <span class="keyword">var</span> delay :<span class="type">TimeInterval</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> card <span class="keyword">in</span> viewModel.cards &#123;</span><br><span class="line">            	withAnimation(.easeInOut(duration: <span class="number">1</span>).delay(delay)) &#123;</span><br><span class="line">                    <span class="keyword">_</span> <span class="operator">=</span> dealt.insert(card.id)</span><br><span class="line">                &#125;</span><br><span class="line">                delay <span class="operator">+=</span> <span class="number">0.15</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> deckWidth: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">50</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-代码优化"><a href="#4-2-代码优化" class="headerlink" title="4.2 代码优化"></a>4.2 代码优化</h3><p>提取 constants 变量和动画效果，<code>onTapGesture</code> 交互动作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiMemoryGameView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiMemoryGameView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Card</span> <span class="operator">=</span> <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt;.<span class="type">Card</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">EmojiMemoryGame</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> aspectRatio: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">/</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> spacing: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> delayInterval <span class="operator">=</span> <span class="number">0.15</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> deckWidth: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">50</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> dealAnimation: <span class="type">Animation</span> <span class="operator">=</span> .easeInOut(duration: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Namespace</span> <span class="keyword">private</span> <span class="keyword">var</span> dealingNamespace</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> deck: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="type">ForEach</span>(undealtCards) &#123; card <span class="keyword">in</span></span><br><span class="line">                <span class="type">CardView</span>(card)</span><br><span class="line">                    .matchedGeometryEffect(id: card.id, in: dealingNamespace)</span><br><span class="line">                    .transition(.asymmetric(insertion: .identity, removal: .identity))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .frame(width: deckWidth, height: deckWidth <span class="operator">/</span> aspectRatio)</span><br><span class="line">        .onTapGesture &#123;</span><br><span class="line">            deal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">deal</span>() &#123;</span><br><span class="line">        <span class="keyword">var</span> delay: <span class="type">TimeInterval</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> card <span class="keyword">in</span> viewModel.cards &#123;</span><br><span class="line">            withAnimation(dealAnimation.delay(delay)) &#123;</span><br><span class="line">                <span class="keyword">_</span> <span class="operator">=</span> dealt.insert(card.id)</span><br><span class="line">            &#125;</span><br><span class="line">            delay <span class="operator">+=</span> <span class="number">0.15</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
  <entry>
    <title>个人前端学习路径分享｜附项目及常用工具</title>
    <url>/2025/02/19/%E4%B8%AA%E4%BA%BA%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%E5%88%86%E4%BA%AB%EF%BD%9C%E9%99%84%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>本文为个人前端学习路径分享，主要分享前端学习路线，前端三件套，前端项目推荐，前端框架，前端相关工具，其他常用工具资源等。</p>
<span id="more"></span>

<ul>
<li><p><strong>了解学习路线（10 分钟）</strong></p>
<blockquote>
<p>快速了解前端和全栈的技术栈和学习路线（非常重要）。</p>
</blockquote>
<ul>
<li><p>**前端学习路线 (油管，约 9 分钟)**：<a href="https://www.youtube.com/watch?v=Tef1e9FiSR0">The Complete Frontend Developer Roadmap 2024</a></p>
</li>
<li><p><strong>全栈学习路线（油管，15 分钟）</strong>：<a href="https://www.youtube.com/watch?v=GxmfcnU3feo">The Complete Web Development Roadmap 2024</a></p>
</li>
<li><p><strong>前端三件套（2-3 个月）</strong></p>
<ul>
<li><p><strong>HTML+CSS（1 个月）</strong>：<a href="https://www.bilibili.com/video/BV14J4114768/?spm_id_from=333.337.search-card.all.click&vd_source=9a40fb262d68cbd3e674569c050a1028">黑马 pink 零基础 h5+css3+移动端视频教程｜ B 站 pink</a></p>
<blockquote>
<p>pink 老师的课程分节都很细很短（1-10 分钟&#x2F;节），课程分节很细，一小节的时长很短（大部分 5 -15 分钟），可以根据每天的时间调整观看的数量，建议每天都要看，不论看多少。（每天定一小节的任务，能减小学习的阻力，通常会是超额完成）</p>
</blockquote>
</li>
<li><p><strong>JavaScript（1 个月）</strong></p>
<blockquote>
<p>看完第一个，第二个从第 191 集开始看，后续如果遇到不明白的，再往前跳到对应节点看即可。如果由于科学上网问题，第一个无法观看，建议从第二个第 1 集开始看。</p>
</blockquote>
<ul>
<li><strong>JS 基础（一周）</strong>：<a href="https://www.youtube.com/watch?v=PkZNo7MFNFg&t=44s">JavaScript Beginer ｜油管 freeCodeCamp</a></li>
<li><strong>js web api（一个月）</strong>：<a href="https://www.bilibili.com/video/BV1Sy4y1C7ha?spm_id_from=333.788.videopod.episodes&vd_source=9a40fb262d68cbd3e674569c050a1028&p=191">JavaScript 前端课程-dom-bom-js-es6 新语法｜ B 站 pink 老师</a></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>练习项目推荐</strong>：</p>
<blockquote>
<p>建议在学完 web api 后可以合适的项目做，边做边学 React 或者 Vue，React 或 Vue 学得差不多了，同样在这找项目做。</p>
</blockquote>
<ul>
<li>这个就够用了： <a href="https://github.com/florinpop17/app-ideas">florinpop17 ｜ app-ideas ｜ github</a>。有分别对应初学者、中级、高级三个阶段的项目和参考源码。</li>
<li>补充项目：<a href="https://github.com/KelvinQiu802/project-ideas?tab=readme-ov-file">kelvinQiu802 ｜项目构想｜ github</a></li>
</ul>
</li>
<li><p><strong>前端框架</strong>：</p>
<blockquote>
<p>React 的视频教程较少，建议直接看官方文档，非常简洁易懂，小白推荐。</p>
</blockquote>
<ul>
<li><strong>React</strong>：<a href="https://react.docschina.org/learn">React 中文官网</a></li>
</ul>
</li>
<li><p><strong>前端相关工具或资源</strong></p>
<ul>
<li>资源集锦：<a href="https://docschina.org/">印记中文</a>。收集了编译构建（webpack、babel 等）、前端框架（React、Vue、Angular）、前端组件库（AntDesign、MaterialUI、）及可视化图表组件库等大量前端开发学习地址。</li>
<li>UI 组件源码：<a href="https://uiverse.io/">uiverse</a>，<a href="https://codepen.io/trending">codePen</a></li>
<li>css 背景渐变：<a href="https://webgradients.com/">css ｜ webgradients</a></li>
<li>css 动画：<a href="https://animista.net/">animista</a></li>
</ul>
</li>
<li><p><strong>其他常用工具资源</strong></p>
<ul>
<li>计算机自学指南：<a href="https://csdiy.wiki/">cs 自学指南</a>。⭐⭐⭐⭐⭐，超级宝藏的博客，包含了：必学工具（科学上网，git，vim，docker…）、数学基础，编程基础（python、c、java、）、数据结构，人工智能，深度学习等大量优秀的 cs 国内外课程收集及经验分享。</li>
<li>网页转 markdown 浏览器插件：<strong>obsidian webcliper</strong>。⭐⭐⭐⭐⭐，网页转存 markdown 自动保存在 obsidian 仓库文件夹，可修改并导出为 pdf 格式，相比直接导出图片 pdf 更方便美观。效果如下（从左至右为网站、markdown、pdf）。<br><img src="/2025/02/19/%E4%B8%AA%E4%BA%BA%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%E5%88%86%E4%BA%AB%EF%BD%9C%E9%99%84%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%B8%AA%E4%BA%BA%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84%E5%88%86%E4%BA%AB%EF%BD%9C%E9%99%84%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7-1.png" alt="个人前端学习路径分享｜附项目及常用工具-1"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Stanford-cs193p-10｜EmojiArt</title>
    <url>/2025/01/24/Stanford-cs193p-10%EF%BD%9CEmojiArt/</url>
    <content><![CDATA[<p>本文是斯坦福大学 cs193p 公开课程第 10 集的相关笔记。</p>
<span id="more"></span>

<p>cs193p 课程介绍:</p>
<blockquote>
<p>The lectures for the Spring 2023 version of Stanford University’s course CS193p (Developing Applications for iOS using SwiftUI) were given in person but, unfortunately, were not video recorded. However, we did capture the laptop screen of the presentations and demos as well as the associated audio. You can watch these screen captures using the links below. You’ll also find links to supporting material that was distributed to students during the quarter (homework, demo code, etc.).</p>
</blockquote>
<p>cs193p 课程网址: [<a href="https://cs193p.sites.stanford.edu/2023]">https://cs193p.sites.stanford.edu/2023]</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这堂课会使用 MVVM 架构再创建一个 app：EmojiArt，并且在当中实现外部 URL 和内部 String 的拖拽，multiple MVVM。</p>
<h2 id="1-MVVM-初实现"><a href="#1-MVVM-初实现" class="headerlink" title="1. MVVM 初实现"></a>1. MVVM 初实现</h2><h3 id="1-1-创建-Model-EmojiArt"><a href="#1-1-创建-Model-EmojiArt" class="headerlink" title="1.1 创建 Model EmojiArt"></a>1.1 创建 <code>Model</code> EmojiArt</h3><p>新建一个 swift 文件，用于创建 <code>EmojiArt</code>（Model）存储背景、表情符号、大小和位置。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArt.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiArt</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> background: <span class="type">URL</span>?</span><br><span class="line">    <span class="keyword">var</span> emojis <span class="operator">=</span> [<span class="type">Emoji</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Emoji</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> string: <span class="type">String</span></span><br><span class="line">        <span class="keyword">var</span> position: <span class="type">Position</span></span><br><span class="line">        <span class="keyword">var</span> size: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Position</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">            <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-2-创建-ViewModel-EmojiArtDocument"><a href="#1-2-创建-ViewModel-EmojiArtDocument" class="headerlink" title="1.2 创建 ViewModel EmojiArtDocument"></a>1.2 创建 <code>ViewModel</code> EmojiArtDocument</h3><p>新建一个 swift 文件，用于创建 <code>EmojiArtDocument</code> (ViewModel)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocument.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiArtDocument</span>:<span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Emoji</span> <span class="operator">=</span> <span class="type">EmojiArt</span>.<span class="type">Emoji</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> emojiArt <span class="operator">=</span> <span class="type">EmojiArt</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> emojis: [<span class="type">Emoji</span>] &#123;</span><br><span class="line">        emojiArt.emojis</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> background: <span class="type">URL</span>?&#123;</span><br><span class="line">        emojiArt.background</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">setBackground</span>(<span class="keyword">_</span> <span class="params">url</span>: <span class="type">URL</span>?) &#123;</span><br><span class="line">        emojiArt.background <span class="operator">=</span> url</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-3-创建-View-EmojiArtDocument"><a href="#1-3-创建-View-EmojiArtDocument" class="headerlink" title="1.3 创建 View EmojiArtDocument"></a>1.3 创建 <code>View</code> EmojiArtDocument</h3><p>创建一个 <code>swiftUI</code> 文件，用于创建 <code>EmojiArtDocumentView</code> (View)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocumentView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiArtDocumentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> emojis <span class="operator">=</span> <span class="string">&quot;👻🍎😃🤪☹️🤯🐶🐭🦁🐵🦆🐝🐢🐄🐖🌲🌴🌵🍄🌞🌎🔥🌈🌧️🌨️☁️⛄️⛳️🚗🚙🚓🚲🛺🏍️🚘✈️🛩️🚀🚁🏰🏠❤️💤⛵️&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> paletteEmojiSize:<span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">40</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> (spacing:<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">Color</span>.yellow</span><br><span class="line">            <span class="type">ScrollingEmojis</span>(emojis)</span><br><span class="line">                .font(.system(size: paletteEmojiSize))</span><br><span class="line">                .padding(.horizontal)</span><br><span class="line">				<span class="comment">// 隐藏底部的滚动栏</span></span><br><span class="line">                .scrollIndicators(.hidden)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望滚动表情在底部</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScrollingEmojis</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> emojis: [<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">emojis</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="comment">// String.init 用于创建字符串实例，例如let Str = String(123), 等价于let str = String.init(123)</span></span><br><span class="line">		<span class="comment">// 这里作用是将 emojis:String 转为 [String] 类型</span></span><br><span class="line">        <span class="keyword">self</span>.emojis <span class="operator">=</span> emojis.uniqued.map(<span class="type">String</span>.<span class="keyword">init</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ScrollView</span>(.horizontal)&#123;</span><br><span class="line">            <span class="type">HStack</span> &#123;</span><br><span class="line">                <span class="type">ForEach</span>(emojis, id:\.<span class="keyword">self</span>) &#123; emoji <span class="keyword">in</span></span><br><span class="line">                    <span class="type">Text</span>(emoji)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="type">Preview</span> &#123;</span><br><span class="line">    <span class="type">EmojiArtDocumentView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的视图如下：<br><img src="/2025/01/24/Stanford-cs193p-10%EF%BD%9CEmojiArt/Stanford-cs193p-10%EF%BD%9CEmojArt-1.png" alt="Stanford-cs193p-10｜EmojArt-1"></p>
<h2 id="2-功能扩展与改进"><a href="#2-功能扩展与改进" class="headerlink" title="2. 功能扩展与改进"></a>2. 功能扩展与改进</h2><h3 id="2-1-添加背景支持"><a href="#2-1-添加背景支持" class="headerlink" title="2.1 添加背景支持"></a>2.1 添加背景支持</h3><p>添加一个私有视图变量 <code>documentBody</code>，确保背景外部区域为白色。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocumentView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiArtDocumentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> document: <span class="type">EmojiArtDocument</span></span><br><span class="line"></span><br><span class="line"> 	<span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> documentBody: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ZStack</span> &#123;</span><br><span class="line">            <span class="comment">//希望 图片两边是白色的（最底层为白色）</span></span><br><span class="line">            <span class="type">Color</span>.white</span><br><span class="line">            <span class="type">ForEach</span>(document.emojis) &#123; emoji <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(emoji.string)</span><br><span class="line">                    .font(emoji.font)</span><br><span class="line">                    .position(emoji.position)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-添加-ObservedObject"><a href="#2-2-添加-ObservedObject" class="headerlink" title="2.2 添加 ObservedObject"></a>2.2 添加 <code>ObservedObject</code></h3><p>在 <code>EmojiArtApp</code> 中创建 <code>EmojiArtDocument</code> 的状态对象。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtApp.swift</span></span><br><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiArtApp</span>: <span class="title class_ inherited__">App</span> &#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">var</span> defaultDocument <span class="operator">=</span> <span class="type">EmojiArtDocument</span>()</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> &#123;</span><br><span class="line">        <span class="type">WindowGroup</span> &#123;</span><br><span class="line">            <span class="type">EmojiArtDocumentView</span>(document: defaultDocument)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时还出现一个错误 <code>Referencing initializer &#39;init(_:content:)&#39; on &#39;ForEach&#39; requires that &#39;EmojiArtDocument.Emoji&#39; (aka &#39;EmojiArt.Emoji&#39;) conform to &#39;Identifiable&#39;</code> 表明需要 <code>Emoji</code> 遵循 <code>Identifiable</code> 协议。</p>
<h3 id="2-3-实现-Identifiable-协议"><a href="#2-3-实现-Identifiable-协议" class="headerlink" title="2.3 实现 Identifiable 协议"></a>2.3 实现 <code>Identifiable</code> 协议</h3><p>通过唯一标识符支持 ForEach 的迭代，并为表情符号提供添加方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArt.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiArt</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> background: <span class="type">URL</span>?</span><br><span class="line">    <span class="comment">// 确保只有 Model 可以修改emojis，其余只能读取</span></span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> emojis <span class="operator">=</span> [<span class="type">Emoji</span>]()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设定初始 id 值为 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> uniqueEmojiId <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">addEmoji</span>(<span class="keyword">_</span> <span class="params">emoji</span>: <span class="type">String</span>, <span class="params">at</span> <span class="params">position</span>: <span class="type">Emoji</span>.<span class="type">Position</span>, <span class="params">size</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        uniqueEmojiId <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        emojis.append(<span class="type">Emoji</span>(</span><br><span class="line">            string: emoji,</span><br><span class="line">            position: position,</span><br><span class="line">            size: size,</span><br><span class="line">            id: uniqueEmojiId</span><br><span class="line">        ))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Emoji</span> : <span class="title class_ inherited__">Identifiable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> string: <span class="type">String</span></span><br><span class="line">        <span class="keyword">var</span> position: <span class="type">Position</span></span><br><span class="line">        <span class="keyword">var</span> size: <span class="type">Int</span></span><br><span class="line">        <span class="comment">// 每次添加表情符号时，都会使id+1</span></span><br><span class="line">        <span class="keyword">var</span> id: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Position</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">            <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为表情数组添加表情的操作属于用户意图，我们需要在 <code>ViewModel</code> EmojiArtDocument 中添加 addEmoji 方法以便在 UI 视图中调用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocument.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiArtDocument</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addEmoji</span>(<span class="keyword">_</span> <span class="params">emoji</span>:<span class="type">String</span>,<span class="params">at</span> <span class="params">position</span>:<span class="type">Emoji</span>.<span class="type">Position</span>,<span class="params">size</span>:<span class="type">CGFloat</span>) &#123;</span><br><span class="line">        emojiArt.addEmoji(emoji, at: position, size: <span class="type">Int</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时 <code>EmojiArtDocumentView</code> 会发现有错误 <code>Value of type &#39;EmojiArtDocument.Emoji&#39; (aka &#39;EmojiArt.Emoji&#39;) has no member &#39;font&#39;</code>，即 Emoji 结构体没有 font 成员。<code>font</code> 属于 UI 视图的组成，而 Emoji 属于 Model ，无法使得 <code>font</code> 出现在 Model 中，但可以使用 extension 为 Emoji 添加扩展，将这个扩展添加在 ViewModel 中会更好。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocument.swift</span></span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">EmojiArt</span>.<span class="type">Emoji</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> font: <span class="type">Font</span> &#123;</span><br><span class="line">        <span class="type">Font</span>.system(size: <span class="type">CGFloat</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到 View，<code>.position</code> 仍然会报错 <code>Cannot convert value of type &#39;EmojiArt.Emoji.Position&#39; to expected argument type &#39;CGPoint&#39;</code>。</p>
<p>我们将 View 中的黄色背景替换为 <code>documentBody</code>，希望利用 GeometryReader 来获取这个 Emoji 在视图中的位置，在 <code>ViewModel</code> 中添加一个扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocumentView.swift</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiArtDocumentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> document: <span class="type">EmojiArtDocument</span></span><br><span class="line"></span><br><span class="line"> 	<span class="operator">...</span></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	<span class="type">VStack</span> (spacing:<span class="number">0</span>)&#123;</span><br><span class="line">		documentBody</span><br><span class="line">		<span class="type">ScrollingEmojis</span>(emojis)</span><br><span class="line">			.font(.system(size: paletteEmojiSize))</span><br><span class="line">			.padding(.horizontal)</span><br><span class="line">			.scrollIndicators(.hidden)</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> documentBody: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	   <span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">		   <span class="type">ZStack</span> &#123;</span><br><span class="line">			   <span class="comment">//希望 图片两边是白色的（最底层为白色）</span></span><br><span class="line">			   <span class="type">Color</span>.white</span><br><span class="line">			   <span class="type">ForEach</span>(document.emojis) &#123; emoji <span class="keyword">in</span></span><br><span class="line">				   <span class="type">Text</span>(emoji.string)</span><br><span class="line">					   .font(emoji.font)</span><br><span class="line">					   .position(emoji.position.in(geometry))</span><br><span class="line">			   &#125;</span><br><span class="line">		   &#125;</span><br><span class="line">	   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line">#<span class="type">Preview</span> &#123;</span><br><span class="line">    <span class="type">EmojiArtDocumentView</span>(document: <span class="type">EmojiArtDocument</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocument.swift</span></span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">EmojiArt</span>.<span class="type">Emoji</span>.<span class="type">Position</span> &#123;</span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">`in`</span>(<span class="keyword">_</span> <span class="params">geometry</span>:<span class="type">GeometryProxy</span>) -&gt; <span class="type">CGPoint</span> &#123;</span><br><span class="line">		<span class="comment">// center 为页面中心</span></span><br><span class="line">		<span class="comment">//.frame().center 通过扩展实现，见extension.swift</span></span><br><span class="line">		<span class="keyword">let</span> center <span class="operator">=</span> geometry.frame(in: .local).center</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGPoint</span>(x: center.x <span class="operator">+</span> <span class="type">CGFloat</span>(x), y: center.y <span class="operator">-</span> <span class="type">CGFloat</span>(y))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Keyword &#39;in&#39; cannot be used as an identifier here</code>, <code>in</code> 作为常用的闭包中的关键词，不能用作函数名称，需要为其添加反引号才能正常使用。</li>
</ul>
<p>在 ViewModel 中添加初始化：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocument.swift</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmojiArtDocument</span>: <span class="title class_ inherited__">ObservableObject</span> &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        emojiArt.addEmoji(<span class="string">&quot;🚴&quot;</span>, at: .<span class="keyword">init</span>(x: <span class="operator">-</span><span class="number">200</span>, y: <span class="operator">-</span><span class="number">150</span>), size: <span class="number">200</span>)</span><br><span class="line">        emojiArt.addEmoji(<span class="string">&quot;🔥&quot;</span>, at: .<span class="keyword">init</span>(x: <span class="number">150</span>, y: <span class="number">150</span>), size: <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时的预览如下：</p>
<p><img src="/2025/01/24/Stanford-cs193p-10%EF%BD%9CEmojiArt/Stanford-cs193p-10%EF%BD%9CEmojArt-2.png" alt="Stanford-cs193p-10｜EmojArt-2"></p>
<h2 id="3-背景图片增强"><a href="#3-背景图片增强" class="headerlink" title="3. 背景图片增强"></a>3. 背景图片增强</h2><h3 id="3-1-AsyncImage-背景图片添加"><a href="#3-1-AsyncImage-背景图片添加" class="headerlink" title="3.1 AsyncImage 背景图片添加"></a>3.1 <code>AsyncImage</code> 背景图片添加</h3><p><code>AsyncImage</code> 在外部获取图像时会放置一个灰色盒子，当图像返回时，会异步显示。设定背景位置为 geometry 中的原点（0,0）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocumentView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiArtDocumentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Emoji</span> <span class="operator">=</span> <span class="type">EmojiArt</span>.<span class="type">Emoji</span></span><br><span class="line"></span><br><span class="line">	<span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> documentBody: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">            <span class="type">ZStack</span> &#123;</span><br><span class="line">                <span class="comment">//希望 图片两边是白色的（最底层为白色）</span></span><br><span class="line">                <span class="type">Color</span>.white</span><br><span class="line">                <span class="type">AsyncImage</span>(url: document.background)</span><br><span class="line">                    .position(<span class="type">Emoji</span>.<span class="type">Position</span>.zero.in(geometry))</span><br><span class="line">                <span class="type">ForEach</span>(document.emojis) &#123; emoji <span class="keyword">in</span></span><br><span class="line">                    <span class="type">Text</span>(emoji.string)</span><br><span class="line">                        .font(emoji.font)</span><br><span class="line">                        .position(emoji.position.in(geometry))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArt.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiArt</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Emoji</span> : <span class="title class_ inherited__">Identifiable</span>&#123;</span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Position</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">            <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">let</span> zero <span class="operator">=</span> <span class="keyword">Self</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-拖拽功能实现"><a href="#4-拖拽功能实现" class="headerlink" title="4. 拖拽功能实现"></a>4. 拖拽功能实现</h2><h3 id="4-1-拖拽功能简介"><a href="#4-1-拖拽功能简介" class="headerlink" title="4.1 拖拽功能简介"></a>4.1 拖拽功能简介</h3><p>拖放操作非常简单，只需要将要传输的数据表示为一个 <code>Transferable</code> 对象。常用的数据结构，如 <code>String</code>、<code>Int</code>、<code>Data</code> 等，都实现了 <code>Transferable</code>协议。</p>
<p>要使一个视图成为拖动的发起者，只需应用 <code>draggable(Transferable)</code> 修饰符即可。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">&quot;😊&quot;</span>).draggable(<span class="string">&quot;😊&quot;</span>) <span class="comment">// emoji 是一个 String</span></span><br></pre></td></tr></table></figure>

<p>当用户按住并拖动时，整个文本会开始拖动。被拖动的数据（即 <strong>Transferable</strong> 对象）将是这个 emoji 字符串。</p>
<h3 id="4-2-Transferable-协议"><a href="#4-2-Transferable-协议" class="headerlink" title="4.2 Transferable 协议"></a>4.2 Transferable 协议</h3><p>一个视图可以被放置在具有 <code>dropDestination</code> 修饰符的目标上。示例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> highlighted <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="type">Rectangle</span>()</span><br><span class="line">    .stroke(lineWidth: highlighted <span class="operator">?</span> <span class="number">5</span> : <span class="number">1</span>)</span><br><span class="line">    .dropDestination(for: <span class="type">String</span>.<span class="keyword">self</span>) &#123; [<span class="type">String</span>, <span class="type">CGPoint</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// 处理被放置在 Rectangle 中的字符串和 CGPoint</span></span><br><span class="line">    &#125; isTargeted: &#123; isTargeted: <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// 高亮或其他方式指示有东西可以放置</span></span><br><span class="line">        highlighted <span class="operator">=</span> isTargeted</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>遗憾的是，每个视图只能有一个 <code>dropDestination</code>。因此，如果希望在同一视图上放置 <code>String</code> 和 <code>Int</code>，您需要创建一个自定义的 <code>Transferable</code>。接下来，在演示中具体说明这个过程。</p>
<h3 id="4-3-Demo-实现图片拖拽"><a href="#4-3-Demo-实现图片拖拽" class="headerlink" title="4.3 Demo-实现图片拖拽"></a>4.3 Demo-实现图片拖拽</h3><p>现在实现从网页中拖拽图片作为当前背景图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocumentView.swift</span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiArtDocumentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> documentBody: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">            <span class="type">ZStack</span> &#123;</span><br><span class="line">                <span class="comment">//希望 图片两边是白色的（最底层为白色）</span></span><br><span class="line">                <span class="type">Color</span>.white</span><br><span class="line">                <span class="type">AsyncImage</span>(url: document.background)</span><br><span class="line">                    .position(<span class="type">Emoji</span>.<span class="type">Position</span>.zero.in(geometry))</span><br><span class="line">                <span class="type">ForEach</span>(document.emojis) &#123; emoji <span class="keyword">in</span></span><br><span class="line">                    <span class="type">Text</span>(emoji.string)</span><br><span class="line">                        .font(emoji.font)</span><br><span class="line">                        .position(emoji.position.in(geometry))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .dropDestination(for:<span class="type">URL</span>.<span class="keyword">self</span>) &#123; urls,location <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> drop(urls,at:location, in: geometry)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">drop</span>(<span class="keyword">_</span> <span class="params">urls</span>:[<span class="type">URL</span>], <span class="params">at</span> <span class="params">location</span>:<span class="type">CGPoint</span>, <span class="params">in</span> <span class="params">geomery</span>: <span class="type">GeometryProxy</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> urls.first &#123;</span><br><span class="line">            document.setBackground(url)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时我们可以实现外部图片的拖拽，但是不能同时实现 URL 和 String 的拖拽，即不能再添加一个 <code>dropDestination</code>。</p>
<h3 id="4-4-实现表情和图片拖拽"><a href="#4-4-实现表情和图片拖拽" class="headerlink" title="4.4 实现表情和图片拖拽"></a>4.4 实现表情和图片拖拽</h3><p>我们将课程源代码中的 <code>Sturldata.swift</code> 文件拖拽到当前项目文件夹下，并在 View 中定义拖拽的回调逻辑。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  EmojiArtDocumentView.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmojiArtDocumentView</span>: <span class="title class_ inherited__">View</span> &#123;</span><br><span class="line">    <span class="operator">...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> documentBody: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">            <span class="type">ZStack</span> &#123;</span><br><span class="line">                <span class="comment">//希望 图片两边是白色的（最底层为白色）</span></span><br><span class="line">                <span class="type">Color</span>.white</span><br><span class="line">                <span class="type">AsyncImage</span>(url: document.background)</span><br><span class="line">                    .position(<span class="type">Emoji</span>.<span class="type">Position</span>.zero.in(geometry))</span><br><span class="line">                <span class="type">ForEach</span>(document.emojis) &#123; emoji <span class="keyword">in</span></span><br><span class="line">                    <span class="type">Text</span>(emoji.string)</span><br><span class="line">                        .font(emoji.font)</span><br><span class="line">                        .position(emoji.position.in(geometry))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .dropDestination(for:<span class="type">Sturldata</span>.<span class="keyword">self</span>) &#123; sturldatas,location <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> drop(sturldatas,at:location, in: geometry)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">drop</span>(<span class="keyword">_</span> <span class="params">sturldatas</span>:[<span class="type">Sturldata</span>], <span class="params">at</span> <span class="params">location</span>:<span class="type">CGPoint</span>, <span class="params">in</span> <span class="params">geometry</span>: <span class="type">GeometryProxy</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> sturldata <span class="keyword">in</span> sturldatas &#123;</span><br><span class="line">            <span class="keyword">switch</span> sturldata &#123;</span><br><span class="line">            <span class="keyword">case</span> .url(<span class="keyword">let</span> url):</span><br><span class="line">                document.setBackground(url)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">case</span> .string(<span class="keyword">let</span> emoji):</span><br><span class="line">                document.addEmoji(</span><br><span class="line">                    emoji,</span><br><span class="line">                    at:emojiPosition(at: location, in: geometry),</span><br><span class="line">                    size:paletteEmojiSize</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">emojiPosition</span>(<span class="params">at</span> <span class="params">location</span>: <span class="type">CGPoint</span>, <span class="params">in</span> <span class="params">geometry</span>: <span class="type">GeometryProxy</span>) -&gt; <span class="type">Emoji</span>.<span class="type">Position</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> center <span class="operator">=</span> geometry.frame(in: .local).center</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Emoji</span>.<span class="type">Position</span>(</span><br><span class="line">            x: <span class="type">Int</span>(location.x <span class="operator">-</span> center.x),</span><br><span class="line">            y: <span class="type">Int</span>(<span class="operator">-</span>(location.y <span class="operator">-</span> center.y))</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时，已经可以实现 URL 和 String 的同时拖拽。</p>
]]></content>
      <categories>
        <category>code</category>
        <category>swift</category>
      </categories>
      <tags>
        <tag>cs193p</tag>
      </tags>
  </entry>
</search>
